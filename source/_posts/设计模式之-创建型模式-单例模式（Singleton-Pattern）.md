---
title: 设计模式之-创建型模式-单例模式（Singleton Pattern）
top: false
cover: false
toc: true
mathjax: false
date: 2021-06-29 16:28:10
password:
summary: Singleton Pattern
tags:
	- PHP
	- 面向对象
categories:
	- PHP设计模式
---


# 设计模式之-单例模式（Singleton Pattern）

---

### 1. 模式动机

对于系统中的某些类来说，只有一个实例很重要，例如，一个系统只能有一个计时工具或ID（序号）生成器；一个系统中只能有一个锁定应用程序的文件。

如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。

一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。


### 2. 模式定义

单例模式（Singleton Pattern）：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：

* 一是某个类只能有一个实例

* 二是它必须自行创建这个实例

* 三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式


### 3. 代码示例

* Singleton.php

```php
<?php
/**
 * Singleton
 *
 * @author     <dendi875@163.com>
 * @createDate 2018-03-02 14:12:28
 * @copyright  Copyright (c) 2019 dendi875@163.com
 */

final class Singleton
{
    private static $instance;

    /**
     * 提供一个公有的静态方法
     *
     * @return Singleton
     */
    public static function getInstance(): Singleton
    {
        if (static::$instance === null) {
            static::$instance = new static();
        }

        return static::$instance;
    }

    /**
     * 不允许从外部调用，以防止创建多个实例，
     * 要使用单例，必须从 Singleton::getInstance() 获取实例
     */
    private function __construct()
    {
    }

    /**
     * 防止实例被克隆（这将创建它的第二个实例）
     */
    private function __clone()
    {
    }

    /**
     * 防止被反序列化（这将创建它的第二个实例）
     */
    private function __wakeup()
    {
    }
}
```

### 4. 模式分析

单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——**Singleton**。单例类拥有一个私有构造函数，确保用户无法通过`new`关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的方法，该方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。

在单例模式的实现过程中，需要注意如下三点：

* 单例类的构造函数为私有

* 提供一个自身的静态私有成员变量

* 提供一个公有的静态方法

### 5. UML类图

简单工厂模式实现的计算器示例代码UML图：

![singleton](https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/singleton.png)

### 6. 优点

* 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。

* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。

### 7. 缺点

* 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难

* 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、PHP)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。


### 8. 适用场景

以下情况可以使用单例模式：

* 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象

* 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例

* 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式

### 9. 模式应用

* 数据库连接器

* 一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现

### 10. 总结

* 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。

* 单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。

* 单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过`new`关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的方法。该方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。