<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Istio 简介和安装</title>
      <link href="/2022/09/15/istio-jian-jie-he-an-zhuang/"/>
      <url>/2022/09/15/istio-jian-jie-he-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Istio-安装"><a href="#Istio-安装" class="headerlink" title="Istio 安装"></a>Istio 安装</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><p>macOS Catalina 版本 10.15.6</p></li><li><p>minikube version: v1.12.0</p></li><li><p>kubernetes-version: v1.16.0</p></li><li><p>istioctl version: 1.5.1</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>&nbsp;安装官方文档说明 <a href="https://istio.io/latest/docs/setup/platform-setup/minikube/">https://istio.io/latest/docs/setup/platform-setup/minikube/</a> 进行安装，但要注意 istio 与 k8s 版本之间的兼容性，兼容性参考：<a href="https://istio.io/latest/docs/releases/supported-releases/">https://istio.io/latest/docs/releases/supported-releases/</a></p><ul><li>执行以下命令，启动一个单节点的 k8s 集群</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops [23:42:20] $ minikube start --memory=16384 --cpus=4 --image-mirror-country='cn' --image-repository='registry.cn-hangzhou.aliyuncs.com/google_containers' --kubernetes-version=v1.16.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在 <a href="https://github.com/istio/istio/releases">GitHub Release 页面 </a>获取对应系统版本下载地址</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops [16:35:30] $ wget https://storage.googleapis.com/istio-release/releases/1.5.1/istio-1.5.1-osx.tar.gz # zhangquan @ MacBook-Pro in ~/Downloads/devops [16:51:41] $ tar -zxvf istio-1.5.1-osx.tar.gz# 把 istioctl 命令添加到环境变量中export ISTIO_HOME=/Users/zhangquan/Downloads/devops/istio-1.5.1/binexport PATH=$PATH:$ISTIO_HOME# zhangquan @ MacBook-Pro in ~/Downloads/devops [16:52:54] $ ll istio-1.5.1total 48-rw-r--r--   1 zhangquan  staff    11K  3 24  2020 LICENSE-rw-r--r--   1 zhangquan  staff   5.7K  3 24  2020 README.mddrwxr-x---   3 zhangquan  staff    96B  3 24  2020 bindrwxr-xr-x   7 zhangquan  staff   224B  3 24  2020 install-rw-r-----   1 zhangquan  staff   595B  3 24  2020 manifest.yamldrwxr-xr-x  20 zhangquan  staff   640B  3 24  2020 samplesdrwxr-x---   6 zhangquan  staff   192B  3 24  2020 tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 istio 中包含以下几部分内容</p><ul><li>bin: 有我们要使用的 <code>istioctl </code> 命令行工具</li><li>install: 包含了几个平台的安装清单</li><li>samples: 官方提供一些示例程序</li></ul><p>istio 提供了一些配置档案，也就是<code>Profile</code>，它的目的就是让你在不同应用场景去安装不同的版本</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220912170726.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220912170843.png">安装 istio 的工具和文件准备好过后，直接执行如下所示的安装命令即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [17:10:27] $ istioctl manifest apply --set profile=demoDetected that your cluster does not support third party JWT authentication. Falling back to less secure first party JWT. See https://istio.io/docs/ops/best-practices/security/#configure-third-party-service-account-tokens for details.- Applying manifest for component Base...✔ Finished applying manifest for component Base.- Applying manifest for component Pilot...✔ Finished applying manifest for component Pilot.  Waiting for resources to become ready.........  Waiting for resources to become ready...- Applying manifest for component EgressGateways...- Applying manifest for component IngressGateways...- Applying manifest for component AddonComponents...✔ Finished applying manifest for component EgressGateways.✔ Finished applying manifest for component IngressGateways.✔ Finished applying manifest for component AddonComponents.✔ Installation complete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装完成后我们可以查看 istio-system 命名空间下面的 Pod 运行状态：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$  kubectl get pods -n istio-systemNAME                                    READY   STATUS    RESTARTS   AGEgrafana-5cc7f86765-89z9l                1/1     Running   0          5m18sistio-egressgateway-598d7ffc49-x4rtw    1/1     Running   0          5m19sistio-ingressgateway-7bd5586b79-z78rw   1/1     Running   0          5m19sistio-tracing-8584b4d7f9-26czf          1/1     Running   0          5m18sistiod-646b6fcc6-rjlcm                  1/1     Running   0          6m53skiali-696bb665-cr8f9                    1/1     Running   0          5m18sprometheus-6c88c4cb8-2dt5k              2/2     Running   0          5m18s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果都是 Running 状态证明 istio 就已经安装成功了。</p><p>安装完成后还可以检测一下<code>istio</code>的<code>CRD</code>和<code>API资源</code>:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl get crd | grep istioadapters.config.istio.io                   2022-09-09T21:58:30Zattributemanifests.config.istio.io         2022-09-09T21:58:30Zauthorizationpolicies.security.istio.io    2022-09-09T21:58:30Zclusterrbacconfigs.rbac.istio.io           2022-09-09T21:58:30Zdestinationrules.networking.istio.io       2022-09-09T21:58:30Zenvoyfilters.networking.istio.io           2022-09-09T21:58:30Zgateways.networking.istio.io               2022-09-09T21:58:30Zhandlers.config.istio.io                   2022-09-09T21:58:30Zhttpapispecbindings.config.istio.io        2022-09-09T21:58:30Zhttpapispecs.config.istio.io               2022-09-09T21:58:30Zinstances.config.istio.io                  2022-09-09T21:58:30Zmeshpolicies.authentication.istio.io       2022-09-09T21:58:30Zpeerauthentications.security.istio.io      2022-09-09T21:58:30Zpolicies.authentication.istio.io           2022-09-09T21:58:30Zquotaspecbindings.config.istio.io          2022-09-09T21:58:30Zquotaspecs.config.istio.io                 2022-09-09T21:58:30Zrbacconfigs.rbac.istio.io                  2022-09-09T21:58:30Zrequestauthentications.security.istio.io   2022-09-09T21:58:30Zrules.config.istio.io                      2022-09-09T21:58:30Zserviceentries.networking.istio.io         2022-09-09T21:58:30Zservicerolebindings.rbac.istio.io          2022-09-09T21:58:30Zserviceroles.rbac.istio.io                 2022-09-09T21:58:30Zsidecars.networking.istio.io               2022-09-09T21:58:30Ztemplates.config.istio.io                  2022-09-09T21:58:30Zvirtualservices.networking.istio.io        2022-09-09T21:58:30Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看一下 <code>API资源</code>：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl api-resources | grep istio meshpolicies                                   authentication.istio.io        false        MeshPolicypolicies                                       authentication.istio.io        true         Policyadapters                                       config.istio.io                true         adapterattributemanifests                             config.istio.io                true         attributemanifesthandlers                                       config.istio.io                true         handlerhttpapispecbindings                            config.istio.io                true         HTTPAPISpecBindinghttpapispecs                                   config.istio.io                true         HTTPAPISpecinstances                                      config.istio.io                true         instancequotaspecbindings                              config.istio.io                true         QuotaSpecBindingquotaspecs                                     config.istio.io                true         QuotaSpecrules                                          config.istio.io                true         ruletemplates                                      config.istio.io                true         templatedestinationrules                  dr           networking.istio.io            true         DestinationRuleenvoyfilters                                   networking.istio.io            true         EnvoyFiltergateways                          gw           networking.istio.io            true         Gatewayserviceentries                    se           networking.istio.io            true         ServiceEntrysidecars                                       networking.istio.io            true         Sidecarvirtualservices                   vs           networking.istio.io            true         VirtualServiceclusterrbacconfigs                             rbac.istio.io                  false        ClusterRbacConfigrbacconfigs                                    rbac.istio.io                  true         RbacConfigservicerolebindings                            rbac.istio.io                  true         ServiceRoleBindingserviceroles                                   rbac.istio.io                  true         ServiceRoleauthorizationpolicies                          security.istio.io              true         AuthorizationPolicypeerauthentications                            security.istio.io              true         PeerAuthenticationrequestauthentications                         security.istio.io              true         RequestAuthentication<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>istio 官方提供了一些 Dashboard，可以以可视化的方式直接去查看你的系统运行情况。</p><p>我们直接启动 <code>Kiali</code>这个 Dashboard：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [17:24:02] $ istioctl dashboard kiali<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行以上命令它会帮我们打开浏览器，使用 admin/admin登录：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220914185033.png"></p><p>如下图所示，可以看到 istio 相关组件都已安装成功，并且成功启动：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220914185942.png"></p><h2 id="示例安装"><a href="#示例安装" class="headerlink" title="示例安装"></a>示例安装</h2><p>然后我们可以来安装官方提供的一个非常经典的 <a href="https://github.com/istio/istio/tree/master/samples/bookinfo/">Bookinfo 应用示例</a>，这个示例部署了一个用于演示多种 Istio 特性的应用，该应用由四个单独的微服务构成。 这个应用模仿在线书店的一个分类，显示一本书的信息。页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。</p><p>Bookinfo 应用分为四个单独的微服务：</p><ul><li>productpage：这个微服务会调用 details 和 reviews 两个微服务，用来生成页面。</li><li>details：这个微服务中包含了书籍的信息。</li><li>reviews：这个微服务中包含了书籍相关的评论，它还会调用 ratings 微服务。</li><li>ratings：这个微服务中包含了由书籍评价组成的评级信息。</li></ul><p>reviews 微服务有 3 个版本：</p><ul><li>v1 版本不会调用 ratings 服务。</li><li>v2 版本会调用 ratings 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li><li>v3 版本会调用 ratings 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220914193030.png"></p><p>上图展示了使用 istio 后，整个应用实际的结构。所有的微服务都和一个 <code>Envoy sidecar</code> 封装到一起，sidecar 拦截所有到达和离开服务的请求。</p><h3 id="注入-Sidecar"><a href="#注入-Sidecar" class="headerlink" title="注入 Sidecar"></a>注入 Sidecar</h3><p>在部署 Bookinfo 之前我们需要注入 Sidecar，有两种注入方式</p><ul><li><p>自动注入</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [19:43:36]$ kubectl label namespace default istio-injection=enablednamespace/default labeled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>给 default 这个命令空间（booknifo应用所在空间）添加一个 label，名称为：istio-injection，值为：enabled。</p></li><li><p>手动注入</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f &lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [19:43:39] $ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml service/details createdserviceaccount/bookinfo-details createddeployment.apps/details-v1 createdservice/ratings createdserviceaccount/bookinfo-ratings createddeployment.apps/ratings-v1 createdservice/reviews createdserviceaccount/bookinfo-reviews createddeployment.apps/reviews-v1 createddeployment.apps/reviews-v2 createddeployment.apps/reviews-v3 createdservice/productpage createdserviceaccount/bookinfo-productpage createddeployment.apps/productpage-v1 created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们部署的 <code>bookinfo.yaml</code> 资源清单文件就是普通的 Kubernetes 的 Deployment 和 Service 的 yaml 文件，而 <code>istioctl kube-inject</code> 会在这个文件的基础上向其中的 Deployment 追加一个镜像为 <code>docker.io/istio/proxyv2:1.5.1</code> 的 sidecar 容器。</p><p>过一会儿就可以看到如下 service 和 pod 启动:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [19:46:55] $ kubectl get po NAME                              READY   STATUS    RESTARTS   AGEdetails-v1-78d78fbddf-5srj5       2/2     Running   0          3m3sproductpage-v1-85b9bf9cd7-sbwd8   2/2     Running   0          3m1sratings-v1-6c9dbf6b45-9fpck       2/2     Running   0          3m2sreviews-v1-564b97f875-f8zkw       2/2     Running   0          3m1sreviews-v2-568c7c9d8f-r5c76       2/2     Running   0          3m2sreviews-v3-67b4988599-qlv5j       2/2     Running   0          3m2s# zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [19:46:57] $ kubectl get svcNAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGEdetails       ClusterIP   10.99.216.225    &lt;none&gt;        9080/TCP   3m6skubernetes    ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP    4d20hproductpage   ClusterIP   10.100.219.221   &lt;none&gt;        9080/TCP   3m5sratings       ClusterIP   10.96.89.71      &lt;none&gt;        9080/TCP   3m6sreviews       ClusterIP   10.110.207.93    &lt;none&gt;        9080/TCP   3m6s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到每个 pod 中有两个 container，一个是应用本身的，另一个是我们自动注入的 Sidecar。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl describe pod details-v1-78d78fbddf-5srj5        Name:         details-v1-78d78fbddf-5srj5Namespace:    defaultPriority:     0Node:         minikube/192.168.64.5Start Time:   Wed, 14 Sep 2022 19:43:55 +0800Labels:       app=details              pod-template-hash=78d78fbddf              security.istio.io/tlsMode=istio              service.istio.io/canonical-name=details              service.istio.io/canonical-revision=v1              version=v1Annotations:  sidecar.istio.io/status:                {"version":"64f53c7f7e9dca50ddb9767390392872119f042c4a541dbbb6a973d5638bd264","initContainers":["istio-init"],"containers":["istio-proxy"]...Status:       Running......Containers:  details:    Container ID:   docker://ff6f87fcad1aab7888a87bfb515806a48c78f744fa045b078529cc3090b43bea    Image:          docker.io/istio/examples-bookinfo-details-v1:1.15.0    Image ID:       docker-pullable://istio/examples-bookinfo-details-v1@sha256:fce0bcbff0bed09116dacffca15695cd345e0c3788c15b0114a05f654ddecc17    Port:           9080/TCP    Host Port:      0/TCP    State:          Running      Started:      Wed, 14 Sep 2022 19:46:16 +0800    Ready:          True    Restart Count:  0    Environment:    &lt;none&gt;    Mounts:      /var/run/secrets/kubernetes.io/serviceaccount from bookinfo-details-token-qr8rw (ro)  istio-proxy:    Container ID:  docker://ed3a32d4ba85b35406a2e62287e72cffcda417f9003b69bbc3e1984d35e79a1d    Image:         docker.io/istio/proxyv2:1.5.1    Image ID:      docker-pullable://istio/proxyv2@sha256:3ad9ee2b43b299e5e6d97aaea5ed47dbf3da9293733607d9b52f358313e852ae    Port:          15090/TCP    Host Port:     0/TCP......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建-Ingress-网关"><a href="#创建-Ingress-网关" class="headerlink" title="创建 Ingress 网关"></a>创建 Ingress 网关</h3><p>现在应用的服务都部署成功并启动了，如果我们需要在集群外部访问，就需要添加一个 istio gateway。gateway 相当于 k8s 的 ingress controller 和 ingress。它为 HTTP/TCP 流量配置负载均衡，通常在服务网格边缘作为应用的 ingress 流量管理。</p><p>创建一个 gateway:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [19:56:37] $ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yamlgateway.networking.istio.io/bookinfo-gateway createdvirtualservice.networking.istio.io/bookinfo created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>验证 gateway 是否启动成功:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl get gatewayNAME               AGEbookinfo-gateway   40s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要想取访问这个应用，这里我们需要更改下 istio 提供的 istio-ingressgateway 这个 Service 对象，默认是 LoadBalancer 类型的服务：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl get svc -n istio-systemNAME                        TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)                                                                                                                                      AGE......istio-ingressgateway        LoadBalancer   10.102.174.244   &lt;pending&gt;     15020:30839/TCP,80:30693/TCP,443:32317/TCP,15029:30570/TCP,15030:31955/TCP,15031:31823/TCP,15032:31296/TCP,31400:32294/TCP,15443:32067/TCP   4d14h......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LoadBalancer 类型的服务，实际上是用来对接云服务厂商的，如果我们没有对接云服务厂商的话，可以将这里类型改成 <code>NodePort</code>，但是这样当访问我们的服务的时候就需要加上 nodePort 端口了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl edit svc istio-ingressgateway -n istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/devops/istio-1.5.1 [20:07:44] $ kubectl get svc -n istio-systemNAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                                                                                                                                      AGE......istio-ingressgateway        NodePort    10.102.174.244   &lt;none&gt;        15020:30839/TCP,80:30693/TCP,443:32317/TCP,15029:30570/TCP,15030:31955/TCP,15031:31823/TCP,15032:31296/TCP,31400:32294/TCP,15443:32067/TCP   4d14h ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就可以通过 <code>http://&lt;NodeIP&gt;:&lt;nodePort&gt;/productpage</code> 访问应用了：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220914201313.png"></p><p>刷新页面可以看到 Book Reviews 发生了改变，因为每次请求会被路由到到了不同的 Reviews 服务版本去：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220914201535.png"></p><p>至此，整个 istio 就安装并验证成功了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://istio.io/latest/docs/setup/platform-setup/minikube/">https://istio.io/latest/docs/setup/platform-setup/minikube/</a> </li><li><a href="https://istio.io/latest/docs/releases/supported-releases/">https://istio.io/latest/docs/releases/supported-releases/</a></li><li><a href="https://github.com/istio/istio/tree/master/samples/bookinfo/">https://github.com/istio/istio/tree/master/samples/bookinfo/</a></li><li><a href="https://istio.io/latest/docs/examples/bookinfo/">https://istio.io/latest/docs/examples/bookinfo/</a></li><li><a href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection">https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Service Mesh </tag>
            
            <tag> Istio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus Operator 的安装</title>
      <link href="/2022/09/09/prometheus-operator-de-an-zhuang/"/>
      <url>/2022/09/09/prometheus-operator-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Prometheus-Operator-的安装"><a href="#Prometheus-Operator-的安装" class="headerlink" title="Prometheus Operator 的安装"></a>Prometheus Operator 的安装</h1><p>传统的Prometheus监控Kubernetes集群，有所缺陷，比如Prometheus、Alertmanager等组件的高可用，虽然可以通过自定义的方式实现，但是不够灵活。那么Prometheus Operator是一种更高级，更云原生的Kubernetes集群监控方式。其项目地址为：<a href="https://github.com/prometheus-operator/kube-prometheus">https://github.com/prometheus-operator/kube-prometheus</a></p><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><h3 id="什么是-Operator？"><a href="#什么是-Operator？" class="headerlink" title="什么是 Operator？"></a>什么是 Operator？</h3><p>Operator = Controller + CRD。假如你不了解什么是 Controller 和 CRD，可以看一个 Kubernetes 本身的例子：我们提交一个 Deployment 对象来声明期望状态，比如 3 个副本；而 Kubernetes 的 Controller 会不断地干活（跑控制循环）来达成期望状态，比如看到只有 2 个副本就创建一个，看到有 4 个副本了就删除一个。在这里，Deployment 是 Kubernetes 本身的 API 对象。那假如我们想自己设计一些 API 对象来完成需求呢？Kubernetes 本身提供了 CRD(Custom Resource Definition)，允许我们定义新的 API 对象。但在定义完之后，Kubernetes 本身当然不可能知道这些 API 对象的期望状态该如何到达。这时，我们就要写对应的 Controller 去实现这个逻辑。而这种自定义 API 对象 + 自己写 Controller 去解决问题的模式，就是 Operator Pattern。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先我们先来了解下<code>Prometheus-Operator</code>的架构图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220909134822.png"></p><p>上图是 Prometheus-Operator 官方提供的架构图，各组件以不同的方式运行在 Kubernetes 集群中，其中 Operator 是最核心的部分，作为一个控制器，他会去创建Prometheus、ServiceMonitor、AlertManager 以及 PrometheusRule 4个 CRD 资源对象，然后会一直监控并维持这4个资源对象的状态。</p><ul><li><code>Operator</code>：根据自定义资源来部署和管理 Prometheus Server，同时监控这些自定义资源事件的变化来做相应的处理，是整个系统的控制中心。</li><li><code>Prometheus</code>：声明 Prometheus 资源对象期望的状态，Operator 确保这个资源对象运行时一直与定义保持一致。</li><li><code>Prometheus Server</code>：Operator 根据自定义资源 Prometheus 类型中定义的内容而部署的 Prometheus Server 集群，这些自定义资源可以看作是用来管理 Prometheus Server 集群的 StatefulSets 资源。</li><li><code>ServiceMonitor</code>：声明指定监控的服务，描述了一组被 Prometheus 监控的目标列表，就是 exporter 的抽象，用来提供 metrics 数据接口的工具。该资源通过 Labels 来选取对应的 Service Endpoint，让 Prometheus Server 通过选取的 Service 来获取 Metrics 信息。</li><li><code>Service</code>：简单的说就是 Prometheus 监控的对象。</li><li><code>Alertmanager</code>：定义 AlertManager 资源对象期望的状态，Operator 确保这个资源对象运行时一直与定义保持一致。</li></ul><p>这样我们要在集群中监控什么数据，就变成了直接去操作 Kubernetes 集群的资源对象了，是不是方便很多了。上图中的 Service 和 ServiceMonitor 都是 Kubernetes 的资源，一个 ServiceMonitor 可以通过 labelSelector 的方式去匹配一类 Service，Prometheus 也可以通过 labelSelector 去匹配多个ServiceMonitor。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>注意集群版本，自己先到Github上下载对应的版本。</p></blockquote><p>我们可以使用 Helm 来快速安装 Prometheus Operator，也可以通过 <a href="https://github.com/coreos/kube-prometheus/blob/master/manifests/prometheus-service.yaml">https://github.com/coreos/kube-prometheus</a> 项目来手动安装，我们这里采用手动安装的方式可以去了解更多的实现细节。</p><p>首先 clone 项目代码：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git clone https://github.com/coreos/kube-prometheus.git$ cd manifests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入到 <code>manifests</code> 目录下面，首先我们需要安装 <code>setup</code> 目录下面的 CRD 和 Operator 资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master manifests]# kubectl apply -f setup/namespace/monitoring unchangedcustomresourcedefinition.apiextensions.k8s.io/alertmanagerconfigs.monitoring.coreos.com configuredcustomresourcedefinition.apiextensions.k8s.io/alertmanagers.monitoring.coreos.com configuredcustomresourcedefinition.apiextensions.k8s.io/podmonitors.monitoring.coreos.com configuredcustomresourcedefinition.apiextensions.k8s.io/probes.monitoring.coreos.com configuredcustomresourcedefinition.apiextensions.k8s.io/prometheuses.monitoring.coreos.com createdcustomresourcedefinition.apiextensions.k8s.io/prometheusrules.monitoring.coreos.com configuredcustomresourcedefinition.apiextensions.k8s.io/servicemonitors.monitoring.coreos.com configuredcustomresourcedefinition.apiextensions.k8s.io/thanosrulers.monitoring.coreos.com configuredclusterrole.rbac.authorization.k8s.io/prometheus-operator createdclusterrolebinding.rbac.authorization.k8s.io/prometheus-operator createddeployment.apps/prometheus-operator createdservice/prometheus-operator createdserviceaccount/prometheus-operator created[root@k8s-master manifests]# kubectl get pods -n monitoringNAME                                   READY   STATUS    RESTARTS   AGEprometheus-operator-7775c66ccf-wqkgw   2/2     Running   0          80s[root@k8s-master manifests]# kubectl get crd  | grep coreosalertmanagerconfigs.monitoring.coreos.com             2022-09-09T05:57:30Zalertmanagers.monitoring.coreos.com                   2022-09-09T05:57:30Zpodmonitors.monitoring.coreos.com                     2022-09-09T05:57:31Zprobes.monitoring.coreos.com                          2022-09-09T05:57:31Zprometheuses.monitoring.coreos.com                    2022-09-09T06:07:45Zprometheusrules.monitoring.coreos.com                 2022-09-09T05:57:31Zservicemonitors.monitoring.coreos.com                 2022-09-09T05:57:31Zthanosrulers.monitoring.coreos.com                    2022-09-09T05:57:31Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这会创建一个名为 <code>monitoring</code> 的命名空间，以及相关的 CRD 资源对象声明和 Prometheus Operator 控制器。当我们声明完 CRD 过后，就可以来自定义资源清单了，但是要让我们声明的自定义资源对象生效就需要安装对应的 Operator 控制器，这里我们都已经安装了，所以接下来就可以来用 CRD 创建真正的自定义资源对象了。其实在 <code>manifests</code> 目录下面的就是我们要去创建的 Prometheus、Alertmanager 以及各种监控对象的资源清单。</p><p>没有特殊的定制需求我们可以直接一键安装：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master manifests]# kubectl apply -f .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会自动安装 node-exporter、kube-state-metrics、grafana、prometheus-adapter 以及 prometheus 和 alertmanager 组件，而且 prometheus 和 alertmanager 还是多副本的。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master manifests]#  kubectl get pods -n monitoringNAME                                   READY   STATUS    RESTARTS   AGEalertmanager-main-0                    2/2     Running   0          5m55salertmanager-main-1                    2/2     Running   0          5m55salertmanager-main-2                    2/2     Running   0          5m55sblackbox-exporter-55c457d5fb-l29mr     3/3     Running   0          5m55sgrafana-9df57cdc4-gx8bg                1/1     Running   0          5m55skube-state-metrics-76f6cb7996-vrtgm    3/3     Running   0          5m55snode-exporter-bd9cg                    0/2     Pending   0          5m56snode-exporter-dxzth                    0/2     Pending   0          5m56snode-exporter-sftnm                    0/2     Pending   0          5m56sprometheus-adapter-59df95d9f5-222st    1/1     Running   0          5m55sprometheus-adapter-59df95d9f5-mhmr8    1/1     Running   0          5m55sprometheus-k8s-0                       2/2     Running   1          5m55sprometheus-k8s-1                       2/2     Running   1          5m55sprometheus-operator-7775c66ccf-wqkgw   2/2     Running   0          10m[root@k8s-master manifests]# kubectl get svc -n monitoringNAME                    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGEalertmanager-main       ClusterIP   10.96.246.4     &lt;none&gt;        9093/TCP                     6m20salertmanager-operated   ClusterIP   None            &lt;none&gt;        9093/TCP,9094/TCP,9094/UDP   6m20sblackbox-exporter       ClusterIP   10.96.158.138   &lt;none&gt;        9115/TCP,19115/TCP           6m19sgrafana                 ClusterIP   10.96.241.17    &lt;none&gt;        3000/TCP                     6m19skube-state-metrics      ClusterIP   None            &lt;none&gt;        8443/TCP,9443/TCP            6m19snode-exporter           ClusterIP   None            &lt;none&gt;        9100/TCP                     6m19sprometheus-adapter      ClusterIP   10.96.198.116   &lt;none&gt;        443/TCP                      6m18sprometheus-k8s          ClusterIP   10.96.166.175   &lt;none&gt;        9090/TCP                     6m18sprometheus-operated     ClusterIP   None            &lt;none&gt;        9090/TCP                     6m18sprometheus-operator     ClusterIP   None            &lt;none&gt;        8443/TCP                     11m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到上面针对 grafana、alertmanager 和 prometheus 都创建了一个类型为 ClusterIP 的 Service，当然如果我们想要在外网访问这两个服务的话可以通过创建对应的 Ingress 对象或者使用 NodePort 类型的 Service，我们这里为了简单，直接使用 NodePort 类型的服务即可，编辑 grafana、alertmanager-main 和 prometheus-k8s 这3个 Service，将服务类型更改为 NodePort:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master manifests]# kubectl get svc -n monitoringNAME                    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGEalertmanager-main       NodePort    10.96.246.4     &lt;none&gt;        9093:32704/TCP               9m54sgrafana                 NodePort    10.96.241.17    &lt;none&gt;        3000:31319/TCP               9m53sprometheus-k8s          NodePort    10.96.166.175   &lt;none&gt;        9090:30343/TCP               9m52s......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更改完成后，我们就可以通过上面的 NodePort 去访问对应的服务了，比如查看 prometheus 的服务发现页面：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220909142557.png"></p><p>查看 prometheus 的 targets 页面：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220909143353.png"></p><p>我们就可以去查看下 Grafana 下面的监控图表，同样使用上面的 NodePort 访问即可，第一次登录使用 <code>admin:admin</code> 登录即可，进入首页后，我们可以发现其实 Grafana 已经有很多配置好的监控图表了。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220909144353.png"></p><p>我们可以随便选择一个 Dashboard 查看监控图表信息。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220909144624.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/58.Prometheus%20Operator.html">https://www.qikqiak.com/k8s-book/docs/58.Prometheus%20Operator.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
            <tag> Operator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus报警系统AlertManager</title>
      <link href="/2022/09/09/prometheus-bao-jing-xi-tong-alertmanager/"/>
      <url>/2022/09/09/prometheus-bao-jing-xi-tong-alertmanager/</url>
      
        <content type="html"><![CDATA[<h1 id="Prometheus报警系统AlertManager"><a href="#Prometheus报警系统AlertManager" class="headerlink" title="Prometheus报警系统AlertManager"></a>Prometheus报警系统AlertManager</h1><h2 id="AlertManager-简介"><a href="#AlertManager-简介" class="headerlink" title="AlertManager 简介"></a>AlertManager 简介</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905151134.png"></p><p>Alertmanager 主要用于接收 Prometheus 发送的告警信息，它支持丰富的告警通知渠道，而且很容易做到告警信息进行去重，降噪，分组等，是一款前卫的告警通知系统。</p><p>通过在 Prometheus 中定义告警规则，Prometheus会周期性的对告警规则进行计算，如果满足告警触发条件就会向Alertmanager 发送告警信息。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905151208.png"></p><p>在 Prometheus 中一条告警规则主要由以下几部分组成：</p><ul><li>告警名称：用户需要为告警规则命名，当然对于命名而言，需要能够直接表达出该告警的主要内容</li><li>告警规则：告警规则实际上主要由 <code>PromQL</code> 进行定义，其实际意义是当表达式（PromQL）查询结果持续多长时间（During）后出发告警</li></ul><p>在 Prometheus 中，还可以通过 Group（告警组）对一组相关的告警进行统一定义。Alertmanager 作为一个独立的组件，负责接收并处理来自 Prometheus Server 的告警信息。Alertmanager 可以对这些告警信息进行进一步的处理，比如当接收到大量重复告警时能够消除重复的告警信息，同时对告警信息进行分组并且路由到正确的通知方，Prometheus 内置了对邮件、Slack 多种通知方式的支持，同时还支持与 Webhook 的集成，以支持更多定制化的场景。例如，目前 Alertmanager 还不支持钉钉，用户完全可以通过 Webhook 与钉钉机器人进行集成，从而通过钉钉接收告警信息。同时 AlertManager 还提供了静默和告警抑制机制来对告警通知行为进行优化。</p><p>让<code>AlertManager</code>提供服务总的来说就下面3步： </p><ol><li><p>安装和配置<code>AlertManger</code></p></li><li><p>配置<code>Prometheus</code>来和<code>AlertManager</code>通信</p></li><li><p>在<code>Prometheus</code>中创建报警规则</p></li></ol><h2 id="安装和配置AlertManager"><a href="#安装和配置AlertManager" class="headerlink" title="安装和配置AlertManager"></a>安装和配置AlertManager</h2><p>从官方文档 <a href="https://prometheus.io/docs/alerting/configuration/">https://prometheus.io/docs/alerting/configuration/</a> 中我们可以看到下载 AlertManager 二进制文件后，可以通过下面的命令运行：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ./alertmanager --config.file=simple.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>-config.file</code> 参数是用来指定对应的配置文件的，由于我们这里同样要运行到 Kubernetes 集群中来，所以我们使用 Docker 镜像的方式来安装，使用的镜像是：<code>prom/alertmanager:v0.20.0</code>。</p><blockquote><p><strong>Note</strong></p><p>为了方便管理，我们将监控相关的所有资源对象都安装在 <code>kube-mon</code> 这个 namespace 下面，没有的话可以提前创建。</p></blockquote><p>把用到的资源文件统一放到 <code>alertmanager</code> 目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# mkdir ~/alertmanager &amp;&amp; cd alertmanager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先，指定配置文件，同样的，我们这里使用一个 ConfigMap 资源对象：alertmanager-config.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> alert<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">config.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    <span class="token key atrule">global</span><span class="token punctuation">:</span>      <span class="token comment"># 当alertmanager持续多长时间未接收到告警后标记告警状态为 resolved</span>      <span class="token key atrule">resolve_timeout</span><span class="token punctuation">:</span> 5m      <span class="token comment"># 配置邮件发送信息</span>      <span class="token key atrule">smtp_smarthost</span><span class="token punctuation">:</span> <span class="token string">'smtp.163.com:25'</span>      <span class="token key atrule">smtp_from</span><span class="token punctuation">:</span> <span class="token string">'dendi875@163.com'</span>      <span class="token key atrule">smtp_auth_username</span><span class="token punctuation">:</span> <span class="token string">'dendi875@163.com'</span>      <span class="token key atrule">smtp_auth_password</span><span class="token punctuation">:</span> <span class="token string">'&lt;邮箱密码&gt;'</span>      <span class="token key atrule">smtp_hello</span><span class="token punctuation">:</span> <span class="token string">'163.com'</span>      <span class="token key atrule">smtp_require_tls</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token comment"># 所有报警信息进入后的根路由，用来设置报警的分发策略</span>    <span class="token key atrule">route</span><span class="token punctuation">:</span>      <span class="token comment"># 这里的标签列表是接收到报警信息后的重新分组标签，例如，接收到的报警信息里面有许多具有 cluster=A 和 alertname=LatncyHigh 这样的标签的报警信息将会批量被聚合到一个分组里面</span>      <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">,</span> <span class="token string">'cluster'</span><span class="token punctuation">]</span>      <span class="token comment"># 当一个新的报警分组被创建后，需要等待至少 group_wait 时间来初始化通知，这种方式可以确保您能有足够的时间为同一分组来获取多个警报，然后一起触发这个报警信息。</span>      <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 30s      <span class="token comment"># 相同的group之间发送告警通知的时间间隔</span>      <span class="token key atrule">group_interval</span><span class="token punctuation">:</span> 30s      <span class="token comment"># 如果一个报警信息已经发送成功了，等待 repeat_interval 时间来重新发送他们，不同类型告警发送频率需要具体配置</span>      <span class="token key atrule">repeat_interval</span><span class="token punctuation">:</span> 1h      <span class="token comment"># 默认的receiver：如果一个报警没有被一个route匹配，则发送给默认的接收器</span>      <span class="token key atrule">receiver</span><span class="token punctuation">:</span> default      <span class="token comment"># 上面所有的属性都由所有子路由继承，并且可以在每个子路由上进行覆盖。</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> email        <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s        <span class="token key atrule">match</span><span class="token punctuation">:</span>          <span class="token key atrule">team</span><span class="token punctuation">:</span> node    <span class="token key atrule">receivers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'default'</span>      <span class="token key atrule">email_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span> <span class="token string">'943299849@qq.com'</span>        <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 接受告警恢复的通知</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'email'</span>      <span class="token key atrule">email_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span> <span class="token string">'943299849@qq.com'</span>        <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>Note</strong></p><p>分组机制可以将详细的告警信息合并成一个通知，在某些情况下，比如由于系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知，避免一次性接受大量的告警通知，而无法对问题进行快速定位。</p></blockquote><p>这是 AlertManager 的配置文件，我们先直接创建这个 ConfigMap 资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master alertmanager]# kubectl apply -f alertmanager-config.yaml configmap/alert-config created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后配置 AlertManager 的容器，直接使用一个 Deployment 来进行管理即可，对应的 YAML 资源声明如下：alertmanager-deploy.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> alertmanager  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> alertmanager<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> alertmanager  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> alertmanager    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> alertcfg        <span class="token key atrule">configMap</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> alert<span class="token punctuation">-</span>config      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> alertmanager        <span class="token key atrule">image</span><span class="token punctuation">:</span> prom/alertmanager<span class="token punctuation">:</span>v0.20.0        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"--config.file=/etc/alertmanager/config.yml"</span>        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9093</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> http        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/alertmanager"</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> alertcfg        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 256Mi          <span class="token key atrule">limits</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 256Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们将上面创建的 <code>alert-config</code> 这个 ConfigMap 资源对象以 Volume 的形式挂载到 <code>/etc/alertmanager</code> 目录下去，然后在启动参数中指定了配置文件 <code>--config.file=/etc/alertmanager/config.yml</code>，然后我们可以来创建这个资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master alertmanager]# kubectl apply -f alertmanager-deploy.yaml deployment.apps/alertmanager created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了可以访问到 AlertManager，同样需要我们创建一个对应的 Service 对象：alertmanager-svc.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> alertmanager  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> alertmanager<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> alertmanager  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> web      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9093</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> http<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 NodePort 类型也是为了方便测试，创建上面的 Service 这个资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master alertmanager]# kubectl apply -f alertmanager-svc.yaml service/alertmanager created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置Prometheus来和AlertManager通信"><a href="#配置Prometheus来和AlertManager通信" class="headerlink" title="配置Prometheus来和AlertManager通信"></a>配置Prometheus来和AlertManager通信</h2><p>AlertManager 的容器启动起来后，我们还需要在 Prometheus 中配置下 AlertManager 的地址，让 Prometheus 能够访问到 AlertManager，在 Prometheus 的 ConfigMap 资源清单中添加如下配置：prometheus-cm.yaml </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">alerting</span><span class="token punctuation">:</span>  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"alertmanager:9093"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更新这个资源对象后，稍等一小会儿，执行 reload 操作即可。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml configmap/prometheus-config configured# 隔一会儿执行reload操作[root@k8s-master prometheus]# curl -X POST "http://10.96.146.110:9090/-/reload"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新完成后，我们查看 Pod 已经是 Running 状态了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get pods -n kube-monNAME                            READY   STATUS      RESTARTS   AGEalertmanager-7c96c8fc4b-v4wjf   1/1     Running     0          8m54sgrafana-869db94654-wrpdg        1/1     Running     1          17hnode-exporter-bl6nb             1/1     Running     3          2d16hnode-exporter-fwzlt             1/1     Running     3          2d16hnode-exporter-pcr9w             1/1     Running     3          2d16hprometheus-75d4666dcd-vlth8     1/1     Running     3          2d17hredis-6468bf6c84-qmm2k          2/2     Running     6          2d17h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在Prometheus中创建报警规则"><a href="#在Prometheus中创建报警规则" class="headerlink" title="在Prometheus中创建报警规则"></a>在Prometheus中创建报警规则</h2><p>现在我们只是把 AlertManager 容器运行起来了，也和 Prometheus 进行了关联，但是现在我们并不知道要做什么报警，因为没有任何地方告诉我们要报警，所以我们还需要配置一些报警规则来告诉我们对哪些数据进行报警。</p><p>警报规则允许你基于 Prometheus 表达式语言的表达式来定义报警报条件，并在触发警报时发送通知给外部的接收者。</p><p>同样在 Prometheus 的配置文件中添加如下报警规则配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">rule_files</span><span class="token punctuation">:</span><span class="token punctuation">-</span> /etc/prometheus/rules.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中 <code>rule_files</code> 就是用来指定报警规则的，这里我们同样将 <code>rules.yml</code> 文件用 ConfigMap 的形式挂载到 <code>/etc/prometheus</code> 目录下面即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">prometheus.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    global:      scrape_interval: 15s      scrape_timeout: 15s      evaluation_interval: 30s  # 默认情况下每分钟对告警规则进行计算    alerting:      alertmanagers:      - static_configs:        - targets: ["alertmanager:9093"]    rule_files:    - /etc/prometheus/rules.yml</span>  <span class="token punctuation">...</span><span class="token punctuation">...</span> <span class="token comment"># 省略prometheus其他部分</span>  <span class="token key atrule">rules.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    groups:    - name: test-node-mem      rules:      - alert: NodeMemoryUsage  # (CPU使用率大于20%)的话，那么每5分钟我们就可以收到一条报警邮件        expr: (node_memory_MemTotal_bytes - (node_memory_MemFree_bytes + node_memory_Buffers_bytes + node_memory_Cached_bytes)) / node_memory_MemTotal_bytes * 100 &gt; 20        for: 2m        labels:          team: node        annotations:          summary: "{{$labels.instance}}: High Memory usage detected"          description: "{{$labels.instance}}: Memory usage is above 20% (current value is: {{ $value }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们定义了一个名为 <code>NodeMemoryUsage</code> 的报警规则，一条报警规则主要由以下几部分组成：</p><ul><li><code>alert</code>：告警规则的名称</li><li><code>expr</code>：是用于进行报警规则 PromQL 查询语句</li><li><code>for</code>：评估等待时间（Pending Duration），用于表示只有当触发条件持续一段时间后才发送告警，在等待期间新产生的告警状态为<code>pending</code></li><li><code>labels</code>：自定义标签，允许用户指定额外的标签列表，把它们附加在告警上</li><li><code>annotations</code>：指定了另一组标签，它们不被当做告警实例的身份标识，它们经常用于存储一些额外的信息，用于报警信息的展示之类的</li></ul><blockquote><p><strong>for 属性</strong></p><p>这个参数主要用于降噪，很多类似响应时间这样的指标都是有抖动的，通过指定 <code>Pending Duration</code>，我们可以过滤掉这些瞬时抖动，可以让我们能够把注意力放在真正有持续影响的问题上。</p></blockquote><p>为了让告警信息具有更好的可读性，Prometheus 支持模板化 <code>label</code> 和 <code>annotations</code> 中的标签的值，通过 <code>$labels.变量</code> 可以访问当前告警实例中指定标签的值，<code>$value</code> 则可以获取当前 PromQL 表达式计算的样本值。</p><p>为了方便演示，我们将的表达式判断报警临界值设置为 20，重新更新 ConfigMap 资源对象，由于我们在 Prometheus 的 Pod 中已经通过 Volume 的形式将 prometheus-config 这个一个 ConfigMap 对象挂载到了 <code>/etc/prometheus</code> 目录下面，所以更新后，该目录下面也会出现 <code>rules.yml</code> 文件，所以前面配置的 <code>rule_files</code> 路径也是正常的，更新完成后，重新执行 reload 操作，这个时候我们去 Prometheus 的 Dashboard 中切换到 alerts 路径下面就可以看到有报警配置规则的数据了：</p><p>更新 Prometheus 并 reload：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml configmap/prometheus-config configured# 隔一会儿执行reload操作[root@k8s-master prometheus]# curl -X POST "http://10.96.146.110:9090/-/reload"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>确认<code>/etc/prometheus</code>目录下面有 rules.yml 文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get pod -n kube-mon -l app=prometheus            NAME                          READY   STATUS    RESTARTS   AGEprometheus-75d4666dcd-vlth8   1/1     Running   3          2d18h[root@k8s-master prometheus]# kubectl exec  -it prometheus-75d4666dcd-vlth8 -n kube-mon  -- /bin/sh/prometheus # ls /etc/prometheus/prometheus.yml  rules.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看报警配置规则的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905155534.png"></p><p>页面中出现了我们刚刚定义的报警规则信息，而且报警信息中还有状态显示，一个报警信息在生命周期内有下面3种状态：</p><ul><li><code>pending</code>: 表示在设置的阈值时间范围内被激活了</li><li><code>firing</code>: 表示超过设置的阈值时间被激活了</li><li><code>inactive</code>: 表示当前报警信息处于非活动状态</li></ul><p>同时对于已经 <code>pending</code> 或者 <code>firing</code> 的告警，Prometheus 也会将它们存储到时间序列<code>ALERTS{}</code>中。当然我们也可以通过表达式去查询告警实例：</p><pre class="line-numbers language-none"><code class="language-none">ALERTS{alertname="&lt;alert name&gt;", alertstate="pending|firing", &lt;additional alert labels&gt;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>样本值为<code>1</code>表示当前告警处于活动状态（pending 或者 firing），当告警从活动状态转换为非活动状态时，样本值则为0。</p><p>我们这里的状态现在是 <code>firing</code> 就表示这个报警已经被激活了，我们这里的报警信息有一个 <code>team=node</code> 这样的标签，而最上面我们配置 alertmanager 的时候就有如下的路由配置信息了：alertmanager-config.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">routes</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> email  <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">match</span><span class="token punctuation">:</span>    <span class="token key atrule">team</span><span class="token punctuation">:</span> node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过 NodePort 的形式去访问到 AlertManager 的 Dashboard 页面：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master alertmanager]# kubectl get svc -n kube-monNAME           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGEalertmanager   NodePort    10.96.242.35    &lt;none&gt;        9093:30265/TCP      73m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后通过 <code>&lt;任一Node节点&gt;:30265</code> 进行访问，我们就可以查看到 AlertManager 的 Dashboard 页面，在这个页面中我们可以进行一些操作，比如过滤、分组等等，里面还有两个新的概念：<code>Inhibition(抑制)</code> 和 <code>Silences(静默)</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905163918.png"></p><ul><li>Inhibition：如果某些其他警报已经触发了，则对于某些警报，Inhibition 是一个抑制通知的概念。例如：一个警报已经触发，它正在通知整个集群是不可达的时，Alertmanager 则可以配置成关心这个集群的其他警报无效。这可以防止与实际问题无关的数百或数千个触发警报的通知，Inhibition 需要通过上面的配置文件进行配置。</li><li>Silences：静默是一个非常简单的方法，可以在给定时间内简单地忽略所有警报。Silences 基于 matchers配置，类似路由树。来到的警告将会被检查，判断它们是否和活跃的 Silences 相等或者正则表达式匹配。如果匹配成功，则不会将这些警报发送给接收者。</li></ul><p>由于全局配置中我们配置的 <code>repeat_interval: 1h</code>，所以正常来说，上面的测试报警如果一直满足报警条件(内存使用率大于20%)的话，那么每1小时我们就可以收到一条报警邮件。</p><p>一条告警产生后，还要经过 Alertmanager 的分组、抑制处理、静默处理、去重处理和降噪处理最后再发送给接收者。这个过程中可能会因为各种原因会导致告警产生了却最终没有进行通知，可以通过下图了解整个告警的生命周期：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905164016.png"></p><h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><ul><li>为什么没有收到邮件？</li></ul><p>alertmanager-config.yaml 文件中邮箱账号和密码要替换成自己的，并且 AlertManager 和 Prometheus 一样也支持 <code>reload</code>操作，修改了 AlertManager 配置文件之后也要执行 reload</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get svc -n kube-monNAME           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGEalertmanager   NodePort    10.96.242.35    &lt;none&gt;        9093:30265/TCP      4h20mgrafana        NodePort    10.96.179.102   &lt;none&gt;        3000:30907/TCP      26hprometheus     NodePort    10.96.146.110   &lt;none&gt;        9090:32640/TCP      2d21hredis          ClusterIP   10.96.143.235   &lt;none&gt;        6379/TCP,9121/TCP   2d21h# 通过 9093 来执行 AlertManager 的reload操作[root@k8s-master ~]# curl -X POST "http://10.96.242.35:9093/-/reload" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/57.AlertManager%E7%9A%84%E4%BD%BF%E7%94%A8.html">https://www.qikqiak.com/k8s-book/docs/57.AlertManager%E7%9A%84%E4%BD%BF%E7%94%A8.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
            <tag> AlertManager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus 查询语言 PromQL 使用说明</title>
      <link href="/2022/09/07/prometheus-cha-xun-yu-yan-promql-shi-yong-shuo-ming/"/>
      <url>/2022/09/07/prometheus-cha-xun-yu-yan-promql-shi-yong-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="Prometheus-查询语言-PromQL-使用说明"><a href="#Prometheus-查询语言-PromQL-使用说明" class="headerlink" title="Prometheus 查询语言 PromQL 使用说明"></a>Prometheus 查询语言 PromQL 使用说明</h1><p>Prometheus 通过指标名称（metrics name）以及对应的一组标签（label）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而 label 则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤、聚合、统计从而产生新的计算后的一条时间序列。</p><p><code>PromQL（Prometheus Query Language）</code> 是 Prometheus 内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。并且被广泛应用在 Prometheus 的日常应用当中，包括对数据查询、可视化、告警处理。可以这么说，<code>PromQL</code> 是 Prometheus 所有应用场景的基础，理解和掌握 <code>PromQL</code> 是我们使用 Prometheus 必备的技能。</p><h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p>通过 node-exporter 暴露的 metrics 服务，Prometheus 可以采集到当前主机所有监控指标的样本数据。例如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># HELP node_cpu_seconds_total Seconds the cpus spent in each mode.# TYPE node_cpu_seconds_total counternode_cpu_seconds_total{cpu="0",mode="idle"} 6.62885731e+06# HELP node_load1 1m load average.# TYPE node_load1 gaugenode_load1 2.29<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中非 <code>#</code> 开头的每一行表示当前 node-exporter 采集到的一个监控样本：<code>node_cpu_seconds_total</code>和 <code>node_load1</code> 表明了当前指标的名称、大括号中的标签则反映了当前样本的一些特征和维度、浮点数则是该监控样本的具体值。</p><p>Prometheus 会将所有采集到的样本数据以时间序列的方式保存在<strong>内存数据库</strong>中，并且定时保存到硬盘上。时间序列是按照时间戳和值的序列顺序存放的，我们称之为向量(vector)，每条时间序列通过指标名称(metrics name)和一组标签集(labelset)命名。如下所示，可以将时间序列理解为一个以时间为 X 轴的数字矩阵：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">^│   . . . . . . . . . . . . . . . . .   . .   node_cpu_seconds_total{cpu="cpu0",mode="idle"}│     . . . . . . . . . . . . . . . . . . .   node_cpu_seconds_total{cpu="cpu0",mode="system"}│     . . . . . . . . . .   . . . . . . . .   node_load1{}│     . . . . . . . . . . . . . . . .   . .  v  &lt;------------------ 时间 ----------------&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在时间序列中的每一个点称为一个样本（sample），样本由以下三部分组成：</p><ul><li>指标(metric)：metric name 和描述当前样本特征的 labelsets</li><li>时间戳(timestamp)：一个精确到毫秒的时间戳</li><li>样本值(value)： 一个 float64 的浮点型数据表示当前样本的值</li></ul><p>如下所示：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;http_request_total{status="200", method="GET"}@1434417560938 =&gt; 94355http_request_total{status="200", method="GET"}@1434417561287 =&gt; 94334http_request_total{status="404", method="GET"}@1434417560938 =&gt; 38473http_request_total{status="404", method="GET"}@1434417561287 =&gt; 38544http_request_total{status="200", method="POST"}@1434417560938 =&gt; 4748http_request_total{status="200", method="POST"}@1434417561287 =&gt; 4785<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在形式上，所有的指标(Metric)都通过如下格式表示：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;metric name&gt;{&lt;label name&gt; = &lt;label value&gt;, ...}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指标的名称(metric name)可以反映被监控样本的含义（比如，http_request_total - 表示当前系统接收到的 HTTP 请求总量）。指标名称只能由 ASCII 字符、数字、下划线以及冒号组成并必须符合正则表达式<code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>。</li><li>标签(label)反映了当前样本的特征维度，通过这些维度 Prometheus 可以对样本数据进行过滤，聚合等。标签的名称只能由 ASCII 字符、数字以及下划线组成并满足正则表达式 <code>[a-zA-Z_][a-zA-Z0-9_]*</code>。</li></ul><p>每个不同的 <code>metric_name</code>和 <code>label</code> 组合都称为<strong>时间序列</strong>，在 Prometheus 的表达式语言中，表达式或子表达式包括以下四种类型之一：</p><ul><li>瞬时向量（Instant vector）：一组时间序列，每个时间序列包含单个样本，它们共享相同的时间戳。也就是说，表达式的返回值中只会包含该时间序列中的最新的一个样本值。而相应的这样的表达式称之为瞬时向量表达式。</li><li>区间向量（Range vector）：一组时间序列，每个时间序列包含一段时间范围内的样本数据，这些是通过将时间选择器附加到方括号中的瞬时向量（例如[5m]5分钟）而生成的。</li><li>标量（Scalar）：一个简单的数字浮点值。</li><li>字符串（String）：一个简单的字符串值。</li></ul><p>所有这些指标都是 Prometheus 定期从 metrics 接口那里采集过来的。采集的间隔时间的设置由 <code>prometheus.yaml</code> 配置中的 <code>scrape_interval</code> 指定。最多抓取间隔为30秒，这意味着至少每30秒就会有一个带有新时间戳记录的新数据点，这个值可能会更改，也可能不会更改，但是每隔 <code>scrape_interval</code> 都会产生一个新的数据点。</p><h2 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h2><p>从存储上来讲所有的监控指标 metric 都是相同的，但是在不同的场景下这些 metric 又有一些细微的差异。 例如，在 Node Exporter 返回的样本中指标 <code>node_load1</code> 反应的是当前系统的负载状态，随着时间的变化这个指标返回的样本数据是在不断变化的。而指标 <code>node_cpu_seconds_total</code> 所获取到的样本数据却不同，它是一个持续增大的值，因为其反应的是 CPU 的累计使用时间，从理论上讲只要系统不关机，这个值是会一直变大。</p><p>为了能够帮助用户理解和区分这些不同监控指标之间的差异，Prometheus 定义了4种不同的指标类型：Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）、Summary（摘要）。</p><p>在 node-exporter 返回的样本数据中，其注释中也包含了该样本的类型。例如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># HELP node_cpu_seconds_total Seconds the cpus spent in each mode.# TYPE node_cpu_seconds_total counternode_cpu_seconds_total{cpu="cpu0",mode="idle"} 362812.7890625<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p><code>Counter</code> (只增不减的计数器) 类型的指标其工作方式和计数器一样，只增不减。常见的监控指标，如 <code>http_requests_total</code>、<code>node_cpu_seconds_total</code> 都是 <code>Counter</code> 类型的监控指标。</p><p><code>Counter</code> 是一个简单但又强大的工具，例如我们可以在应用程序中记录某些事件发生的次数，通过以时间序列的形式存储这些数据，我们可以轻松的了解该事件产生的速率变化。<code>PromQL</code> 内置的聚合操作和函数可以让用户对这些数据进行进一步的分析，例如，通过 <code>rate()</code> 函数获取 HTTP 请求量的增长率：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rate(http_requests_total[5m])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询当前系统中，访问量前 10 的 HTTP 请求：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">topk(10, http_requests_total)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Gauge"><a href="#Gauge" class="headerlink" title="Gauge"></a>Gauge</h3><p>与 <code>Counter</code> 不同，<code>Gauge</code>（可增可减的仪表盘）类型的指标侧重于反应系统的当前状态。因此这类指标的样本数据可增可减。常见指标如：<code>node_memory_MemFree_bytes</code>（主机当前空闲的内存大小）、<code>node_memory_MemAvailable_bytes</code>（可用内存大小）都是 <code>Gauge</code> 类型的监控指标。通过 <code>Gauge</code>指标，用户可以直接查看系统的当前状态：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node_memory_MemFree_bytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 <code>Gauge</code> 类型的监控指标，通过 <code>PromQL</code> 内置函数 <code>delta()</code> 可以获取样本在一段时间范围内的变化情况。例如，计算 CPU 温度在两个小时内的差异：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">delta(cpu_temp_celsius{host="zeus"}[2h])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还可以直接使用 <code>predict_linear()</code> 对数据的变化趋势进行预测。例如，预测系统磁盘空间在4个小时之后的剩余情况：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">predict_linear(node_filesystem_free_bytes[1h], 4 * 3600)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Histogram-和-Summary"><a href="#Histogram-和-Summary" class="headerlink" title="Histogram 和 Summary"></a>Histogram 和 Summary</h3><p>除了 <code>Counter</code> 和 <code>Gauge</code> 类型的监控指标以外，Prometheus 还定义了 <code>Histogram</code> 和 <code>Summary</code> 的指标类型。<code>Histogram</code> 和 <code>Summary</code> 主用用于统计和分析样本的分布情况。</p><p>在大多数情况下人们都倾向于使用某些量化指标的平均值，例如 CPU 的平均使用率、页面的平均响应时间，这种方式也有很明显的问题，以系统 API 调用的平均响应时间为例：如果大多数 API 请求都维持在 100ms 的响应时间范围内，而个别请求的响应时间需要 5s，那么就会导致某些 WEB 页面的响应时间落到<strong>中位数</strong>上，而这种现象被称为<strong>长尾问题</strong>。</p><p>为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如，统计延迟在 0<del>10ms 之间的请求数有多少而 10</del>20ms 之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。<code>Histogram</code> 和 <code>Summary</code> 都是为了能够解决这样的问题存在的，通过 <code>Histogram</code> 和<code>Summary</code> 类型的监控指标，我们可以快速了解监控样本的分布情况。</p><p>例如，指标 <code>prometheus_tsdb_wal_fsync_duration_seconds</code> 的指标类型为 Summary。它记录了 Prometheus Server 中 <code>wal_fsync</code> 的处理时间，通过访问 Prometheus Server 的 <code>/metrics</code> 地址，可以获取到以下监控样本数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get svc -n kube-monNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGEgrafana      NodePort    10.96.179.102   &lt;none&gt;        3000:30907/TCP      20hprometheus   NodePort    10.96.146.110   &lt;none&gt;        9090:32640/TCP      2d16hredis        ClusterIP   10.96.143.235   &lt;none&gt;        6379/TCP,9121/TCP   2d15h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# curl http://localhost:32640/metrics......# HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.# TYPE prometheus_tsdb_wal_fsync_duration_seconds summaryprometheus_tsdb_wal_fsync_duration_seconds{quantile="0.5"} 0.012352463prometheus_tsdb_wal_fsync_duration_seconds{quantile="0.9"} 0.014458005prometheus_tsdb_wal_fsync_duration_seconds{quantile="0.99"} 0.017316173prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002prometheus_tsdb_wal_fsync_duration_seconds_count 216......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的样本中可以得知当前 Prometheus Server 进行 <code>wal_fsync</code> 操作的总次数为216次，耗时2.888716127000002s。其中中位数（quantile=0.5）的耗时为0.012352463，9分位数（quantile=0.9）的耗时为0.014458005s。</p><p>在 Prometheus Server 自身返回的样本数据中，我们还能找到类型为 Histogram 的监控指标<code>prometheus_tsdb_compaction_chunk_range_seconds_bucket</code>：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># HELP prometheus_tsdb_compaction_chunk_range_seconds Final time range of chunks on their first compaction# TYPE prometheus_tsdb_compaction_chunk_range_seconds histogramprometheus_tsdb_compaction_chunk_range_seconds_bucket{le="100"} 71prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="400"} 71prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="1600"} 71prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="6400"} 71prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="25600"} 405prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="102400"} 25690prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="409600"} 71863prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="1.6384e+06"} 115928prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="6.5536e+06"} 2.5687892e+07prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="2.62144e+07"} 2.5687896e+07prometheus_tsdb_compaction_chunk_range_seconds_bucket{le="+Inf"} 2.5687896e+07prometheus_tsdb_compaction_chunk_range_seconds_sum 4.7728699529576e+13prometheus_tsdb_compaction_chunk_range_seconds_count 2.5687896e+07<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 <code>Summary</code> 类型的指标相似之处在于 <code>Histogram</code> 类型的样本同样会反应当前指标的记录的总数(以 <code>_count</code> 作为后缀)以及其值的总量（以 <code>_sum</code> 作为后缀）。不同在于 <code>Histogram</code> 指标直接反应了在不同区间内样本的个数，区间通过标签 le 进行定义。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>当 Prometheus 采集到监控指标样本数据后，我们就可以通过 PromQL 对监控样本数据进行查询。基本的 Prometheus 查询的结构非常类似于一个 metric 指标，以指标名称开始。</p><h3 id="查询结构"><a href="#查询结构" class="headerlink" title="查询结构"></a>查询结构</h3><p>比如只查询 <code>node_cpu_seconds_total</code> 则会返回所有采集节点的所有类型的 CPU 时长数据，当然如果数据量特别特别大的时候，直接在 Grafana 执行该查询操作的时候，则可能导致浏览器崩溃，因为它同时需要渲染的数据点太多。</p><p>接下来，可以使用标签进行过滤查询，标签过滤器支持4种运算符：</p><ul><li><code>=</code> 等于</li><li><code>!=</code> 不等于</li><li><code>=~</code> 匹配正则表达式</li><li><code>!~</code> 与正则表达式不匹配</li></ul><p>标签过滤器都位于指标名称后面的<code>{}</code>内，比如过滤 master 节点的 CPU 使用数据可用如下查询语句：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node_cpu_seconds_total{instance="k8s-master"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>Note</strong></p><p>PromQL 查询语句中的正则表达式匹配使用 <a href="https://github.com/google/re2/wiki/Syntax">RE2语法</a>。</p></blockquote><p>此外我们还可以使用多个标签过滤器，以逗号分隔。多个标签过滤器之间是 <code>AND</code> 的关系，所以使用多个标签进行过滤，返回的指标数据必须和所有标签过滤器匹配。</p><p>例如如下查询语句将返回所有以 <code>ydzs-</code>为前缀的节点的并且是 <code>idle</code> 模式下面的节点 CPU 使用时长指标：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node_cpu_seconds_total{instance=~"k8s-.*", mode="idle"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="范围选择器"><a href="#范围选择器" class="headerlink" title="范围选择器"></a>范围选择器</h3><p>我们可以通过将<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#range-vector-selectors">时间范围选择器([])</a>附加到查询语句中，指定为每个返回的区间向量样本值中提取多长的时间范围。每个时间戳的值都是按时间倒序记录在时间序列中的，该值是从时间范围内的时间戳获取的对应的值。</p><p>时间范围通过数字来表示，单位可以使用以下其中之一的时间单位：</p><ul><li>s - 秒</li><li>m - 分钟</li><li>h - 小时</li><li>d - 天</li><li>w - 周</li><li>y - 年</li></ul><p>比如 <code>node_cpu_seconds_total{instance="k8s-master", mode="idle"}</code> 这个查询语句，如果添加上 <code>[1m]</code>这个时间范围选择器，则我们可以得到如下所示的信息：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905141306.png"></p><p>可以看到上面的两个时间序列都有4个值，这是因为我们 Prometheus 中配置的抓取间隔是15秒，所以，我们从图中的 <code>@</code> 符号后面的时间戳可以看出，它们之间的间隔基本上就是15秒。</p><p>但是现在如果我们在 Prometheus 的页面中查询上面的语句，然后切换到 <code>Graph</code> 选项卡的时候，则会出现如下所示的错误信息： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905141436.png"></p><p>这是因为现在每一个时间序列中都有多个时间戳多个值，所以没办法渲染，必须是标量或者瞬时向量才可以绘制图形。</p><p>不过通常区间向量都会应用一个函数后变成可以绘制的瞬时向量，Prometheus 中对瞬时向量和区间向量有很多操作的<a href="https://prometheus.io/docs/prometheus/latest/querying/functions">函数</a>，不过对于区间向量来说最常用的函数并不多，使用最频繁的有如下几个函数：</p><ul><li><code>rate()</code>: 计算整个时间范围内区间向量中时间序列的每秒平均增长率</li><li><code>irate()</code>: 仅使用时间范围中的<strong>最后两个数据点</strong>来计算区间向量中时间序列的每秒平均增长率，<code>irate</code> 只能用于绘制快速变化的序列，在长期趋势分析或者告警中更推荐使用 <code>rate</code> 函数</li><li><code>increase()</code>: 计算所选时间范围内时间序列的增量，它基本上是速率乘以时间范围选择器中的秒数</li></ul><p>我们选择的时间范围持续时间将确定图表的粒度，比如，持续时间 <code>[1m]</code> ，看起来像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905142504.png"></p><p>有的时候可能想要查看5分钟前或者昨天一天的区间内的样本数据，这个时候我们就需要用到位移操作了，位移操作的关键字是 <code>offset</code>，比如我们可以查询30分钟之前的 master 节点 CPU 的空闲指标数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node_cpu_seconds_total{instance="k8s-master", mode="idle"} offset 30m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>Note</strong></p><p>需要注意的是 <code>offset</code> 关键字需要紧跟在选择器(<code>{}</code>)后面。</p></blockquote><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>Prometheus 没有提供类似与 SQL 语句的关联查询的概念，但是我们可以通过在 Prometheus 上使用 <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/">运算符</a> 来组合时间序列，可以应用于多个时间序列或标量值的常规计算、比较和逻辑运算。</p><blockquote><p><strong>Note</strong></p><p>如果将运算符应用于两个瞬时向量，则它将仅应用于匹配的时间序列，当且仅当时间序列具有完全相同的标签集的时候，才认为是匹配的。当表达式左侧的每个序列和右侧的一个序列完全匹配的时候，在序列上使用这些运算符才可以实现一对一匹配。</p></blockquote><p>比如如下的两个瞬时向量：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node_cpu_seconds_total{instance="k8s-master", cpu="0", mode="idle"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node_cpu_seconds_total{instance="k8s-node1", cpu="0", mode="idle"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们对这两个序列做加法运算来尝试获取 master 和 node1 节点的总的空闲 CPU 时长，则不会返回任何内容了：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905143353.png"></p><p>这是因为这两个时间序列没有完全匹配标签。我们可以使用 <code>on</code> 关键字指定只希望在 <code>mode</code> 标签上进行匹配，就可以计算出结果来：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905143514.png"></p><p>需要注意的是新的瞬时向量包含单个序列，其中仅包含 <code>on</code> 关键字中指定的标签。</p><p>不过在 Prometheus 中还有很多 <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators">聚合操作</a>，所以，如果我们真的想要获取节点的 CPU 总时长，我们完全不用这么操作，使用 <code>sum</code> 操作要简单得多：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sum(node_cpu_seconds_total{mode="idle"}) by (instance)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905145900.png"></p><h3 id="瞬时向量和村量结合"><a href="#瞬时向量和村量结合" class="headerlink" title="瞬时向量和村量结合"></a>瞬时向量和村量结合</h3><p>此外我们还可以将瞬时向量和标量值相结合，这个很简单，就是简单的数学计算，比如：</p><pre class="line-numbers language-none"><code class="language-none">node_cpu_seconds_total{instance="k8s-master"} * 10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220905150052.png"></p><p>会为瞬时向量中每个序列的每个值都剩以10。这对于计算比率和百分比得时候非常有用。</p><ul><li>除了 <code>*</code> 之外，其他常用的算数运算符当然也支持：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>^</code>。</li><li>还有其他的比较运算符：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>。</li><li>逻辑运算符：<code>and</code>、<code>or</code>、<code>unless</code>，不过逻辑运算符只能用于瞬时向量之间。</li></ul><p>除了这些关于 <code>PromQL</code> 最基本的知识点之外，还有很多相关的使用方法，可以参考官网相关介绍：<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/%E3%80%82">https://prometheus.io/docs/prometheus/latest/querying/basics/。</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/k8strain/monitor/promql/">https://www.qikqiak.com/k8strain/monitor/promql/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 安装Grafana及使用</title>
      <link href="/2022/09/07/kubernetes-an-zhuang-grafana-ji-shi-yong/"/>
      <url>/2022/09/07/kubernetes-an-zhuang-grafana-ji-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-安装Grafana及使用"><a href="#Kubernetes-安装Grafana及使用" class="headerlink" title="Kubernetes 安装Grafana及使用"></a>Kubernetes 安装Grafana及使用</h1><p>我们可以使用 Prometheus 采集了 Kubernetes 集群中的一些监控数据指标，我们也使用 promQL 语句查询出了一些数据，并且在 Prometheus 的 Dashboard 中进行了展示，但是明显可以感觉到 Prometheus 的图表功能相对较弱，所以一般情况下我们会一个第三方的工具来展示这些数据，今天我们要和大家使用到的就是 <a href="http://grafana.com/">Grafana</a>。</p><p>Grafana 是一个可视化面板，有着非常漂亮的图表和布局展示，功能齐全的度量仪表盘和图形编辑器，支持 Graphite、zabbix、InfluxDB、Prometheus、OpenTSDB、Elasticsearch 等作为数据源，比 Prometheus 自带的图表展示功能强大太多，更加灵活，有丰富的插件，功能更加强大。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们将 grafana 安装到 Kubernetes 集群中，第一步去查看 grafana 的 docker 镜像的介绍，我们可以在 dockerhub 上去搜索，也可以在官网去查看相关资料，镜像地址如下：<a href="https://hub.docker.com/r/grafana/grafana/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BB%8B%E7%BB%8D%E4%B8%AD%E8%BF%90%E8%A1%8C">https://hub.docker.com/r/grafana/grafana/，我们可以看到介绍中运行</a> grafana 容器的命令非常简单：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker run -d --name=grafana -p 3000:3000 grafana/grafana<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是还有一个需要注意的是 Changelog 中 v5.1.0 版本的更新介绍：</p><pre class="line-numbers language-none"><code class="language-none">Major restructuring of the containerUsage of chown removedFile permissions incompatibility with previous versionsuser id changed from 104 to 472group id changed from 107 to 472Runs as the grafana user by default (instead of root)All default volumes removed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别需要注意第3条，userid 和 groupid 都有所变化，所以我们在运行的容器的时候需要注意这个变化。</p><blockquote><p><strong>Note</strong></p><p>为了方便管理，我们将监控相关的所有资源对象都安装在 <code>kube-mon</code> 这个 namespace 下面，没有的话可以提前创建。</p></blockquote><p>把用到的资源文件统一放到 <code>grafana</code> 目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir ~/grafana &amp;&amp; cd grafana<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在我们将这个容器转化成 Kubernetes 中的 Pod：grafana-deploy.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> grafana<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">revisionHistoryLimit</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> grafana  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> grafana    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana        <span class="token key atrule">image</span><span class="token punctuation">:</span> grafana/grafana<span class="token punctuation">:</span>5.3.4        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">3000</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> GF_SECURITY_ADMIN_USER          <span class="token key atrule">value</span><span class="token punctuation">:</span> admin        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> GF_SECURITY_ADMIN_PASSWORD          <span class="token key atrule">value</span><span class="token punctuation">:</span> admin321        <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">10</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /api/health            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>            <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">60</span>          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>          <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>          <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">30</span>        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /api/health            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>            <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>          <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>          <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">limits</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 256Mi          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 256Mi        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/lib/grafana          <span class="token key atrule">subPath</span><span class="token punctuation">:</span> grafana          <span class="token key atrule">name</span><span class="token punctuation">:</span> storage      <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>        <span class="token key atrule">fsGroup</span><span class="token punctuation">:</span> <span class="token number">472</span>        <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">472</span>      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> storage        <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>          <span class="token key atrule">claimName</span><span class="token punctuation">:</span> grafana<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们<code>grafana/grafana:5.3.4</code>镜像，然后添加了监控检查、资源声明，另外两个比较重要的环境变量<code>GF_SECURITY_ADMIN_USER</code>和<code>GF_SECURITY_ADMIN_PASSWORD</code>，用来配置 grafana 的管理员用户和密码的，由于 grafana 将 dashboard、插件这些数据保存在<code>/var/lib/grafana</code>这个目录下面的，所以我们这里如果需要做数据持久化的话，就需要针对这个目录进行 volume 挂载声明，其他的和我们之前的 Deployment 没什么区别，由于上面我们刚刚提到的 Changelog 中 grafana 的 userid 和 groupid 有所变化，所以我们这里需要增加一个<code>securityContext</code>的声明来进行声明。</p><p>当然如果要使用一个 pvc 对象来持久化数据，我们就需要添加一个可用的 pv 供 pvc 绑定使用：grafana-volume.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.31.0.2 <span class="token comment"># NFS 服务器地址</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/ <span class="token comment"># NFS 服务器共享的目录</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们需要对外暴露 grafana 这个服务，所以我们需要一个对应的 Service 对象，当然用 NodePort 或者再建立一个 ingress 对象都是可行的：grafana-svc.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> grafana<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> grafana<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们直接创建上面的这些资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl create -f grafana-volume.yaml persistentvolume/grafana createdpersistentvolumeclaim/grafana created[root@k8s-master grafana]# kubectl create -f grafana-deploy.yaml deployment.apps/grafana created[root@k8s-master grafana]# kubectl create -f grafana-svc.yaml service/grafana created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完成后，我们可以查看 grafana 对应的 Pod 是否正常：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl get pods -n kube-mon -l app=grafana         NAME                       READY   STATUS             RESTARTS   AGEgrafana-869db94654-m2qpj   0/1     CrashLoopBackOff   1          104s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以看到这里的状态是<code>CrashLoopBackOff</code>，并没有正常启动，我们查看下这个 Pod 的日志：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl logs -f grafana-869db94654-m2qpj -n kube-monGF_PATHS_DATA='/var/lib/grafana' is not writable.You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/#migration-from-a-previous-version-of-the-docker-container-to-5-1-or-latermkdir: cannot create directory '/var/lib/grafana/plugins': Permission denied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面的错误是在<code>5.1</code>版本之后才会出现的，当然你也可以使用之前的版本来规避这个问题。</p></blockquote><p>可以看到是日志中错误很明显就是<code>/var/lib/grafana</code>目录的权限问题，这还是因为5.1版本后 groupid 更改了引起的问题，我们这里增加了<code>securityContext</code>，但是我们将目录<code>/var/lib/grafana</code>挂载到 pvc 这边后目录的拥有者并不是上面的 grafana(472)这个用户了，所以我们需要更改下这个目录的所属用户，这个时候我们可以利用一个 Job 任务去更改下该目录的所属用户：grafana-chown-job.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana<span class="token punctuation">-</span>chown  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana<span class="token punctuation">-</span>chown        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"chown"</span><span class="token punctuation">,</span> <span class="token string">"-R"</span><span class="token punctuation">,</span> <span class="token string">"472:472"</span><span class="token punctuation">,</span> <span class="token string">"/var/lib/grafana"</span><span class="token punctuation">]</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> storage          <span class="token key atrule">subPath</span><span class="token punctuation">:</span> grafana          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/lib/grafana      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> storage        <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>          <span class="token key atrule">claimName</span><span class="token punctuation">:</span> grafana<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们利用一个 busybox 镜像将<code>/var/lib/grafana</code>目录更改成了<code>472</code>这个 user 和 group，不过还需要注意的是下面的 volumeMounts 和 volumes 需要和上面的 Deployment 对应上。</p><p>现在我们删除之前创建的 Deployment 对象，重新创建：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl delete -f grafana-deploy.yaml deployment.apps "grafana" deleted[root@k8s-master grafana]# kubectl create -f grafana-deploy.yaml deployment.apps/grafana created[root@k8s-master grafana]# kubectl create -f grafana-chown-job.yaml job.batch/grafana-chown created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新执行完成后，可以查看下上面的创建的资源对象是否正确了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl get pod -n kube-monNAME                          READY   STATUS      RESTARTS   AGEgrafana-869db94654-gxgjk      1/1     Running     2          102sgrafana-chown-jwkhb           0/1     Completed   0          86s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到有一个状态为<code>Completed</code>的 Pod，这就是上面我们用来更改 grafana 目录权限的 Pod，是一个 Job 任务，所以执行成功后就退出了，状态变成了<code>Completed</code>，而上面的 grafana 的 Pod 也已经是<code>Running</code>状态了，可以查看下该 Pod 的日志确认下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl logs -f grafana-869db94654-gxgjk -n kube-mont=2022-09-04T09:34:26+0000 lvl=info msg="Starting Grafana" logger=server version=5.3.4 commit=69630b9 compiled=2018-11-13T12:19:12+0000t=2022-09-04T09:34:26+0000 lvl=info msg="Config loaded from" logger=settings file=/usr/share/grafana/conf/defaults.init=2022-09-04T09:34:26+0000 lvl=info msg="Config loaded from" logger=settings file=/etc/grafana/grafana.ini......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到上面的日志信息就证明我们的 grafana 的 Pod 已经正常启动起来了。这个时候我们可以查看 Service 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl get svc -n kube-mon -l app=grafanaNAME      TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGEgrafana   NodePort   10.96.179.102   &lt;none&gt;        3000:30907/TCP   8m50s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在我们就可以在浏览器中使用<code>http://&lt;任意节点IP:30907&gt;</code>来访问 grafana 这个服务了</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-1.png"></p><p>由于上面我们配置了管理员的，所以第一次打开的时候会跳转到登录界面，然后就可以用上面我们配置的两个环境变量的值来进行登录了，登录完成后就可以进入到下面 Grafana 的首页</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904174238.png"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在上面的首页中我们可以看到已经安装了 Grafana，接下来点击<code>Add data source</code>进入添加数据源界面。</p><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>我们这个地方配置的数据源是 Prometheus，所以选择这个 Type 即可，给改数据源添加一个 name：prometheus-ds，最主要的是下面<code>HTTP</code>区域是配置数据源的访问模式。</p><p>访问模式是用来控制如何处理对数据源的请求的：</p><ul><li>服务器(Server)访问模式（默认）：所有请求都将从浏览器发送到 Grafana 后端的服务器，后者又将请求转发到数据源，通过这种方式可以避免一些跨域问题，其实就是在 Grafana 后端做了一次转发，需要从Grafana 后端服务器访问该 URL。</li><li>浏览器(Browser)访问模式：所有请求都将从浏览器直接发送到数据源，但是有可能会有一些跨域的限制，使用此访问模式，需要从浏览器直接访问该 URL。</li></ul><p>由于我们这个地方 Prometheus 通过 NodePort 的方式的对外暴露的服务，所以我们这个地方是不是可以使用浏览器访问模式直接访问 Prometheus 的外网地址，但是这种方式显然不是最好的，相当于走的是外网，而我们这里 Prometheus 和 Grafana 都处于 kube-mon 这同一个 namespace 下面，是不是在集群内部直接通过 DNS 的形式就可以访问了，而且还都是走的内网流量，所以我们这里用服务器访问模式显然更好，数据源地址：<code>http://prometheus:9090</code>（因为在同一个 namespace 下面所以直接用 Service 名也可以），然后其他的配置信息就根据实际情况了，比如 Auth 认证，我们这里没有，所以跳过即可，点击最下方的<code>Save &amp; Test</code>提示成功证明我们的数据源配置正确：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl get svc -n kube-monNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGEgrafana      NodePort    10.96.179.102   &lt;none&gt;        3000:30907/TCP      30mprometheus   NodePort    10.96.146.110   &lt;none&gt;        9090:32640/TCP      44hredis        ClusterIP   10.96.143.235   &lt;none&gt;        6379/TCP,9121/TCP   43h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904180103.png"></p><p>数据源添加完成后，就可以来添加 Dashboard 了。</p><h3 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h3><p>同样，切换到主页，我们可以根据自己的需求手动新建一个 Dashboard，除此之外，grafana 的官方网站上还有很多公共的 Dashboard 可以供我们使用，我们这里可以使用<a href="https://grafana.com/dashboards/162/revisions">Kubernetes cluster monitoring (via Prometheus)(dashboard id 为162)</a>这个 Dashboard 来展示 Kubernetes 集群的监控信息，在左侧侧边栏 Create 中点击<code>import</code>导入： </p><p>![image-20220904180506120](/Users/zhangquan/Library/Application Support/typora-user-images/image-20220904180506120.png)</p><p>我们可以将上面编号<code>162</code>的 dashboard 下载到本地，然后这里重新上传即可，也可以在上面的文本框中直接输入<code>162</code>编号回车即可，导入这个 dashboard： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904180639.png"></p><p>需要注意的是在执行上面的 import 之前要记得选择我们的<code>prometheus-ds</code>这个名字的数据源，执行<code>import</code>操作，就可以进入到 dashboard 页面： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904180822.png"></p><p>我们可以看到 dashboard 页面上出现了很多漂亮的图表，但是看上去数据不正常，这是因为这个 dashboard 里面需要的数据指标名称和我们 Prometheus 里面采集到的数据指标不一致造成的，比如，第一个<code>Cluster memory usage(集群内存使用情况)</code>，我们可以点击标题 -&gt; Edit，进入编辑这个图表的编辑页面：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904180923.png"></p><p>进入编辑页面我们就可以看到这个图表的查询语句：</p><blockquote><p>(sum(node_memory_MemTotal) - sum(node_memory_MemFree+node_memory_Buffers+node_memory_Cached) ) / sum(node_memory_MemTotal) * 100</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904181041.png"></p><p>这就是我们之前在 Prometheus 里面查询的<code>promQL</code>语句，我们可以将上面的查询语句复制到 Prometheus 的 Graph 页面进行查询，其实可以预想到是没有对应的数据的。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904181334.png"></p><p>因为我们用<code>node_exporter</code>采集到的数据指标不是<code>node_memory_MemTotal</code>关键字，而是<code>node_memory_MemTotal_bytes</code></p><p>![image-20220904181527134](/Users/zhangquan/Library/Application Support/typora-user-images/image-20220904181527134.png)</p><p>将上面的<code>promQL</code>语句做相应的更改：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">(sum(node_memory_MemTotal_bytes) - sum(node_memory_MemFree_bytes + node_memory_Buffers_bytes+node_memory_Cached_bytes)) / sum(node_memory_MemTotal_bytes) * 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>这个语句的意思就是<code>(整个集群的内存-(整个集群剩余的内存以及Buffer和Cached))/整个集群的内存</code>，简单来说就是总的集群内存使用百分比。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904181735.png"></p><p>可以看到 Prometheus 可以查到数据了。</p><p>将上面 grafana 的<code>promQL</code>语句替换掉，就可以看到图表正常了：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904182227.png"></p><p>同样的，我们可以更改后面的 CPU 和 FileSystem 的使用</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904182813.png"></p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904183812.png"></p><p>同样下面的<code>Pod CPU Usage</code>用来展示 Pod CPU 的使用情况，对应的<code>promQL</code>语句如下，根据 pod_name 来进行统计：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sum by (pod)( rate(container_cpu_usage_seconds_total{image!=""}[1m] ) )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照上面的方法替换 grafana 中的 dashboard 图表中的查询语句： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904184335.png"></p><p>其他的也按照我们的实际需求重新编辑下就可以，下图是最终整个 dashboard 的效果图： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904185720.png"></p><p>最后要记得保存这个 dashboard，除此之外，我们也可以前往 grafana dashboard 的页面去搜索其他的关于 Kubernetes 的监控页面，地址：<a href="https://grafana.com/dashboards%EF%BC%8C%E6%AF%94%E5%A6%82id">https://grafana.com/dashboards，比如id</a> 为747和741的这两个 dashboard。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>我们也可以安装一些其他插件，比如 grafana 就有一个专门针对 Kubernetes 集群监控的插件：<a href="https://grafana.com/plugins/grafana-kubernetes-app">grafana-kubernetes-app</a>，但是该插件很久没有更新了，这里我们介绍一个功能更加强大的插件 <a href="https://github.com/devopsprodigy/kubegraf/">DevOpsProdigy KubeGraf</a>，它是 Grafana 官方的 <a href="https://grafana.com/plugins/grafana-kubernetes-app">Kubernetes 插件</a> 的升级版本，该插件可以用来可视化和分析 Kubernetes 集群的性能，通过各种图形直观的展示了 Kubernetes 集群的主要服务的指标和特征，还可以用于检查应用程序的生命周期和错误日志。</p><p>要安装这个插件，需要到 grafana 的 Pod 里面去执行安装命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pods -n kube-mon -l app=grafanaNAME                       READY   STATUS    RESTARTS   AGEgrafana-869db94654-gxgjk   1/1     Running   3          4h4m[root@k8s-master ~]# kubectl exec -it grafana-869db94654-gxgjk -n kube-mon /bin/bashkubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.grafana@grafana-869db94654-gxgjk:/usr/share/grafana$ grafana-cli plugins install devopsprodigy-kubegraf-appinstalling devopsprodigy-kubegraf-app @ 1.4.2from url: https://grafana.com/api/plugins/devopsprodigy-kubegraf-app/versions/1.4.2/downloadinto: /var/lib/grafana/plugins✔ Installed devopsprodigy-kubegraf-app successfully Restart grafana after installing plugins . &lt;service grafana-server restart&gt;# 由于该插件依赖另外一个 Grafana-piechart-panel 插件，所以如果没有安装，同样需要先安装该插件。grafana@grafana-869db94654-gxgjk:/usr/share/grafana$ grafana-cli plugins install Grafana-piechart-panelinstalling Grafana-piechart-panel @ 1.6.2from url: https://grafana.com/api/plugins/Grafana-piechart-panel/versions/1.6.2/downloadinto: /var/lib/grafana/plugins✔ Installed Grafana-piechart-panel successfully Restart grafana after installing plugins . &lt;service grafana-server restart&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装完成后需要重启 grafana 才会生效，我们这里直接删除 Pod，重建即可。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# kubectl delete -f grafana-deploy.yaml deployment.apps "grafana" deleted[root@k8s-master grafana]# kubectl create -f grafana-deploy.yaml            deployment.apps/grafana created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后通过浏览器打开 Grafana 找到该插件，点击 <code>enable</code> 启用插件。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904214630.png"></p><p>点击 <code>Set up your first k8s-cluster</code> 创建一个新的 Kubernetes 集群:</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-20.png"></p><ul><li>URL 使用 Kubernetes Service 地址即可：<a href="https://kubernetes.default/">https://kubernetes.default:443</a></li><li>Access 访问模式使用：<code>Server(default)</code></li><li>由于插件访问 Kubernetes 集群的各种资源对象信息，所以我们需要配置访问权限，这里我们可以简单使用 kubectl 的 <code>kubeconfig</code> 来进行配置即可。</li><li>勾选 Auth 下面的 <code>TLS Client Auth</code> 和 <code>With CA Cert</code> 两个选项</li><li>其中 <code>TLS Auth Details</code> 下面的值就对应 <code>kubeconfig</code> 里面的证书信息。比如我们这里的 <code>kubeconfig</code> 文件格式如下所示：</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master grafana]# more ~/.kube/config apiVersion: v1clusters:- cluster:    certificate-authority-data:  &lt;certificate-authority-data&gt;    server: https://cluster-endpoint:6443  name: kubernetescontexts:- context:    cluster: kubernetes    user: kubernetes-admin  name: kubernetes-admin@kubernetes- context:    cluster: kubernetes    namespace: kube-system    user: zq  name: zq-contextcurrent-context: kubernetes-admin@kuberneteskind: Configpreferences: {}users:- name: kubernetes-admin  user:    client-certificate-data: &lt;client-certificate-data&gt;    client-key-data: &lt;client-certificate-data&gt;- name: zq  user:    client-certificate: /root/certs/zq.crt    client-key: /root/certs/zq.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么 <code>CA Cert</code> 的值就对应 <code>kubeconfig</code> 里面的 <code>&lt;certificate-authority-data&gt;</code> 进行 base64 解码过后的值；<code>Client Cert</code> 的值对应 <code>&lt;client-certificate-data&gt;</code> 进行 base64 解码过后的值；<code>Client Key</code> 的值就对应 <code>&lt;client-key-data&gt;</code> 进行 base64 解码过后的值。</p><ul><li>最后在 <code>additional datasources</code> 下拉列表中选择 prometheus 的数据源。</li><li>点击 <code>Save &amp; Test</code> 正常就可以保存成功了。</li></ul><p>插件配置完成后，在左侧侧边栏就会出现 <code>DevOpsProdigy KubeGraf</code> 插件的入口，通过插件页面可以查看整个集群的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904220329.png"></p><h2 id="自定义图表"><a href="#自定义图表" class="headerlink" title="自定义图表"></a>自定义图表</h2><p>导入现成的第三方 Dashboard 或许能解决我们大部分问题，但是毕竟还会有需要定制图表的时候，这个时候就需要了解如何去自定义图表了。</p><p>同样在侧边栏点击 “+”，选择 Dashboard，可以根据需要选择各种类型的图表，比如我们这里选择一个 <code>Graph</code> 类型的：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-21.png"></p><p>然后选择左侧图标中的第一个 <code>Queries</code> tab，然后选择 <code>Prometheus</code> 这个数据源：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-23.png"></p><p>然后在 <code>Metrics</code> 区域输入我们要查询的监控 PromQL 语句，比如我们这里想要查询集群节点 CPU 的使用率：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">(1 - sum(increase(node_cpu_seconds_total{mode="idle", instance=~"$node"}[1m])) by (instance) / sum(increase(node_cpu_seconds_total{instance=~"$node"}[1m])) by (instance)) * 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然我们现在还没有具体的学习过 PromQL 语句，但其实我们仔细分析上面的语句也不是很困难，集群节点的 CPU 使用率实际上就相当于排除空闲 CPU 的使用率，所以我们可以优先计算空闲 CPU 的使用时长，除以总的 CPU 时长就是使用率了，用 1 减掉过后就是 CPU 的使用率了，如果想用百分比来表示的话则乘以 100 即可。</p><p>这里有一个需要注意的地方是在 PromQL 语句中有一个 <code>install=~"$node"</code> 的标签，其实意思就是根据 <code>$node</code> 这个参数来进行过滤，也就是我们希望在 Grafana 里面通过参数化来控制每一次计算哪一个节点的 CPU 使用率。</p><p>所以这里就涉及到 Grafana 里面的参数使用。点击页面顶部的 <code>Dashboard Settings</code> 按钮进入配置页面：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-24.png"></p><p>在左侧 tab 栏点击 <code>Variables</code> 进入参数配置页面，如果还没有任何参数，可以通过点击 <code>Add Variable</code> 添加一个新的变量：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-25.png"></p><p>这里需要注意的是变量的名称 <code>node</code> 就是上面我们在 PromQL 语句里面使用的 <code>$node</code> 这个参数，这两个地方必须保持一致，然后最重要的就是参数的获取方式了，比如我们可以通过 <code>Prometheus</code>这个数据源，通过 <code>kubelet_node_name</code> 这个指标来获取，在 Prometheus 里面我们可以查询该指标获取到的值为：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-26.png"></p><p>我们其实只是想要获取节点的名称，所以我们可以用正则表达式去匹配 <code>node=xxx</code> 这个标签，将匹配的值作为参数的值即可。在最下面的 <code>Preview of values</code> 里面会有获取的参数值的预览结果。</p><p>另外由于我们希望能够让用户自由选择一次性可以查询多少个节点的数据，所以我们将 <code>Multi-value</code> 以及 <code>Include All option</code> 都勾选上了，最后记得保存，保存后跳转到 Dashboard 页面就可以看到我们自定义的图表信息：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-grafana-29.png"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Prometheus  监控 Kubernetes 中常用的资源对象</title>
      <link href="/2022/09/04/shi-yong-prometheus-jian-kong-kubernetes-zhong-chang-yong-de-zi-yuan-dui-xiang/"/>
      <url>/2022/09/04/shi-yong-prometheus-jian-kong-kubernetes-zhong-chang-yong-de-zi-yuan-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Prometheus-监控-Kubernetes-中常用的资源对象"><a href="#使用-Prometheus-监控-Kubernetes-中常用的资源对象" class="headerlink" title="使用 Prometheus  监控 Kubernetes 中常用的资源对象"></a>使用 Prometheus  监控 Kubernetes 中常用的资源对象</h1><h2 id="监控容器"><a href="#监控容器" class="headerlink" title="监控容器"></a>监控容器</h2><p>说到容器监控我们自然会想到 <code>cAdvisor</code>，cAdvisor已经内置在了 kubelet 组件之中，所以我们不需要单独去安装，<code>cAdvisor</code> 的数据路径为 <code>/api/v1/nodes/&lt;node&gt;/proxy/metrics</code>，同样我们这里使用 node 的服务发现模式，因为每一个节点下面都有 kubelet，自然都有 <code>cAdvisor</code>采集到的数据指标，配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-cadvisor'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> node  <span class="token key atrule">scheme</span><span class="token punctuation">:</span> https  <span class="token key atrule">tls_config</span><span class="token punctuation">:</span>    <span class="token key atrule">ca_file</span><span class="token punctuation">:</span> /var/run/secrets/kubernetes.io/serviceaccount/ca.crt  <span class="token key atrule">bearer_token_file</span><span class="token punctuation">:</span> /var/run/secrets/kubernetes.io/serviceaccount/token  <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">action</span><span class="token punctuation">:</span> labelmap    <span class="token key atrule">regex</span><span class="token punctuation">:</span> __meta_kubernetes_node_label_(.+)  <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__    <span class="token key atrule">replacement</span><span class="token punctuation">:</span> kubernetes.default.svc<span class="token punctuation">:</span><span class="token number">443</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_node_name<span class="token punctuation">]</span>    <span class="token key atrule">regex</span><span class="token punctuation">:</span> (.+)    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __metrics_path__    <span class="token key atrule">replacement</span><span class="token punctuation">:</span> /api/v1/nodes/$<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>/proxy/metrics/cadvisor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的配置和我们之前配置 <code>node-exporter</code> 的时候几乎是一样的，区别是我们这里使用了 https 的协议，另外需要注意的是配置了 ca.cart 和 token 这两个文件，这两个文件是 Pod 启动后自动注入进来的，通过这两个文件我们可以在 Pod 中访问 apiserver，比如我们这里的 <code>__address__</code> 不再是 nodeip 了，而是 kubernetes 在集群中的服务地址，然后加上<code>__metrics_path__</code> 的访问路径 <code>/api/v1/nodes/${1}/proxy/metrics/cadvisor</code>，因为我们现在是通过 kubernetes 的 apiserver 地址去进行访问的，现在同样更新下配置，然后查看 Targets 路径：</p><p>更新配置：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml  configmap/prometheus-config configured# 隔一会儿执行reload操作[root@k8s-master prometheus]# curl -X POST "http://10.96.146.110:9090/-/reload" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 Targets 路径：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904162720.png"></p><p>我们可以切换到 Graph 路径下面查询容器相关数据，比如我们这里来查询集群中所有 Pod 的 CPU 使用情况，kubelet 中的 cAdvisor 采集的指标和含义，可以查看 <a href="https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md">Monitoring cAdvisor with Prometheus</a> 说明，其中有一项：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">container_cpu_usage_seconds_total   Counter     Cumulative cpu time consumed    seconds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><code>container_cpu_usage_seconds_total</code> 是容器累计使用的 CPU 时间，用它除以 CPU 的总时间，就可以得到容器的 CPU 使用率了：</p><p>首先计算容器的 CPU 占用时间，由于节点上的 CPU 有多个，所以需要将容器在每个 CPU 上占用的时间累加起来，Pod 在 1m 内累积使用的 CPU 时间为：(根据 pod 和 namespace 进行分组查询)</p><blockquote><pre class="line-numbers language-none"><code class="language-none">sum(rate(container_cpu_usage_seconds_total{image!="",pod!=""}[1m])) by (namespace, pod)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>然后计算 CPU 的总时间，这里的 CPU 数量是容器分配到的 CPU 数量，<code>container_spec_cpu_quota</code>是容器的 CPU 配额，它的值是容器指定的 <code>CPU 个数 * 100000</code>，所以 Pod 在 1s 内 CPU 的总时间为：Pod 的 CPU 核数 * 1s：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">sum(container_spec_cpu_quota{image!="", pod!=""}) by(namespace, pod) / 100000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>将上面这两个语句的结果相除，就得到了容器的 CPU 使用率：</p><blockquote><p>(sum(rate(container_cpu_usage_seconds_total{image!=””,pod!=””}[1m])) by (namespace, pod)) / (sum(container_spec_cpu_quota{image!=””, pod!=””}) by(namespace, pod) / 100000) * 100</p></blockquote><p>在 promethues 里面执行上面的 promQL 语句可以得到下面的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904163745.png"></p><h2 id="监控-apiserver"><a href="#监控-apiserver" class="headerlink" title="监控 apiserver"></a>监控 apiserver</h2><p>apiserver 作为 Kubernetes 最核心的组件，当然他的监控也是非常有必要的，对于 apiserver 的监控我们可以直接通过 kubernetes 的 Service 来获取：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get svcNAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGEkubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   21d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面这个 Service 就是我们集群的 apiserver 在集群内部的 Service 地址，要自动发现 Service 类型的服务，我们就需要用到 role 为 Endpoints 的 <code>kubernetes_sd_configs</code>，我们可以在 ConfigMap 对象中添加上一个 Endpoints 类型的服务的监控任务：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-apiservers'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> endpoints<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面这个任务是定义的一个类型为 endpoints 的 kubernetes_sd_configs ，添加到 Prometheus 的 ConfigMap 的配置文件中，然后更新配置：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml  configmap/prometheus-config configured# 隔一会儿执行reload操作[root@k8s-master prometheus]# curl -X POST "http://10.96.146.110:9090/-/reload" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新完成后，我们再去查看 Prometheus 的 Dashboard 的 target 页面：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904164515.png"></p><p>我们可以看到 kubernetes-apiservers 下面出现了很多实例，这是因为这里我们使用的是 Endpoints 类型的服务发现，所以 Prometheus 把所有的 Endpoints 服务都抓取过来了，同样的，上面我们需要的服务名为 <code>kubernetes</code> 这个 apiserver 的服务也在这个列表之中，那么我们应该怎样来过滤出这个服务来呢？还记得前面的 <code>relabel_configs</code> 吗？没错，同样我们需要使用这个配置，只是我们这里不是使用 <code>replace</code> 这个动作了，而是 <code>keep</code>，就是只把符合我们要求的给保留下来，哪些才是符合我们要求的呢？我们可以把鼠标放置在任意一个 target 上，可以查看到<code>Before relabeling</code>里面所有的元数据，比如我们要过滤的服务是 <code>default</code> 这个 namespace 下面，服务名为 <code>kubernetes</code> 的元数据，所以这里我们就可以根据对应的 <code>__meta_kubernetes_namespace</code> 和 <code>__meta_kubernetes_service_name</code> 这两个元数据来 relabel，另外由于 kubernetes 这个服务对应的端口是 443，需要使用 https 协议，所以这里我们需要使用 https 的协议，对应的就需要将 ca 证书配置上，如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-apiservers'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> endpoints  <span class="token key atrule">scheme</span><span class="token punctuation">:</span> https  <span class="token key atrule">tls_config</span><span class="token punctuation">:</span>    <span class="token key atrule">ca_file</span><span class="token punctuation">:</span> /var/run/secrets/kubernetes.io/serviceaccount/ca.crt  <span class="token key atrule">bearer_token_file</span><span class="token punctuation">:</span> /var/run/secrets/kubernetes.io/serviceaccount/token  <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_namespace<span class="token punctuation">,</span> __meta_kubernetes_service_name<span class="token punctuation">,</span> __meta_kubernetes_endpoint_port_name<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> keep    <span class="token key atrule">regex</span><span class="token punctuation">:</span> default;kubernetes;https<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在重新更新配置文件、重新加载 Prometheus，切换到 Prometheus 的 Targets 路径下查看：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904164841.png"></p><p>现在可以看到 <code>kubernetes-apiserver</code> 这个任务下面只有 apiserver 这一个实例了，证明我们的 <code>relabel</code> 是成功的，现在我们切换到 Graph 路径下面查看下采集到的数据，比如查询 apiserver 的总的请求数：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sum(rate(apiserver_request_count[1m]))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904165507.png"></p><p>这样我们就完成了对 Kubernetes APIServer 的监控。</p><p>另外如果我们要来监控其他系统组件，比如 kube-controller-manager、kube-scheduler 的话应该怎么做呢？由于 apiserver 服务 namespace 在 default 使用默认的 Service kubernetes，而其余组件服务在 kube-system 这个 namespace 下面，如果我们想要来监控这些组件的话，需要手动创建单独的 Service，其中 kube-sheduler 的指标数据端口为 10251，kube-controller-manager 对应的端口为 10252。</p><h2 id="监控-Pod"><a href="#监控-Pod" class="headerlink" title="监控 Pod"></a>监控 Pod</h2><p>上面的 apiserver 实际上就是一种特殊的 Endpoints，现在我们同样来配置一个任务用来专门发现普通类型的 Endpoint，其实就是 Service 关联的 Pod 列表：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-endpoints'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> endpoints  <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_service_annotation_prometheus_io_scrape<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> keep    <span class="token key atrule">regex</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_service_annotation_prometheus_io_scheme<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __scheme__    <span class="token key atrule">regex</span><span class="token punctuation">:</span> (https<span class="token punctuation">?</span>)  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_service_annotation_prometheus_io_path<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __metrics_path__    <span class="token key atrule">regex</span><span class="token punctuation">:</span> (.+)  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">,</span> __meta_kubernetes_service_annotation_prometheus_io_port<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__    <span class="token key atrule">regex</span><span class="token punctuation">:</span> (<span class="token punctuation">[</span>^<span class="token punctuation">:</span><span class="token punctuation">]</span>+)(<span class="token punctuation">?</span><span class="token punctuation">:</span><span class="token punctuation">:</span>\d+)<span class="token punctuation">?</span>;(\d+)    <span class="token key atrule">replacement</span><span class="token punctuation">:</span> $1<span class="token punctuation">:</span>$2  <span class="token punctuation">-</span> <span class="token key atrule">action</span><span class="token punctuation">:</span> labelmap    <span class="token key atrule">regex</span><span class="token punctuation">:</span> __meta_kubernetes_service_label_(.+)  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_namespace<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> kubernetes_namespace  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_service_name<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> kubernetes_name  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__meta_kubernetes_pod_name<span class="token punctuation">]</span>    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> kubernetes_pod_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意我们这里在 <code>relabel_configs</code> 区域做了大量的配置，特别是第一个保留<code>__meta_kubernetes_service_annotation_prometheus_io_scrape</code> 为 true 的才保留下来，这就是说要想自动发现集群中的 Endpoint，就需要我们在 Service 的 <code>annotation</code> 区域添加 <code>prometheus.io/scrape=true</code> 的声明，现在我们先将上面的配置更新，查看下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904170003.png"></p><p>我们可以看到 <code>kubernetes-endpoints</code> 这一个任务下面只发现了两个服务，这是因为我们在 <code>relabel_configs</code> 中过滤了 <code>annotation</code> 有 <code>prometheus.io/scrape=true</code> 的 Service，而现在我们系统中只有这样一个 <code>kube-dns</code> 服务符合要求，该 Service 下面有两个实例，所以出现了两个实例：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get svc kube-dns -n kube-system -o yamlapiVersion: v1kind: Servicemetadata:  annotations:    prometheus.io/port: "9153"  # metrics 接口的端口    prometheus.io/scrape: "true"  # 这个注解可以让prometheus自动发现  creationTimestamp: "2022-08-13T11:17:30Z"  labels:    k8s-app: kube-dns    kubernetes.io/cluster-service: "true"    kubernetes.io/name: KubeDNS  name: kube-dns  namespace: kube-system......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们在之前创建的 redis 这个 Service 中添加上 <code>prometheus.io/scrape=true</code> 这个 annotation：prometheus-redis.yaml </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">annotations</span><span class="token punctuation">:</span>        <span class="token key atrule">prometheus.io/scrape</span><span class="token punctuation">:</span> <span class="token string">"true"</span>        <span class="token key atrule">prometheus.io/port</span><span class="token punctuation">:</span> <span class="token string">"9121"</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> redis    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis        <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span><span class="token number">4</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 100Mi        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>exporter        <span class="token key atrule">image</span><span class="token punctuation">:</span> oliver006/redis_exporter<span class="token punctuation">:</span>latest        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 100Mi        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9121</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>   <span class="token comment"># 加入annotation</span>    <span class="token key atrule">prometheus.io/scrape</span><span class="token punctuation">:</span> <span class="token string">"true"</span>    <span class="token key atrule">prometheus.io/port</span><span class="token punctuation">:</span> <span class="token string">"9121"</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> prom    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9121</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9121</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 redis 服务的 metrics 接口在 9121 这个 redis-exporter 服务上面，所以我们还需要添加一个 <code>prometheus.io/port=9121</code> 这样的 annotations，然后更新这个 Service：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-redis.yaml deployment.apps/redis unchangedservice/redis configured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>更新完成后，去 Prometheus 查看 Targets 路径，可以看到 redis 服务自动出现在了 <code>kubernetes-endpoints</code> 这个任务下面：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220904170736.png"></p><p>这样以后我们有了新的服务，服务本身提供了 <code>/metrics</code> 接口，我们就完全不需要用静态的方式去配置了，到这里我们就可以将之前配置的 redis 的静态配置去掉了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/55.%E7%9B%91%E6%8E%A7Kubernetes%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1.html">https://www.qikqiak.com/k8s-book/docs/55.%E7%9B%91%E6%8E%A7Kubernetes%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Prometheus  监控 Kubernetes 集群节点</title>
      <link href="/2022/09/04/shi-yong-prometheus-jian-kong-kubernetes-ji-qun-jie-dian/"/>
      <url>/2022/09/04/shi-yong-prometheus-jian-kong-kubernetes-ji-qun-jie-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Prometheus-监控-Kubernetes-集群节点"><a href="#使用-Prometheus-监控-Kubernetes-集群节点" class="headerlink" title="使用 Prometheus  监控 Kubernetes 集群节点"></a>使用 Prometheus  监控 Kubernetes 集群节点</h1><p>对于 Kubernetes 集群本身的监控也是非常重要的，我们需要时时刻刻了解集群的运行状态。</p><p>对于集群的监控一般我们需要考虑以下几个方面：</p><ul><li>Kubernetes 节点的监控：比如节点的 cpu、load、disk、memory 等指标</li><li>内部系统组件的状态：比如 kube-scheduler、kube-controller-manager、kubedns/coredns 等组件的详细运行状态</li><li>编排级的 metrics：比如 Deployment 的状态、资源请求、调度和 API 延迟等数据指标</li></ul><p>Kubernetes 集群的监控方案目前主要有以下几种方案：</p><ul><li>Heapster：Heapster 是一个集群范围的监控和数据聚合工具，以 Pod 的形式运行在集群中。 heapster 除了 Kubelet/cAdvisor 之外，我们还可以向 Heapster 添加其他指标源数据，比如 kube-state-metrics，需要注意的是 Heapster 已经被废弃了，后续版本中会使用 metrics-server 代替。</li><li>cAdvisor：<a href="https://github.com/google/cadvisor">cAdvisor</a> 是 Google 开源的容器资源监控和性能分析工具，它是专门为容器而生，本身也支持 Docker 容器。</li><li>kube-state-metrics：<a href="https://github.com/kubernetes/kube-state-metrics">kube-state-metrics</a> 通过监听 API Server 生成有关资源对象的状态指标，比如 Deployment、Node、Pod，需要注意的是 kube-state-metrics 只是简单提供一个 metrics 数据，并不会存储这些指标数据，所以我们可以使用 Prometheus 来抓取这些数据然后存储。</li><li>metrics-server：metrics-server 也是一个集群范围内的资源数据聚合工具，是 Heapster 的替代品，同样的，metrics-server 也只是显示数据，并不提供数据存储服务。</li></ul><p>不过 kube-state-metrics 和 metrics-server 之间还是有很大不同的，二者的主要区别如下：</p><ul><li><p>kube-state-metrics 主要关注的是业务相关的一些元数据，比如 Deployment、Pod、副本状态等</p></li><li><p>metrics-server 主要关注的是<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/resource-metrics-api.md">资源度量 API</a> 的实现，比如 CPU、文件描述符、内存、请求延时等指标。</p></li></ul><h2 id="监控集群节点"><a href="#监控集群节点" class="headerlink" title="监控集群节点"></a>监控集群节点</h2><p>要监控节点其实我们已经有很多非常成熟的方案了，比如 Nagios、zabbix，甚至我们自己来收集数据也可以，我们这里通过 Prometheus 来采集节点的监控指标数据，可以通过 <a href="https://github.com/prometheus/node_exporter">node_exporter</a>来获取，顾名思义，<code>node_exporter</code> 就是抓取用于采集服务器节点的各种运行指标，目前 <code>node_exporter</code> 支持几乎所有常见的监控点，比如 conntrack，cpu，diskstats，filesystem，loadavg，meminfo，netstat 等，详细的监控点列表可以参考其 <a href="https://github.com/prometheus/node_exporter">Github 仓库</a>。</p><p>我们可以通过 DaemonSet 控制器来部署该服务，这样每一个节点都会自动运行一个这样的 Pod，如果我们从集群中删除或者添加节点后，也会进行自动扩展。</p><p>在部署 <code>node-exporter</code> 的时候有一些细节需要注意，如下资源清单文件：prometheus-node-exporter.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>exporter  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>exporter<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>exporter  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>exporter    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">hostPID</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">hostIPC</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>exporter        <span class="token key atrule">image</span><span class="token punctuation">:</span> prom/node<span class="token punctuation">-</span>exporter<span class="token punctuation">:</span>v0.16.0        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9100</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">0.15</span>        <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>          <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>path.procfs        <span class="token punctuation">-</span> /host/proc        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>path.sysfs        <span class="token punctuation">-</span> /host/sys        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>collector.filesystem.ignored<span class="token punctuation">-</span>mount<span class="token punctuation">-</span>points        <span class="token punctuation">-</span> <span class="token string">'"^/(sys|proc|dev|host|etc)($|/)"'</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> dev          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /host/dev        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> proc          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /host/proc        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sys          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /host/sys        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> rootfs          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /rootfs      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>  <span class="token comment"># 添加容忍的声明</span>      <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"node-role.kubernetes.io/master"</span>        <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span>        <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span>      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> proc          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /proc        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> dev          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /dev        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sys          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /sys        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> rootfs          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们要获取到的数据是主机的监控指标数据，而我们的 <code>node-exporter</code> 是运行在容器中的，所以我们在 Pod 中需要配置一些 Pod 的安全策略，这里我们就添加了 <code>hostPID: true</code>、<code>hostIPC: true</code>、<code>hostNetwork: true</code> 3个策略，用来使用主机的 <code>PID namespace</code>、<code>IPC namespace</code> 以及主机网络，这些 namespace 就是用于容器隔离的关键技术，要注意这里的 namespace 和集群中的 namespace 是两个完全不相同的概念。</p><p>另外我们还将主机的 <code>/dev</code>、<code>/proc</code>、<code>/sys</code>这些目录挂载到容器中，这些因为我们采集的很多节点数据都是通过这些文件夹下面的文件来获取到的，比如我们在使用 <code>top</code> 命令可以查看当前 cpu 使用情况，数据就来源于文件 <code>/proc/stat</code>，使用 <code>free</code> 命令可以查看当前内存使用情况，其数据来源是来自 <code>/proc/meminfo</code> 文件。</p><p>另外由于我们集群使用的是 <code>kubeadm</code> 搭建的，所以如果希望 master 节点也一起被监控，则需要添加相应的容忍，然后直接创建上面的资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-node-exporter.yaml daemonset.apps/node-exporter created[root@k8s-master prometheus]# kubectl get pods -n kube-mon  -o wide  NAME                          READY   STATUS    RESTARTS   AGE     IP                NODE         NOMINATED NODE   READINESS GATESnode-exporter-bl6nb           1/1     Running   0          2m34s   172.31.0.2        k8s-master   &lt;none&gt;           &lt;none&gt;node-exporter-fwzlt           1/1     Running   0          2m34s   172.31.0.4        k8s-node2    &lt;none&gt;           &lt;none&gt;node-exporter-pcr9w           1/1     Running   0          2m34s   172.31.0.3        k8s-node1    &lt;none&gt;           &lt;none&gt;prometheus-75d4666dcd-vlth8   1/1     Running   0          66m     192.168.169.155   k8s-node2    &lt;none&gt;           &lt;none&gt;redis-6468bf6c84-qmm2k        2/2     Running   0          27m     192.168.36.93     k8s-node1    &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>部署完成后，我们可以看到在3个节点上都运行了一个 Pod，我们这里不需要创建一个 Service 吗？我们应该怎样去获取<code>/metrics</code>数据呢？我们上面是不是指定了<code>hostNetwork=true</code>，所以在每个节点上就会绑定一个端口 9100，我们可以通过这个端口去获取到监控指标数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# curl localhost:9100/metrics | more # HELP go_gc_duration_seconds A summary of the GC invocation durations.# TYPE go_gc_duration_seconds summarygo_gc_duration_seconds{quantile="0"} 7.0468e-05go_gc_duration_seconds{quantile="0.25"} 7.0468e-05go_gc_duration_seconds{quantile="0.5"} 8.252e-05go_gc_duration_seconds{quantile="0.75"} 8.252e-05go_gc_duration_seconds{quantile="1"} 8.252e-05go_gc_duration_seconds_sum 0.000152988go_gc_duration_seconds_count 2......promhttp_metric_handler_requests_total{code="200"} 0promhttp_metric_handler_requests_total{code="500"} 0promhttp_metric_handler_requests_total{code="503"} 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然如果你觉得上面的手动安装方式比较麻烦，我们也可以使用 Helm 的方式来安装：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm upgrade --install --name node-exporter --namespace kube-mon stable/prometheus-node-exporter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>由于我们这里每个节点上面都运行了 <code>node-exporter</code> 程序，如果我们通过一个 Service 来将数据收集到一起用静态配置的方式配置到 Prometheus 去中，就只会显示一条数据，我们得自己在指标数据中去过滤每个节点的数据，当然我们也可以手动的把所有节点用静态的方式配置到 Prometheus 中去，但是以后要新增或者去掉节点的时候就还得手动去配置，那么有没有一种方式可以让 Prometheus 去自动发现我们节点的 <code>node-exporter</code> 程序，并且按节点进行分组呢？这就是 Prometheus 里面非常重要的<strong>服务发现</strong>功能了。</p><p>在 Kubernetes 下，Promethues 通过与 Kubernetes API 集成，主要支持5中服务发现模式，分别是：<code>Node</code>、<code>Service</code>、<code>Pod</code>、<code>Endpoints</code>、<code>Ingress</code>。</p><p>我们通过 kubectl 命令可以很方便的获取到当前集群中的所有节点信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get nodesNAME         STATUS   ROLES                  AGE   VERSIONk8s-master   Ready    control-plane,master   20d   v1.20.9k8s-node1    Ready    &lt;none&gt;                 20d   v1.20.9k8s-node2    Ready    &lt;none&gt;                 20d   v1.20.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是要让 Prometheus 也能够获取到当前集群中的所有节点信息的话，我们就需要利用 Node 的服务发现模式，同样的，在 <code> prometheus-cm.yaml</code> 文件中配置如下的 job 任务即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-nodes'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过指定 <code>kubernetes_sd_configs</code> 的模式为<code>node</code>，Prometheus 就会自动从 Kubernetes 中发现所有的 node 节点并作为当前 job 监控的目标实例，发现的节点 <code>/metrics</code> 接口是默认的 kubelet 的 HTTP 接口。</p><p>prometheus 的 ConfigMap 更新完成后，同样的我们执行 reload 操作，让配置生效：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml configmap/prometheus-config configured# 隔一会儿执行reload操作[root@k8s-master prometheus]# kubectl get svc -n kube-monNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGEprometheus   NodePort    10.96.146.110   &lt;none&gt;        9090:32640/TCP      71mredis        ClusterIP   10.96.143.235   &lt;none&gt;        6379/TCP,9121/TCP   36m[root@k8s-master prometheus]# curl -X POST "http://10.96.146.110:9090/-/reload"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置生效后，我们再去 prometheus 的 dashboard 中查看 Targets 是否能够正常抓取数据，访问<code>http://任意节点IP:32640</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902225935.png"></p><p>我们可以看到上面的<code>kubernetes-nodes</code>这个 job 任务已经自动发现了我们3个 node 节点，但是在获取数据的时候失败了，出现了类似于下面的错误信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server returned HTTP status 400 Bad Request<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个是因为 prometheus 去发现 Node 模式的服务的时候，访问的端口默认是10250，而默认是需要认证的 https 协议才有权访问的，但实际上我们并不是希望让去访问10250端口的 <code>/metrics</code>接口，而是 <code>node-exporter</code> 绑定到节点的 9100 端口，所以我们应该将这里的 <code>10250</code> 替换成 <code>9100</code>，但是应该怎样替换呢？</p><p>这里我们就需要使用到 Prometheus 提供的 <code>relabel_configs</code> 中的 <code>replace</code> 能力了，<code>relabel</code> 可以在 Prometheus 采集数据之前，通过 Target 实例的 <code>Metadata</code> 信息，动态重新写入 Label 的值。除此之外，我们还能根据 Target 实例的 <code>Metadata</code> 信息选择是否采集或者忽略该 Target 实例。比如我们这里就可以去匹配 <code>__address__</code> 这个 Label 标签，然后替换掉其中的端口，如果你不知道有哪些 Label 标签可以操作的话，可以将鼠标移动到 Targets 的标签区域，其中显示的 <code>Before relabeling</code> 区域都是我们可以操作的标签：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902230807.png"></p><p>现在我们来替换掉端口，修改 ConfigMap：prometheus-cm.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-nodes'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> node  <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>    <span class="token key atrule">regex</span><span class="token punctuation">:</span> <span class="token string">'(.*):10250'</span>    <span class="token key atrule">replacement</span><span class="token punctuation">:</span> <span class="token string">'${1}:9100'</span>    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就是一个正则表达式，去匹配 <code>__address__</code> 这个标签，然后将 host 部分保留下来，port 替换成了 9100，现在我们重新更新配置文件，执行 reload 操作，然后再去看 Prometheus 的 Dashboard 的 Targets 路径下面 kubernetes-nodes 这个 job 任务是否正常了：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902231454.png"></p><p>我们可以看到现在已经正常了，但是还有一个问题就是我们采集的指标数据 Label 标签就只有一个节点的 hostname，这对于我们在进行监控分组分类查询的时候带来了很多不方便的地方，要是我们能够将集群中 Node 节点的 Label 标签也能获取到就很好了。这里我们可以通过 <code>labelmap</code> 这个属性来将 Kubernetes 的 Label 标签添加为 Prometheus 的指标数据的标签：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-nodes'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> node  <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>    <span class="token key atrule">regex</span><span class="token punctuation">:</span> <span class="token string">'(.*):10250'</span>    <span class="token key atrule">replacement</span><span class="token punctuation">:</span> <span class="token string">'${1}:9100'</span>    <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__    <span class="token key atrule">action</span><span class="token punctuation">:</span> replace  <span class="token punctuation">-</span> <span class="token key atrule">action</span><span class="token punctuation">:</span> labelmap    <span class="token key atrule">regex</span><span class="token punctuation">:</span> __meta_kubernetes_node_label_(.+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加了一个 action 为 <code>labelmap</code>，正则表达式是 <code>__meta_kubernetes_node_label_(.+)</code> 的配置，这里的意思就是表达式中匹配都的数据也添加到指标数据的 Label 标签中去。</p><p>对于 <code>kubernetes_sd_configs</code> 下面可用的元信息标签如下：</p><ul><li><code>__meta_kubernetes_node_name</code>：节点对象的名称</li><li><code>_meta_kubernetes_node_label</code>：节点对象中的每个标签</li><li><code>_meta_kubernetes_node_annotation</code>：来自节点对象的每个注释</li><li><code>_meta_kubernetes_node_address</code>：每个节点地址类型的第一个地址（如果存在）</li></ul><p>关于 kubernets_sd_configs 更多信息可以查看官方文档：<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#">kubernetes_sd_config</a></p><p>另外由于 kubelet 也自带了一些监控指标数据，就上面我们提到的 10250 端口，所以我们这里也把 kubelet 的监控任务也一并配置上：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'kubernetes-kubelet'</span>  <span class="token key atrule">kubernetes_sd_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> node  <span class="token key atrule">scheme</span><span class="token punctuation">:</span> https  <span class="token key atrule">tls_config</span><span class="token punctuation">:</span>    <span class="token key atrule">ca_file</span><span class="token punctuation">:</span> /var/run/secrets/kubernetes.io/serviceaccount/ca.crt    <span class="token key atrule">insecure_skip_verify</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">bearer_token_file</span><span class="token punctuation">:</span> /var/run/secrets/kubernetes.io/serviceaccount/token  <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">action</span><span class="token punctuation">:</span> labelmap    <span class="token key atrule">regex</span><span class="token punctuation">:</span> __meta_kubernetes_node_label_(.+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这里需要特别注意的是这里必须使用 <code>https</code> 协议访问，这样就必然需要提供证书，我们这里是通过配置 <code>insecure_skip_verify: true</code> 来跳过了证书校验，但是除此之外，要访问集群的资源，还必须要有对应的权限才可以，也就是对应的 ServiceAccount 的权限允许才可以，我们这里部署的 prometheus 关联的 ServiceAccount 对象前面我们已经提到过了，这里我们只需要将 Pod 中自动注入的 <code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code> 和 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 文件配置上，就可以获取到对应的权限了。</p><p>现在我们再去更新下配置文件，执行 reload 操作，让配置生效</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml configmap/prometheus-config configured# 隔一会儿执行reload操作[root@k8s-master prometheus]# curl -X POST "http://10.96.146.110:9090/-/reload"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后访问 Prometheus 的 Dashboard 查看 Targets 路径：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902232253.png"></p><p>现在可以看到我们上面添加的 <code>kubernetes-kubelet</code> 和 <code>kubernetes-nodes</code> 这两个 job 任务都已经配置成功了，而且二者的 Labels 标签都和集群的 node 节点标签保持一致了。</p><p>现在我们就可以切换到 Graph 路径下面查看采集的一些指标数据了，比如查询 node_load1 指标：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902232620.png"></p><p>我们可以看到将3个 node 节点对应的 node_load1 指标数据都查询出来了，同样的，我们还可以使用 PromQL 语句来进行更复杂的一些聚合查询操作，还可以根据我们的 Labels 标签对指标数据进行聚合，比如我们这里只查询  k8s-node1 节点的数据，可以使用表达式<code>node_load1{instance="k8s-node1"}</code>来进行查询：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902232750.png"></p><p>到这里我们就把 Kubernetes 集群节点使用 Prometheus 监控起来了。</p><p> prometheus-cm.yaml  内容如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apiVersion: v1kind: ConfigMapmetadata:  name: prometheus-config  namespace: kube-mondata:  prometheus.yml: |    global:      scrape_interval: 15s      scrape_timeout: 15s    scrape_configs:    - job_name: 'prometheus'      static_configs:        - targets: ['localhost:9090']    - job_name: 'coredns'      static_configs:        - targets: ['192.168.235.243:9153', '192.168.235.240:9153']    - job_name: 'redis'      static_configs:      - targets: ['redis:9121']    - job_name: 'kubernetes-nodes'      kubernetes_sd_configs:      - role: node      relabel_configs:      - source_labels: [__address__]        regex: '(.*):10250'        replacement: '${1}:9100'        target_label: __address__        action: replace      - action: labelmap        regex: __meta_kubernetes_node_label_(.+)    - job_name: 'kubernetes-kubelet'      kubernetes_sd_configs:      - role: node      scheme: https      tls_config:        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt        insecure_skip_verify: true      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token      relabel_configs:      - action: labelmap        regex: __meta_kubernetes_node_label_(.+)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/54.%E7%9B%91%E6%8E%A7Kubernetes%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9.html">https://www.qikqiak.com/k8s-book/docs/54.%E7%9B%91%E6%8E%A7Kubernetes%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Prometheus  监控 Kubernetes 集群中的应用</title>
      <link href="/2022/09/04/shi-yong-prometheus-jian-kong-kubernetes-ji-qun-zhong-de-ying-yong/"/>
      <url>/2022/09/04/shi-yong-prometheus-jian-kong-kubernetes-ji-qun-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Prometheus-监控-Kubernetes-集群中的应用"><a href="#使用-Prometheus-监控-Kubernetes-集群中的应用" class="headerlink" title="使用 Prometheus  监控 Kubernetes 集群中的应用"></a>使用 Prometheus  监控 Kubernetes 集群中的应用</h1><p>前面<code>Prometheus</code>的数据指标是通过一个公开的 HTTP(S) 数据接口获取到的，我们不需要单独安装监控的 agent，只需要暴露一个 metrics 接口，Prometheus 就会定期去拉取数据；对于一些普通的 HTTP 服务，我们完全可以直接重用这个服务，添加一个<code>/metrics</code>接口暴露给 Prometheus；而且获取到的指标数据格式是非常易懂的，不需要太高的学习成本。</p><p>现在很多服务从一开始就内置了一个<code>/metrics</code>接口，比如 Kubernetes 的各个组件、istio 服务网格都直接提供了数据指标接口。有一些服务即使没有原生集成该接口，也完全可以使用一些 exporter 来获取到指标数据，比如 mysqld_exporter、node_exporter，这些 exporter 就有点类似于传统监控服务中的 agent，作为一直服务存在，用来收集目标服务的指标数据然后直接暴露给 Prometheus。</p><h2 id="普通应用监控"><a href="#普通应用监控" class="headerlink" title="普通应用监控"></a>普通应用监控</h2><p>对于普通应用只需要能够提供一个满足 prometheus 格式要求的 <code>/metrics</code> 接口就可以让 Prometheus 来接管监控，比如 Kubernetes 集群中非常重要的 CoreDNS 插件，一般默认情况下就开启了 <code>/metrics</code> 接口：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get cm coredns -n kube-system -o yamlapiVersion: v1data:  Corefile: |    .:53 {        errors        health {           lameduck 5s        }        ready        kubernetes cluster.local in-addr.arpa ip6.arpa {           pods insecure           fallthrough in-addr.arpa ip6.arpa           ttl 30        }        prometheus :9153        forward . /etc/resolv.conf {           max_concurrent 1000        }        cache 30        loop        reload        loadbalance    }kind: ConfigMapmetadata:  creationTimestamp: "2022-08-13T11:17:30Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:Corefile: {}    manager: kubeadm    operation: Update    time: "2022-08-13T11:17:30Z"  name: coredns  namespace: kube-system  resourceVersion: "225"  uid: c643c27a-210e-4f0e-8897-7fa33cf78626<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 ConfigMap 中 <code>prometheus :9153</code> 就是开启 prometheus 的插件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get pods -n kube-system -l k8s-app=kube-dns -o wideNAME                       READY   STATUS    RESTARTS   AGE   IP                NODE         NOMINATED NODE   READINESS GATEScoredns-5897cd56c4-kqfn2   1/1     Running   14         20d   192.168.235.243   k8s-master   &lt;none&gt;           &lt;none&gt;coredns-5897cd56c4-wcgdh   1/1     Running   14         20d   192.168.235.240   k8s-master   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以先尝试手动访问下 <code>/metrics</code> 接口，如果能够手动访问到那证明接口是没有任何问题的：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# curl http://192.168.235.243:9153/metrics# HELP coredns_build_info A metric with a constant '1' value labeled by version, revision, and goversion from which CoreDNS was built.# TYPE coredns_build_info gaugecoredns_build_info{goversion="go1.14.4",revision="f59c03d",version="1.7.0"} 1# HELP coredns_cache_entries The number of elements in the cache.# TYPE coredns_cache_entries gaugecoredns_cache_entries{server="dns://:53",type="denial"} 10coredns_cache_entries{server="dns://:53",type="success"} 1# HELP coredns_cache_misses_total The count of cache misses.# TYPE coredns_cache_misses_total countercoredns_cache_misses_total{server="dns://:53"} 11# HELP coredns_dns_request_duration_seconds Histogram of the time (in seconds) each request took.# TYPE coredns_dns_request_duration_seconds histogramcoredns_dns_request_duration_seconds_bucket{server="dns://:53",type="A",zone=".",le="0.00025"} 3coredns_dns_request_duration_seconds_bucket{server="dns://:53",type="A",zone=".",le="0.0005"} 3coredns_dns_request_duration_seconds_bucket{server="dns://:53",type="A",zone=".",le="0.001"} 3coredns_dns_request_duration_seconds_bucket{server="dns://:53",type="A",zone=".",le="0.002"} 4coredns_dns_request_duration_seconds_bucket{server="dns://:53",type="A",zone=".",le="0.004"} 4......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到可以正常访问到，从这里可以看到 CoreDNS 的监控数据接口是正常的了，然后我们就可以将这个 <code>/metrics</code> 接口配置到 <code>prometheus.yml</code> 中去了，直接加到默认的 prometheus 这个 <code>job</code> 下面：prometheus-cm.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">prometheus.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    global:      scrape_interval: 15s      scrape_timeout: 15s</span>    <span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'coredns'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'192.168.235.243:9153'</span><span class="token punctuation">,</span> <span class="token string">'192.168.235.240:9153'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们这里只是一个很简单的配置，<code>scrape_configs</code> 下面可以支持很多参数，例如：</p><ul><li><code>basic_auth</code> 和 <code>bearer_token</code>：比如我们提供的 <code>/metrics</code> 接口需要 basic 认证的时候，通过传统的用户名/密码或者在请求的 header 中添加对应的 token 都可以支持</li><li><code>kubernetes_sd_configs</code> 或 <code>consul_sd_configs</code>：可以用来自动发现一些应用的监控数据</li></ul><p>现在我们重新更新这个 ConfigMap 资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml configmap/prometheus-config configured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在 Prometheus 的配置文件内容已经更改了，隔一会儿被挂载到 Pod 中的 prometheus.yml 文件也会更新，由于我们之前的 Prometheus 启动参数中添加了 <code>--web.enable-lifecycle</code> 参数，所以现在我们只需要执行一个 <code>reload</code> 命令即可让配置生效：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get pods -n kube-mon -o wideNAME                          READY   STATUS    RESTARTS   AGE   IP                NODE        NOMINATED NODE   READINESS GATESprometheus-75d4666dcd-vlth8   1/1     Running   0          28m   192.168.169.155   k8s-node2   &lt;none&gt;           &lt;none&gt;[root@k8s-master prometheus]# curl -X POST "http://192.168.169.155:9090/-/reload"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>热更新</strong></p><p>由于 ConfigMap 通过 Volume 的形式挂载到 Pod 中去的热更新需要一定的间隔时间才会生效，所以需要稍微等一小会儿。</p></blockquote><p>reload 这个 url 是一个 POST 请求，所以这里我们通过 service 的 CLUSTER-IP:PORT 就可以访问到这个重载的接口，这个时候我们再去看 Prometheus 的 Dashboard 中查看采集的目标数据： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902221421.png"></p><p>可以看到我们刚刚添加的 coredns 这个任务已经出现了，然后同样的我们可以切换到 Graph 下面去，我们可以找到一些 CoreDNS 的指标数据，至于这些指标数据代表什么意义，一般情况下，我们可以去查看对应的 <code>/metrics</code> 接口，里面一般情况下都会有对应的注释。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902221611.png"></p><p>到这里我们就在 Prometheus 上配置了第一个 Kubernetes 应用。</p><h2 id="使用-exporter-监控应用"><a href="#使用-exporter-监控应用" class="headerlink" title="使用 exporter 监控应用"></a>使用 exporter 监控应用</h2><p>有一些应用可能没有自带 <code>/metrics</code> 接口供 Prometheus 使用，在这种情况下，我们就需要利用 <code>exporter</code> 服务来为 Prometheus 提供指标数据了。Prometheus 官方为许多应用就提供了对应的 <code>exporter</code> 应用，也有许多第三方的实现，我们可以前往官方网站进行查看：<a href="https://prometheus.io/docs/instrumenting/exporters/">exporters</a>，当然如果你的应用本身也没有 exporter 实现，那么就要我们自己想办法去实现一个 <code>/metrics</code> 接口了，只要你能提供一个合法的 <code>/metrics</code> 接口，Prometheus 就可以监控你的应用。</p><p>比如我们这里通过一个 <a href="https://github.com/oliver006/redis_exporter">redis-exporter</a> 的服务来监控 redis 服务，对于这类应用，我们一般会以 <code>sidecar</code> 的形式和主应用部署在同一个 Pod 中，比如我们这里来部署一个 redis 应用，并用 redis-exporter 的方式来采集监控数据供 Prometheus 使用，如下资源清单文件：prometheus-redis.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">annotations</span><span class="token punctuation">:</span>        <span class="token key atrule">prometheus.io/scrape</span><span class="token punctuation">:</span> <span class="token string">"true"</span>        <span class="token key atrule">prometheus.io/port</span><span class="token punctuation">:</span> <span class="token string">"9121"</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> redis    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis        <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span><span class="token number">4</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 100Mi        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>exporter        <span class="token key atrule">image</span><span class="token punctuation">:</span> oliver006/redis_exporter<span class="token punctuation">:</span>latest        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 100Mi        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9121</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> prom    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9121</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9121</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到上面我们在 redis 这个 Pod 中包含了两个容器，一个就是 redis 本身的主应用，另外一个容器就是 redis_exporter。现在直接创建上面的应用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-redis.yaml deployment.apps/redis createdservice/redis created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建完成后，我们可以看到 redis 的 Pod 里面包含有两个容器：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl get pods -n kube-monNAME                          READY   STATUS    RESTARTS   AGEprometheus-75d4666dcd-vlth8   1/1     Running   0          39mredis-6468bf6c84-qmm2k        2/2     Running   0          45s[root@k8s-master prometheus]# kubectl get svc -n kube-monNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGEprometheus   NodePort    10.96.146.110   &lt;none&gt;        9090:32640/TCP      35mredis        ClusterIP   10.96.143.235   &lt;none&gt;        6379/TCP,9121/TCP   66s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过 9121 端口来校验是否能够采集到数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# curl 10.96.143.235:9121/metrics# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.# TYPE go_gc_duration_seconds summarygo_gc_duration_seconds{quantile="0"} 0go_gc_duration_seconds{quantile="0.25"} 0go_gc_duration_seconds{quantile="0.5"} 0go_gc_duration_seconds{quantile="0.75"} 0go_gc_duration_seconds{quantile="1"} 0go_gc_duration_seconds_sum 0go_gc_duration_seconds_count 0......# HELP redis_up Information about the Redis instance# TYPE redis_up gaugeredis_up 1# HELP redis_uptime_in_seconds uptime_in_seconds metric# TYPE redis_uptime_in_seconds gaugeredis_uptime_in_seconds 70<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，现在我们只需要更新 Prometheus 的配置文件：prometheus-cm.yaml </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">prometheus.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    global:      scrape_interval: 15s      scrape_timeout: 15s</span>    <span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'coredns'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'192.168.235.243:9153'</span><span class="token punctuation">,</span> <span class="token string">'192.168.235.240:9153'</span><span class="token punctuation">]</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'redis'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'redis:9121'</span><span class="token punctuation">]</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们这里是通过 Service 去配置的 redis 服务，当然直接配置 Pod IP 也是可以的，因为和 Prometheus 处于同一个 namespace，所以我们直接使用 servicename 即可。配置文件更新后，重新加载：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yaml configmap/prometheus-config configured# 隔一会儿执行reload操作[root@k8s-master prometheus]# kubectl get svc -n kube-monNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGEprometheus   NodePort    10.96.146.110   &lt;none&gt;        9090:32640/TCP      40mredis        ClusterIP   10.96.143.235   &lt;none&gt;        6379/TCP,9121/TCP   5m34s[root@k8s-master prometheus]# curl -X POST "http://10.96.146.110:9090/-/reload"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候我们再去看 Prometheus 的 Dashboard 中查看采集的目标数据： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902222816.png"></p><p>可以看到配置的 redis 这个 job 已经生效了。切换到 Graph 下面可以看到很多关于 redis 的指标数据：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902222955.png"></p><p>我们选择任意一个指标，比如<code>redis_exporter_scrapes_total</code>，然后点击执行就可以看到对应的数据图表了： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902223203.png"></p><blockquote><p><strong>Note</strong></p><p>如果时间有问题，我们需要手动在 Graph 下面调整下时间</p></blockquote><p> prometheus-cm.yaml  内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">prometheus.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    global:      scrape_interval: 15s      scrape_timeout: 15s</span>    <span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'coredns'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'192.168.235.243:9153'</span><span class="token punctuation">,</span> <span class="token string">'192.168.235.240:9153'</span><span class="token punctuation">]</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'redis'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'redis:9121'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/53.%E7%9B%91%E6%8E%A7Kubernetes%E9%9B%86%E7%BE%A4%E5%BA%94%E7%94%A8.html">https://www.qikqiak.com/k8s-book/docs/53.%E7%9B%91%E6%8E%A7Kubernetes%E9%9B%86%E7%BE%A4%E5%BA%94%E7%94%A8.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 中手动安装 Prometheus</title>
      <link href="/2022/09/04/kubernetes-zhong-shou-dong-an-zhuang-prometheus/"/>
      <url>/2022/09/04/kubernetes-zhong-shou-dong-an-zhuang-prometheus/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-中手动安装-Prometheus"><a href="#Kubernetes-中手动安装-Prometheus" class="headerlink" title="Kubernetes 中手动安装 Prometheus"></a>Kubernetes 中手动安装 Prometheus</h1><p>我们知道监控是保证系统运行必不可少的功能，特别是对于 Kubernetes 这种比较庞大的系统来说，监控报警更是不可或缺，我们需要时刻了解系统的各种运行指标，也需要时刻了解我们的 Pod 的各种指标，更需要在出现问题的时候有报警信息通知到我们。</p><p>在早期的版本中 Kubernetes 提供了 heapster、influxDB、grafana 的组合来监控系统，在现在的版本中已经移除掉了 heapster，现在更加流行的监控工具是 <a href="https://prometheus.io/">Prometheus</a>，Prometheus 是 Google 内部监控报警系统的开源版本，是 Google SRE 思想在其内部不断完善的产物，它的存在是为了更快和高效的发现问题，快速的接入速度，简单灵活的配置都很好的解决了这一切，而且是已经毕业的 CNCF 项目。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Prometheus 最初是 SoundCloud 构建的开源系统监控和报警工具，是一个独立的开源项目，于2016年加入了 CNCF 基金会，作为继 Kubernetes 之后的第二个托管项目。Prometheus 相比于其他传统监控工具主要有以下几个特点：</p><ul><li>具有由 metric 名称和键/值对标识的时间序列数据的多维数据模型</li><li>有一个灵活的查询语言</li><li>不依赖分布式存储，只和本地磁盘有关</li><li>通过 HTTP 的服务拉取时间序列数据</li><li>也支持推送的方式来添加时间序列数据</li><li>还支持通过服务发现或静态配置发现目标</li><li>多种图形和仪表板支持</li></ul><p>Prometheus 由多个组件组成，但是其中有些组件是可选的：</p><ul><li><code>Prometheus Server</code>：用于抓取指标、存储时间序列数据</li><li><code>exporter</code>：暴露指标让任务来抓</li><li><code>pushgateway</code>：push 的方式将指标数据推送到该网关</li><li><code>alertmanager</code>：处理报警的报警组件 <code>adhoc</code>：用于数据查询</li></ul><p>大多数 Prometheus 组件都是用 Go 编写的，因此很容易构建和部署为静态的二进制文件。下图是 Prometheus 官方提供的架构及其一些相关的生态系统组件：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-prometheus-architecture.png"></p><p>整体流程比较简单，Prometheus 直接接收或者通过中间的 Pushgateway 网关被动获取指标数据，在本地存储所有的获取的指标数据，并对这些数据进行一些规则整理，用来生成一些聚合数据或者报警信息，Grafana 或者其他工具用来可视化这些数据。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于 Prometheus 是 Golang 编写的程序，所以要安装的话也非常简单，只需要将二进制文件下载下来直接执行即可，前往地址：<a href="https://prometheus.io/download">https://prometheus.io/download</a> 下载最新版本即可。</p><p>Prometheus 是通过一个 YAML 配置文件来进行启动的，如果我们使用二进制的方式来启动的话，可以使用下面的命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ./prometheus --config.file=prometheus.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>prometheus.yml</code> 文件的基本配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span>     15s  <span class="token key atrule">evaluation_interval</span><span class="token punctuation">:</span> 15s<span class="token key atrule">rule_files</span><span class="token punctuation">:</span>  <span class="token comment"># - "first.rules"</span>  <span class="token comment"># - "second.rules"</span><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> prometheus <span class="token comment">#监控 prometheus 本身</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个配置文件中包含了3个模块：<code>global</code>、<code>rule_files</code> 和 <code>scrape_configs</code>。</p><ul><li><code>global</code> 模块控制 <code>Prometheus Server</code> 的全局配置：<ul><li><code>scrape_interval</code>：表示 prometheus 抓取指标数据的频率，默认是15s，我们可以覆盖这个值</li><li><code>evaluation_interval</code>：用来控制评估规则的频率，prometheus 使用规则产生新的时间序列数据或者产生警报</li></ul></li><li><code>rule_files</code>：指定了报警规则所在的位置，prometheus 可以根据这个配置加载规则，用于生成新的时间序列数据或者报警信息，当前我们没有配置任何报警规则。</li><li><code>scrape_configs</code> 用于控制 prometheus 监控哪些资源。</li></ul><p>由于 prometheus 通过 HTTP 的方式来暴露的它本身的监控数据，prometheus 也能够监控本身的健康情况。在默认的配置里有一个单独的 job，叫做 prometheus，它采集 prometheus 服务本身的时间序列数据。这个 job 包含了一个单独的、静态配置的目标：监听 localhost 上的 9090 端口。prometheus 默认会通过目标的 <code>/metrics</code> 路径采集 metrics。所以，默认的 job 通过 URL：<code>http://localhost:9090/metrics</code> 采集 metrics。收集到的时间序列包含 prometheus 服务本身的状态和性能。如果我们还有其他的资源需要监控的话，直接配置在 <code>scrape_configs</code> 模块下面就可以了。</p><p>由于我们这里是要运行在 Kubernetes 系统中，所以我们直接用 Docker 镜像的方式运行。</p><blockquote><p><strong>Note</strong></p><p>为了方便管理，我们将监控相关的所有资源对象都安装在 <code>kube-mon</code> 这个 namespace 下面，没有的话可以提前创建。</p></blockquote><p>创建 <code>kube-mon</code> 命令空间</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create namespace kube-monnamespace/kube-mon created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>把用到的资源文件统一放到 <code>prometheus</code> 目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir ~/prometheus &amp;&amp; cd prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了能够方便的管理配置文件，我们这里将 <code>prometheus.yml</code> 文件用 ConfigMap 的形式进行管理：prometheus-cm.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">prometheus.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    global:      scrape_interval: 15s      scrape_timeout: 15s    scrape_configs:    - job_name: 'prometheus'      static_configs:      - targets: ['localhost:9090']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们这里暂时只配置了对 prometheus 本身的监控，直接创建该资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl apply -f prometheus-cm.yamlconfigmap/prometheus-config created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置文件创建完成了，以后如果我们有新的资源需要被监控，我们只需要将上面的 ConfigMap 对象更新即可。现在我们来创建 prometheus 的 Pod 资源：prometheus-deploy.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> prometheus<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> prometheus  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> prometheus    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> prometheus      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> prom/prometheus<span class="token punctuation">:</span>v2.4.3        <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"/bin/prometheus"</span>        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"--config.file=/etc/prometheus/prometheus.yml"</span>        <span class="token punctuation">-</span> <span class="token string">"--storage.tsdb.path=/prometheus"</span>        <span class="token punctuation">-</span> <span class="token string">"--storage.tsdb.retention=24h"</span>        <span class="token punctuation">-</span> <span class="token string">"--web.enable-admin-api"</span>  <span class="token comment"># 控制对admin HTTP API的访问，其中包括删除时间序列等功能</span>        <span class="token punctuation">-</span> <span class="token string">"--web.enable-lifecycle"</span>  <span class="token comment"># 支持热更新，直接执行localhost:9090/-/reload立即生效</span>        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9090</span>          <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP          <span class="token key atrule">name</span><span class="token punctuation">:</span> http        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/prometheus"</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> data          <span class="token key atrule">subPath</span><span class="token punctuation">:</span> prometheus        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/prometheus"</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 512Mi          <span class="token key atrule">limits</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 512Mi      <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>        <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data        <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>          <span class="token key atrule">claimName</span><span class="token punctuation">:</span> prometheus      <span class="token punctuation">-</span> <span class="token key atrule">configMap</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>config        <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在启动程序的时候，除了指定了 prometheus.yml 文件之外，还通过参数<code>storage.tsdb.path</code>指定了 TSDB 数据的存储路径、通过<code>storage.tsdb.retention</code>设置了保留多长时间的数据，还有下面的<code>web.enable-admin-api</code>参数可以用来开启对 admin api 的访问权限，参数<code>web.enable-lifecycle</code>非常重要，用来开启支持热更新的，有了这个参数之后，prometheus.yml 配置文件只要更新了，通过执行<code>localhost:9090/-/reload</code>就会立即生效，所以一定要加上这个参数。</p><p>我们这里将 prometheus.yml 文件对应的 ConfigMap 对象通过 volume 的形式挂载进了 Pod，这样 ConfigMap 更新后，对应的 Pod 里面的文件也会热更新的，然后我们再执行上面的 reload 请求，Prometheus 配置就生效了，除此之外，为了将时间序列数据进行持久化，我们将数据目录和一个 pvc 对象进行了绑定，所以我们需要提前创建好这个 pvc 对象：prometheus-volume.yaml</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apiVersion: v1kind: PersistentVolumemetadata:  name: prometheusspec:  capacity:    storage: 10Gi  accessModes:  - ReadWriteOnce  persistentVolumeReclaimPolicy: Recycle  nfs:    server: 172.31.0.2 # NFS 服务器地址    path: /nfs/data/ # NFS 服务器共享的目录---apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: prometheus  namespace: kube-monspec:  accessModes:  - ReadWriteOnce  resources:    requests:      storage: 10Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们这里简单的通过 NFS 作为存储后端创建一个 pv、pvc 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl create -f prometheus-volume.yamlpersistentvolume/prometheus createdpersistentvolumeclaim/prometheus created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>除了上面的注意事项外，我们这里还需要配置 rbac 认证，因为我们需要在 prometheus 中去访问 Kubernetes 的相关信息，所以我们这里管理了一个名为 prometheus 的 serviceAccount 对象：prometheus-rbac.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">""</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> nodes  <span class="token punctuation">-</span> services  <span class="token punctuation">-</span> endpoints  <span class="token punctuation">-</span> pods  <span class="token punctuation">-</span> nodes/proxy  <span class="token key atrule">verbs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> get  <span class="token punctuation">-</span> list  <span class="token punctuation">-</span> watch<span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">""</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> configmaps  <span class="token punctuation">-</span> nodes/metrics  <span class="token key atrule">verbs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> get<span class="token punctuation">-</span> <span class="token key atrule">nonResourceURLs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> /metrics  <span class="token key atrule">verbs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> get<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们要获取的资源信息，在每一个 namespace 下面都有可能存在，所以我们这里使用的是 ClusterRole 的资源对象，值得一提的是我们这里的权限规则声明中有一个<code>nonResourceURLs</code>的属性，是用来对非资源型 metrics 进行操作的权限声明，这个在以前我们很少遇到过，然后直接创建上面的资源对象即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl create -f prometheus-rbac.yamlserviceaccount/prometheus createdclusterrole.rbac.authorization.k8s.io/prometheus createdWarning: rbac.authorization.k8s.io/v1beta1 ClusterRoleBinding is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRoleBindingclusterrolebinding.rbac.authorization.k8s.io/prometheus created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一个要注意的地方是我们这里必须要添加一个<code>securityContext</code>的属性，将其中的<code>runAsUser</code>设置为0，这是因为现在的 prometheus 运行过程中使用的用户是 <a href="https://github.com/prometheus/prometheus/blob/master/Dockerfile">nobody</a>，否则会出现下面的<code>permission denied</code>之类的权限错误。</p><p>现在我们就可以添加 promethues 的资源对象了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl create -f prometheus-deploy.yamldeployment.apps/prometheus created[root@k8s-master prometheus]# kubectl get pods -n kube-mon NAME                          READY   STATUS    RESTARTS   AGEprometheus-75d4666dcd-vlth8   1/1     Running   0          3m38s[root@k8s-master prometheus]# kubectl logs -f prometheus-75d4666dcd-vlth8 -n kube-monlevel=info ts=2022-09-02T13:41:33.137073775Z caller=main.go:238 msg="Starting Prometheus" version="(version=2.4.3, branch=HEAD, revision=167a4b4e73a8eca8df648d2d2043e21bdb9a7449)"level=info ts=2022-09-02T13:41:33.137157695Z caller=main.go:239 build_context="(go=go1.11.1, user=root@1e42b46043e9, date=20181004-08:42:02)"level=info ts=2022-09-02T13:41:33.137180961Z caller=main.go:240 host_details="(Linux 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 prometheus-75d4666dcd-vlth8 (none))"level=info ts=2022-09-02T13:41:33.137203896Z caller=main.go:241 fd_limits="(soft=1048576, hard=1048576)"level=info ts=2022-09-02T13:41:33.137225997Z caller=main.go:242 vm_limits="(soft=unlimited, hard=unlimited)"level=info ts=2022-09-02T13:41:33.138994196Z caller=main.go:554 msg="Starting TSDB ..."level=info ts=2022-09-02T13:41:33.139043277Z caller=web.go:397 component=web msg="Start listening for connections" address=0.0.0.0:9090level=info ts=2022-09-02T13:41:33.238333358Z caller=main.go:564 msg="TSDB started"level=info ts=2022-09-02T13:41:33.238387474Z caller=main.go:624 msg="Loading configuration file" filename=/etc/prometheus/prometheus.ymllevel=info ts=2022-09-02T13:41:33.238746418Z caller=main.go:650 msg="Completed loading of configuration file" filename=/etc/prometheus/prometheus.ymllevel=info ts=2022-09-02T13:41:33.238766573Z caller=main.go:523 msg="Server is ready to receive web requests."<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Pod 创建成功后，为了能够在外部访问到 prometheus 的 webui 服务，我们还需要创建一个 Service 对象：prometheus-svc.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> prometheus<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> prometheus  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> web      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9090</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> http<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便测试，我们这里创建一个<code>NodePort</code>类型的服务，当然我们可以创建一个<code>Ingress</code>对象，通过域名来进行访问：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# kubectl create -f prometheus-svc.yamlservice/prometheus created[root@k8s-master prometheus]# kubectl get svc -n kube-monNAME         TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGEprometheus   NodePort   10.96.146.110   &lt;none&gt;        9090:32640/TCP   7s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们就可以通过<strong>http://任意节点IP:32640</strong>访问 prometheus 的 webui 服务了。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-prometheus-1.png">现在我们可以查看当前监控系统中的一些监控目标（Status -&gt; Targets)：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902215337.png"></p><p>由于我们现在还没有配置任何的报警信息，所以 Alerts 菜单下面现在没有任何数据，隔一会儿，我们可以去 Graph 菜单下面查看我们抓取的 prometheus 本身的一些监控数据了，其中<code>- insert metrics at cursor -</code>下面就是我们搜集到的一些监控数据指标： </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902215627.png"></p><p>比如我们这里就选择<code>scrape_duration_seconds</code>这个指标，然后点击<code>Execute</code>，如果这个时候没有查询到任何数据，我们可以切换到<code>Graph</code>这个 tab 下面重新选择下时间，选择到当前的时间点，重新执行，就可以看到类似于下面的图表数据了：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220902215736.png"></p><p>除了简单的直接使用采集到的一些监控指标数据之外，这个时候也可以使用强大的 <code>PromQL</code> 工具，<code>PromQL</code> 其实就是 prometheus 便于数据聚合展示开发的一套 <code>ad hoc</code> 查询语言的，你想要查什么找对应函数取你的数据好了。</p><p>所用到的资源文件如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master prometheus]# tree.├── prometheus-cm.yaml├── prometheus-deploy.yaml├── prometheus-rbac.yaml├── prometheus-svc.yaml└── prometheus-volume.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> prometheus-cm.yaml  内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>mon<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">prometheus.yml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    global:      scrape_interval: 15s      scrape_timeout: 15s</span>    <span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>      <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/52.Prometheus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html">https://www.qikqiak.com/k8s-book/docs/52.Prometheus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Helm 模板之内置函数和Values</title>
      <link href="/2022/09/01/kubernetes-helm-mo-ban-zhi-nei-zhi-han-shu-he-values/"/>
      <url>/2022/09/01/kubernetes-helm-mo-ban-zhi-nei-zhi-han-shu-he-values/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Helm-模板之内置函数和Values"><a href="#Kubernetes-Helm-模板之内置函数和Values" class="headerlink" title="Kubernetes Helm 模板之内置函数和Values"></a>Kubernetes Helm 模板之内置函数和Values</h1><p>Helm 使用一种名为 charts 的包格式，一个 chart 是描述一组相关的 Kubernetes 资源的文件集合，单个 chart 可能用于部署简单的应用，比如 memcached pod，或者复杂的应用，比如一个带有 HTTP 服务、数据库、缓存等等功能的完整 web 应用程序。</p><p>Charts 是创建在特定目录下面的文件集合，然后可以将它们打包到一个版本化的存档中来部署。接下来我们就来看看使用 Helm 构建 charts 的一些基本方法。</p><h2 id="Chart-基本概念和使用"><a href="#Chart-基本概念和使用" class="headerlink" title="Chart 基本概念和使用"></a>Chart 基本概念和使用</h2><p>参考官方文档：<a href="https://helm.sh/zh/docs/topics/charts/">https://helm.sh/zh/docs/topics/charts/</a></p><h2 id="Chart-模板编写"><a href="#Chart-模板编写" class="headerlink" title="Chart 模板编写"></a>Chart 模板编写</h2><p>参考官方文档：<a href="https://helm.sh/zh/docs/chart_template_guide/">https://helm.sh/zh/docs/chart_template_guide/</a></p><h2 id="Chart-Hooks"><a href="#Chart-Hooks" class="headerlink" title="Chart Hooks"></a>Chart Hooks</h2><p>参考官方文档：<a href="https://helm.sh/zh/docs/topics/charts_hooks/">https://helm.sh/zh/docs/topics/charts_hooks/</a></p><h2 id="内置函数和Values"><a href="#内置函数和Values" class="headerlink" title="内置函数和Values"></a>内置函数和Values</h2><h3 id="创建第一个Helm-chart"><a href="#创建第一个Helm-chart" class="headerlink" title="创建第一个Helm chart"></a>创建第一个Helm chart</h3><p>创建一个 mychart 包，参考：<a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/">https://helm.sh/zh/docs/chart_template_guide/getting_started/</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/$ mkdir -p helm/charts &amp;&amp; cd helm/charts# zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm/charts [18:47:22] $ helm create mychartCreating mychart# zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm/charts [18:48:48] $ tree mychart mychart├── Chart.yaml├── charts├── templates│&nbsp;&nbsp; ├── NOTES.txt│&nbsp;&nbsp; ├── _helpers.tpl│&nbsp;&nbsp; ├── deployment.yaml│&nbsp;&nbsp; ├── hpa.yaml│&nbsp;&nbsp; ├── ingress.yaml│&nbsp;&nbsp; ├── service.yaml│&nbsp;&nbsp; ├── serviceaccount.yaml│&nbsp;&nbsp; └── tests│&nbsp;&nbsp;     └── test-connection.yaml└── values.yaml3 directories, 10 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把 templates 目录下面所有文件全部删除掉，这里我们自己来创建模板文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm/charts [19:25:33] $ rm -rf mychart/templates/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h3><p>这里我们来创建一个非常简单的模板 ConfigMap，在 templates 目录下面新建一个<code>configmap.yaml</code>文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm/charts [19:25:41] </span>$ vi mychart/templates/configmap.yaml<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mychart<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上现在我们就有一个可安装的 chart 包了，通过<code>helm install</code>命令来进行安装：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm install ./mychart --generate-nameNAME: mychart-1662020439LAST DEPLOYED: Thu Sep  1 16:20:41 2022NAMESPACE: defaultSTATUS: deployedREVISION: 1TEST SUITE: None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的输出中，我们可以看到我们的 ConfigMap 资源对象已经创建了。然后使用如下命令我们可以看到实际的模板被渲染过后的资源文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm/charts [16:20:41] $ helm get  manifest mychart-1662020439 ---# Source: mychart/templates/configmap.yamlapiVersion: v1kind: ConfigMapmetadata:  name: mychart-configmapdata:  myvalue: "Hello World"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们看到上面的 ConfigMap 文件是不是正是我们前面在模板文件中设计的，现在我们删除当前的<code>release</code>:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm lsNAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSIONclunky-serval           default         1               2022-08-30 19:47:55.604474 +0800 CST    deployed        mychart-0.1.0   1.16.0     mychart-1661867411      default         1               2022-08-30 21:50:13.801393 +0800 CST    deployed        mychart-0.1.0   1.16.0     mychart-1662020439      default         1               2022-09-01 16:20:41.481324 +0800 CST    deployed        mychart-0.1.0   1.16.0     rude-cardinal           default         1               2022-08-30 21:26:33.926513 +0800 CST    deployed        mychart-0.1.0   1.16.0  $ helm uninstall mychart-1662020439release "mychart-1662020439" uninstalled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加一个简单的模板"><a href="#添加一个简单的模板" class="headerlink" title="添加一个简单的模板"></a>添加一个简单的模板</h3><p>我们可以看到上面我们定义的 ConfigMap 的名字是固定的，但往往这并不是一种很好的做法，我们可以通过插入 release 的名称来生成资源的名称，比如这里 ConfigMap 的名称我们希望是：zq-configmap，这就需要用到 Chart 的模板定义方法了。</p><p>Helm Chart 模板使用的是<a href="https://pkg.go.dev/text/template"><code>Go</code>语言模板</a>编写而成，并添加了<a href="https://masterminds.github.io/sprig/"><code>Sprig</code>库</a>中的50多个附件模板函数。</p><p>现在我们来重新定义下上面的 configmap.yaml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们将名称替换成了<code>{{ .Release.Name }}-configmap</code>，其中包含在<code>{{`和`}}</code>之中的就是模板指令，<code>{{ .Release.Name }}</code> 将 release 的名称注入到模板中来，这样最终生成的 ConfigMap 名称就是以 release 的名称开头的了。这里的 Release 模板对象属于 Helm 内置的一种对象，还有其他很多内置的对象，稍后我们将接触到。</p><p>现在我们来重新安装我们的 Chart 包，注意观察 ConfigMap 资源对象的名称：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm/charts [16:21:53] $ helm install ./mychart --generate-nameNAME: mychart-1662020625LAST DEPLOYED: Thu Sep  1 16:23:47 2022NAMESPACE: defaultSTATUS: deployedREVISION: 1TEST SUITE: None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到现在生成的名称变成了<strong>mychart-1662020625</strong>，证明已经生效了，当然我们也可以使用命令<code>helm get manifest mychart-1662020625</code>查看最终生成的清单文件的样子。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm get manifest  mychart-1662020625---# Source: mychart/templates/configmap.yamlapiVersion: v1kind: ConfigMapmetadata:  name: mychart-1662020625-configmapdata:  myvalue: "Hello World"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>我们用模板来生成资源文件的清单，但是如果我们想要调试就非常不方便了，不可能我们每次都去部署一个<code>release</code>实例来校验模板是否正确，所幸的时 Helm 为我们提供了<code>--dry-run --debug</code>这个可选参数，在执行<code>helm install</code>的时候带上这两个参数就可以把对应的 values 值和生成的最终的资源清单文件打印出来，而不会真正的去部署一个<code>release</code>实例，比如我们来调试上面创建的 chart 包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm/charts [16:25:52] $ helm install --dry-run --debug --generate-name ./mychart                 install.go:178: [debug] Original chart version: ""install.go:199: [debug] CHART PATH: /Users/zhangquan/code/github.com/k8s-app/helm/charts/mychartNAME: mychart-1662020797LAST DEPLOYED: Thu Sep  1 16:26:39 2022NAMESPACE: defaultSTATUS: pending-installREVISION: 1TEST SUITE: NoneUSER-SUPPLIED VALUES:{}COMPUTED VALUES:......HOOKS:MANIFEST:---# Source: mychart/templates/configmap.yamlapiVersion: v1kind: ConfigMapmetadata:  name: mychart-1662020797-configmapdata:  myvalue: "Hello World"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们使用<code>--dry-run</code>就可以很容易地测试代码了，不需要每次都去安装一个 release 实例了，但是要注意的是这不能确保 Kubernetes 本身就一定会接受生成的模板，在调试完成后，还是需要去安装一个实际的 release 实例来进行验证的。</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>参考官方文档：<a href="https://helm.sh/zh/docs/chart_template_guide/builtin_objects/">https://helm.sh/zh/docs/chart_template_guide/builtin_objects/</a></p><h3 id="values-文件"><a href="#values-文件" class="headerlink" title="values 文件"></a>values 文件</h3><p>参考官方文档：<a href="https://helm.sh/zh/docs/chart_template_guide/values_files/">https://helm.sh/zh/docs/chart_template_guide/values_files/</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 包管理工具 Helm</title>
      <link href="/2022/08/31/kubernetes-bao-guan-li-gong-ju-helm/"/>
      <url>/2022/08/31/kubernetes-bao-guan-li-gong-ju-helm/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-包管理工具-Helm"><a href="#Kubernetes-包管理工具-Helm" class="headerlink" title="Kubernetes 包管理工具 Helm"></a>Kubernetes 包管理工具 Helm</h1><h2 id="为什么需要-Helm"><a href="#为什么需要-Helm" class="headerlink" title="为什么需要 Helm"></a>为什么需要 Helm</h2><p>Kubernetes 中一个重要的设计理念就是，声明式的操作。用户通过设置系统的预期状态来改变系统。例如，现在的副本数量是 2 ，需要调整为 3。声明式的处理方式是，修改配置文件中副本数量为 3 ；命令式的处理方式是，发送增加一个副本的命令，+1。</p><p>使用申明式配置的系统更关注结果，对系统设计要求更高。在分布式系统中，任何组件都不是 100 % 可靠的，对使用者来说，声明式配置的系统更加友好。</p><p>Kubernetes 采用 yaml 作为配置文件。在 Kubernetes 中部署一个简单的 Jenkins 服务，就得写两个 yaml 文件: jenkins-deployment.yaml 和 jenkins-service.yaml。再加上其他服务，考虑到多套环境，需要维护的 yaml 文件数量会很大。</p><p>直接维护 yaml，进行部署 ，既不利于项目组织，也不利于维护更新。我们需要一个工具简化应用部署和管理流程。</p><h2 id="什么是Helm"><a href="#什么是Helm" class="headerlink" title="什么是Helm"></a>什么是Helm</h2><p>Helm 是 Deis 发起的一个 Kubernetes 包管理器，类似于 Linux 中的 apt 和 yum 工具。Deis 公司已经被微软收购。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>对于Helm，有几个重要的概念：</p><ul><li><p>Chart： Helm的软件包， 内部包含了一组相关的kubernetes资源的yaml文件。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-helm-1.png"></p></li><li><p>Repoistory：: Helm的软件仓库，repository本质上是一个web服务器，该服务器保存了chart软件包以供下载，并有提供一个该repository的chart包的清单文件以供查询。在使用时，Helm可以对接多个不同的Repository。 其中Artifact Hub 是helm 的官方chart 仓库——helm 弃用了自己的hub，迁移到了Artifact Hub。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-helm-2.png"></p></li><li><p>Release：使用Helm install命令在Kubernetes集群中安装的Chart称为Release。一个chart可以部署成多个release，例如使用同一个wordpress chart部署多套release。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-helm-3.png"></p></li><li><p>Revision：每个Release会有不同的版本，在Revision中按数字递增保存了每个版本的信息。</p></li></ul><p>上面的所有组件一起按如下方式工作：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-helm-4.png"></p><h3 id="Helm提供的功能"><a href="#Helm提供的功能" class="headerlink" title="Helm提供的功能"></a>Helm提供的功能</h3><p>做为 Kubernetes 的一个包管理工具，<code>Helm</code>具有如下功能：</p><ul><li>创建新的 chart</li><li>chart 打包成 tgz 格式</li><li>上传 chart 到 chart 仓库或从仓库中下载 chart</li><li>在<code>Kubernetes</code>集群中安装或卸载 chart</li><li>管理用<code>Helm</code>安装的 chart 的发布周期</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考：<a href="https://helm.sh/docs/intro/install/">https://helm.sh/docs/intro/install/</a> ，不同平台(windows, linux, mac)的安装方式不一样</p><p>注意：<a href="https://helm.sh/docs/topics/version_skew/">Helm和Kubernetes版本之间的兼容性</a></p><p>首先当然需要一个可用的 Kubernetes 集群，然后在我们使用 Helm 的节点上已经配置好可以通过 kubectl 访问集群，因为 Helm 其实就是读取的 kubeconfig 文件来访问集群的。</p><p>由于 Helm V2 版本必须在 Kubernetes 集群中安装一个 Tiller 服务进行通信，这样大大降低了其安全性和可用性，所以在 V3 版本中移除了服务端，采用了通用的 Kubernetes CRD 资源来进行管理，这样就只需要连接上 Kubernetes 即可，而且 V3 版本已经发布了稳定版，所以我们这里来安装最新的 v3.7.1 版本，软件包下载地址为：<a href="https://get.helm.sh/helm-v3.7.1-darwin-amd64.tar.gz%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%8C%85%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E8%BF%99%E9%87%8C%E6%98%AF">https://get.helm.sh/helm-v3.7.1-darwin-amd64.tar.gz，我们可以根据自己的节点选择合适的包，比如我这里是</a> Mac，就下载 <a href="https://get.helm.sh/helm-v3.7.1-darwin-amd64.tar.gz">MacOS amd64</a> 的版本。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~ [17:29:54] $ kubectl get nodesNAME             STATUS   ROLES    AGE   VERSIONdocker-desktop   Ready    master   20d   v1.15.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下载到本地解压后，将 helm 二进制包文件移动到任意的 PATH 路径下即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/Downloads/darwin-amd64 [13:21:28] $ lltotal 99104-rw-r--r--@ 1 zhangquan  180847186    11K 10 14  2021 LICENSE-rw-r--r--@ 1 zhangquan  180847186   3.3K 10 14  2021 README.md-rwxr-xr-x@ 1 zhangquan  180847186    48M 10 14  2021 helm# zhangquan @ MacBook-Pro in ~/Downloads/darwin-amd64 [13:53:19] $ mv helm /usr/local/bin/helm $ helm versionversion.BuildInfo{Version:"v3.7.1", GitCommit:"1d11fcb5d3f3bf00dbe6fe31b8412839a96b3dc4", GitTreeState:"clean", GoVersion:"go1.16.9"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到上面的版本信息证明已经成功了。</p><p>一旦 Helm 客户端准备成功后，我们就可以添加一个 chart 仓库，当然最常用的就是官方的 Helm stable charts 仓库，但是由于官方的 charts 仓库地址需要科学上网，我们可以使用微软的 charts 仓库代替：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm repo add stable http://mirror.azure.cn/kubernetes/charts/"stable" has been added to your repositories$ helm repo list                                                NAME    URL                                      stable  http://mirror.azure.cn/kubernetes/charts/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装完成后可以用 search 命令来搜索可以安装的 chart 包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm search repo stableNAME                                    CHART VERSION   APP VERSION             DESCRIPTION                                       stable/acs-engine-autoscaler            2.2.2           2.1.1                   DEPRECATED Scales worker nodes within agent pools stable/aerospike                        0.3.5           v4.5.0.5                DEPRECATED A Helm chart for Aerospike in Kubern...stable/airflow                          7.13.3          1.10.12                 DEPRECATED - please use: https://github.com/air...stable/ambassador                       5.3.2           0.86.1                  DEPRECATED A Helm chart for Datawire Ambassador   stable/anchore-engine                   1.7.0           0.7.3                   Anchore container analysis and policy evaluatio...stable/apm-server                       2.1.7           7.0.0                   DEPRECATED The server receives data from the El...stable/ark                              4.2.2           0.10.2                  DEPRECATED A Helm chart for ark ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了安装一个 chart 包，我们可以使用 <code>helm install</code> 命令，Helm 有多种方法来找到和安装 chart 包，但是最简单的方法当然是使用官方的 <code>stable</code> 这个仓库直接安装：</p><p>首先从仓库中将可用的 charts 信息同步到本地，可以确保我们获取到最新的 charts 列表：</p><pre class="line-numbers language-none"><code class="language-none">$ helm repo updateHang tight while we grab the latest from your chart repositories......Successfully got an update from the "stable" chart repositoryUpdate Complete. ⎈Happy Helming!⎈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如我们现在安装一个 <code>mysql</code> 应用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm install stable/mysql --generate-nameWARNING: This chart is deprecatedNAME: mysql-1661839473LAST DEPLOYED: Tue Aug 30 14:04:36 2022NAMESPACE: defaultSTATUS: deployedREVISION: 1NOTES:MySQL can be accessed via port 3306 on the following DNS name from within your cluster:mysql-1661839473.default.svc.cluster.local......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到 <code>stable/mysql</code> 这个 chart 已经安装成功了，我们将安装成功的这个应用叫做一个 <code>release</code>，由于我们在安装的时候指定了<code>--generate-name</code> 参数，所以生成的 release 名称是随机生成的，名为 <code>mysql-1661839473</code>。我们可以用下面的命令来查看 release 安装以后对应的 Kubernetes 资源的状态：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl get all -l release=mysql-1661839473NAME                                    READY   STATUS    RESTARTS   AGEpod/mysql-1661839473-7597b94bc5-2lt9c   1/1     Running   0          118sNAME                       TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGEservice/mysql-1661839473   ClusterIP   10.98.24.64   &lt;none&gt;        3306/TCP   118sNAME                               READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/mysql-1661839473   1/1     1            1           118sNAME                                          DESIRED   CURRENT   READY   AGEreplicaset.apps/mysql-1661839473-7597b94bc5   1         1         1       118s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以 <code>helm show chart</code> 命令来了解 MySQL 这个 chart 包的一些特性：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm show chart stable/mysqlapiVersion: v1appVersion: 5.7.30deprecated: truedescription: DEPRECATED - Fast, reliable, scalable, and easy to use open-source relational  database system.home: https://www.mysql.com/icon: https://www.mysql.com/common/logos/logo-mysql-170x115.pngkeywords:- mysql- database- sqlname: mysqlsources:- https://github.com/kubernetes/charts- https://github.com/docker-library/mysqlversion: 1.6.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要了解更多信息，可以用 <code>helm show all</code> 命令：</p><pre class="line-numbers language-none"><code class="language-none">$ helm show all stable/mysql......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是无论什么时候安装 chart，都会创建一个新的 release，所以一个 chart 包是可以多次安装到同一个集群中的，每个都可以独立管理和升级。</p><p>同样我们也可以用 Helm 很容易查看到已经安装的 release：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm ls                        NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSIONmysql-1661839473        default         1               2022-08-30 14:04:36.833439 +0800 CST    deployed        mysql-1.6.9     5.7.30 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果需要删除这个 release，也很简单，只需要使用 <code>helm uninstall</code> 命令即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm uninstall mysql-1661839473  release "mysql-1661839473" uninstalled$ kubectl get all -l release=mysql-1661839473No resources found in default namespace.$ helm status mysql-1661839473Error: release: not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>uninstall</code> 命令会从 Kubernetes 中删除 release，也会删除与 release 相关的所有 Kubernetes 资源以及 release 历史记录。也可以在删除的时候使用 <code>--keep-history</code> 参数，则会保留 release 的历史记录，可以获取该 release 的状态就是 <code>UNINSTALLED</code>，而不是找不到 release了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm uninstall mysql-1661839949 --keep-historyrelease "mysql-1661839949" uninstalled$ helm status mysql-1661839949NAME: mysql-1661839949LAST DEPLOYED: Tue Aug 30 14:12:32 2022NAMESPACE: defaultSTATUS: uninstalled......$ helm ls -aNAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSIONmysql-1661839949        default         1               2022-08-30 14:12:32.764243 +0800 CST    uninstalled     mysql-1.6.9     5.7.30   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 Helm 会在删除 release 后跟踪你的 release，所以你可以审查历史甚至取消删除 <code>release</code>（使用 <code>helm rollback</code> 命令）。</p><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>上面我们都是直接使用的 <code>helm install</code> 命令安装的 chart 包，这种情况下只会使用 chart 的默认配置选项，但是更多的时候，是各种各样的需求，索引我们希望根据自己的需求来定制 chart 包的配置参数。</p><p>我们可以使用 <code>helm show values</code> 命令来查看一个 chart 包的所有可配置的参数选项：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm show values stable/mysql## mysql image version## ref: https://hub.docker.com/r/library/mysql/tags/##image: "mysql"imageTag: "5.7.30"strategy:  type: Recreatebusybox:  image: "busybox"  tag: "1.32"testFramework:  enabled: true  image: "bats/bats"  tag: "1.2.1"  imagePullPolicy: IfNotPresent  securityContext: {}## Specify password for root user#### Default: random 10 character string# mysqlRootPassword: testing## Create a database user### mysqlUser:## Default: random 10 character string# mysqlPassword:## Allow unauthenticated access, uncomment to enable### mysqlAllowEmptyPassword: true## Create a database### mysqlDatabase:## Specify an imagePullPolicy (Required)## It's recommended to change this to 'Always' if the image tag is 'latest'## ref: http://kubernetes.io/docs/user-guide/images/#updating-images##imagePullPolicy: IfNotPresent......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们看到的所有参数都是可以用自己的数据来覆盖的，可以在安装的时候通过 YAML 格式的文件来传递这些参数：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:16:07] </span>$ cat config.yaml <span class="token key atrule">mysqlUser</span><span class="token punctuation">:</span>  user0<span class="token key atrule">mysqlPassword</span><span class="token punctuation">:</span> user0pwd<span class="token key atrule">mysqlDatabase</span><span class="token punctuation">:</span> user0db<span class="token key atrule">persistence</span><span class="token punctuation">:</span>  <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传递配置数据方式安装：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm install -f config.yaml stable/mysql  --generate-nameWARNING: This chart is deprecatedNAME: mysql-1661840339LAST DEPLOYED: Tue Aug 30 14:19:03 2022NAMESPACE: defaultSTATUS: deployedREVISION: 1NOTES:MySQL can be accessed via port 3306 on the following DNS name from within your cluster:mysql-1661840339.default.svc.cluster.local......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>release 安装成功后，可以查看对应的 Pod 信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl get pod -l release=mysql-1661840339NAME                               READY   STATUS    RESTARTS   AGEmysql-1661840339-655bdc759-4d94f   1/1     Running   0          2m25s# zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:21:29] $ kubectl describe pod mysql-1661840339-655bdc759-4d94f......    Environment:      MYSQL_ROOT_PASSWORD:  &lt;set to the key 'mysql-root-password' in secret 'mysql-1661840339'&gt;  Optional: false      MYSQL_PASSWORD:       &lt;set to the key 'mysql-password' in secret 'mysql-1661840339'&gt;       Optional: false      MYSQL_USER:           user0      MYSQL_DATABASE:       user0db......      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到环境变量 <code>MYSQL_USER=user0，MYSQL_DATABASE=user0db</code> 的值和我们上面配置的值是一致的。在安装过程中，有两种方法可以传递配置数据：</p><ul><li><code>--values（或者 -f）</code>：指定一个 YAML 文件来覆盖 values 值，可以指定多个值，最后边的文件优先</li><li><code>--set</code>：在命令行上指定覆盖的配置</li></ul><p>如果同时使用这两个值，<code>--set</code> 将被合并到具有更高优先级的 <code>--values</code>，使用 <code>--set</code> 指定的值将持久化在 ConfigMap 中，对于给定的 release，可以使用 <code>helm get values &lt;release-name&gt;</code> 来查看已经设置的值，已设置的值也通过允许 <code>helm upgrade</code> 并指定 <code>--reset</code> 值来清除。</p><p><code>--set</code> 选项接收零个或多个 name/value 对，最简单的用法就是 <code>--set name=value</code>，相当于 YAML 文件中的：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>多个值之间用字符串“,”隔开，用法就是 <code>--set a=b,c=d</code>，相当于 YAML 文件中的：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a: bc: d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也支持更加复杂的表达式，例如 <code>--set outer.inner=value</code>，对应 YAML：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">outer</span><span class="token punctuation">:</span>  <span class="token key atrule">inner</span><span class="token punctuation">:</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于列表数组可以用 <code>{}</code> 来包裹，比如 <code>--set name={a, b, c}</code>，对应 YAML：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> a <span class="token punctuation">-</span> b <span class="token punctuation">-</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从 Helm 2.5.0 开始，就可以使用数组索引语法来访问列表中某个项，比如 <code>--set servers[0].port=80</code>，对应的 YAML 为：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">servers</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以这样设置多个值，比如 <code>--set servers[0].port=80,servers[0].host=example</code>，对应的 YAML 为：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">servers  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> example<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有时候你可能需要在 <code>--set</code> 选项中使用特殊的字符，这个时候可以使用<strong>反斜杠来转义字符</strong>，比如 <code>--set name=value1\,value2</code>，对应的 YAML 为：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"value1,value2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似的，你还可以转义<code>.</code>，当 chart 模板中使用 <code>toYaml</code> 函数来解析 annotations、labels 以及 node selectors 之类的时候，这非常有用，比如 <code>--set nodeSelector."kubernetes\.io/role"=master</code>，对应的 YAML 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>  <span class="token key atrule">kubernetes.io/role</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>深度嵌套的数据结构可能很难使用 <code>--set</code> 来表示，所以一般推荐还是使用 YAML 文件来进行覆盖，当然在设计 chart 模板的时候也可以结合考虑到 <code>--set</code> 这种用法，尽可能的提供更好的支持。</p><h2 id="更多安装方式"><a href="#更多安装方式" class="headerlink" title="更多安装方式"></a>更多安装方式</h2><p><code>helm install</code> 命令可以从多个源进行安装：</p><ul><li>chart 仓库（类似于上面我们提到的）</li><li>本地 chart 压缩包（helm install foo-0.1.1.tgz）</li><li>本地解压缩的 chart 目录（helm install foo path/to/foo）</li><li>在线的 URL（helm install fool <a href="https://example.com/charts/foo-1.2.3.tgz%EF%BC%89">https://example.com/charts/foo-1.2.3.tgz）</a></li></ul><h2 id="升级和回滚"><a href="#升级和回滚" class="headerlink" title="升级和回滚"></a>升级和回滚</h2><p>当新版本的 chart 包发布的时候，或者当你要更改 release 的配置的时候，你可以使用 <code>helm upgrade</code> 命令来操作。升级需要一个现有的 release，并根据提供的信息对其进行升级。因为 Kubernetes charts 可能很大而且很复杂，Helm 会尝试以最小的侵入性进行升级，它只会更新自上一版本以来发生的变化：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ cat panda.yaml mysqlUser:  user0mysqlPassword: user0pwdmysqlDatabase: user0dbpersistence:  enabled: falsemysqlRootPassword: passw0rd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>升级：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ helm lsNAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSIONmysql-1661840339        default         1               2022-08-30 14:19:03.821832 +0800 CST    deployed        mysql-1.6.9     5.7.30   # zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:30:41] $ helm upgrade -f panda.yaml mysql-1661840339 stable/mysqlWARNING: This chart is deprecatedRelease "mysql-1661840339" has been upgraded. Happy Helming!NAME: mysql-1661840339LAST DEPLOYED: Tue Aug 30 14:31:08 2022NAMESPACE: defaultSTATUS: deployedREVISION: 2NOTES:MySQL can be accessed via port 3306 on the following DNS name from within your cluster:mysql-1661840339.default.svc.cluster.local......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们这里 <code>mysql</code> 这个 release 用相同的 chart 包进行升级，但是新增了一个配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mysqlRootPassword</span><span class="token punctuation">:</span> passw0rd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以使用 <code>helm get values</code> 来查看新设置是否生效：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:32:10] $ helm get values mysql-1661840339USER-SUPPLIED VALUES:mysqlDatabase: user0dbmysqlPassword: user0pwdmysqlRootPassword: passw0rdmysqlUser: user0persistence:  enabled: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>helm get</code> 命令是查看集群中 release 的非常有用的命令，正如我们在上面看到的，它显示了 <code>panda.yaml</code> 中的新配置值被部署到了集群中，现在如果某个版本在发布期间没有按计划进行，那么可以使用 <code>helm rollback [RELEASE] [REVISION]</code> 命令很容易回滚到之前的版本：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:32:59] $ helm lsNAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSIONmysql-1661840339        default         2               2022-08-30 14:31:08.870825 +0800 CST    deployed        mysql-1.6.9     5.7.30     # zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:33:00] $ helm history mysql-1661840339REVISION        UPDATED                         STATUS          CHART           APP VERSION     DESCRIPTION     1               Tue Aug 30 14:19:03 2022        superseded      mysql-1.6.9     5.7.30          Install complete2               Tue Aug 30 14:31:08 2022        deployed        mysql-1.6.9     5.7.30          Upgrade complete# zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:33:14] $ helm rollback mysql-1661840339 1Rollback was a success! Happy Helming!# zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:34:25] C:1$ kubectl get pods -l release=mysql-1661840339NAME                               READY   STATUS    RESTARTS   AGEmysql-1661840339-655bdc759-4d94f   1/1     Running   0          16m# zhangquan @ MacBook-Pro in ~/code/github.com/k8s-app/helm [14:35:24] $ helm get values mysql-1661840339USER-SUPPLIED VALUES:mysqlDatabase: user0dbmysqlPassword: user0pwdmysqlUser: user0persistence:  enabled: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 values 配置已经回滚到之前的版本了。上面的命令回滚到了 release 的第一个版本，每次进行安装、升级或回滚时，修订号都会加 1，第一个修订号始终为1，我们可以使用 <code>helm history [RELEASE]</code> 来查看某个版本的修订号。</p><p>除此之外我们还可以指定一些有用的选项来定制 install/upgrade/rollback 的一些行为，要查看完整的参数标志，我们可以运行 <code>helm &lt;command&gt; --help</code> 来查看，这里我们介绍几个有用的参数：</p><ul><li><code>--timeout</code>: 等待 Kubernetes 命令完成的时间，默认是 300（5分钟）</li><li><code>--wait</code>: 等待直到所有 Pods 都处于就绪状态、PVCs 已经绑定、Deployments 具有处于就绪状态的最小 Pods 数量（期望值减去 maxUnavailable）以及 Service 有一个 IP 地址，然后才标记 release 为成功状态。它将等待与 <code>--timeout</code> 值一样长的时间，如果达到超时，则 release 将标记为失败。注意：在 Deployment 将副本设置为 1 并且作为滚动更新策略的一部分，maxUnavailable 未设置为0的情况下，<code>--wait</code> 将返回就绪状态，因为它已满足就绪状态下的最小 Pod 数量</li><li><code>--no-hooks</code>: 将会跳过命令的运行 hooks</li><li><code>--recreate-pods</code>: 仅适用于 upgrade 和 rollback，这个标志将导致重新创建所有的 Pods。（Helm3 中启用了）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://helm.sh/zh/docs/">https://helm.sh/zh/docs/</a></li><li><a href="https://helm.sh/zh/docs/intro/using_helm/">https://helm.sh/zh/docs/intro/using_helm/</a></li><li><a href="https://www.qikqiak.com/k8strain/helm/">https://www.qikqiak.com/k8strain/helm/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes StorageClass 的使用</title>
      <link href="/2022/08/29/kubernetes-storageclass-de-shi-yong/"/>
      <url>/2022/08/29/kubernetes-storageclass-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-StorageClass-的使用"><a href="#Kubernetes-StorageClass-的使用" class="headerlink" title="Kubernetes StorageClass 的使用"></a>Kubernetes StorageClass 的使用</h1><p>K8s中 <code>PV</code> 的创建一般分为两种，静态创建和动态创建。静态创建就是提前创建好很多PV，形成一个PV池，按照PVC的规格要求选择合适的进行供应。动态创建则不事先创建，而是根据PVC的规格要求，要求什么规格的就创建什么规格的。静态 PV 在很大程度上并不能满足我们的需求，比如我们有一个应用需要对存储的并发度要求比较高，而另外一个应用对读写速度又要求比较高，特别是对于 <code>StatefulSet</code> 类型的应用简单的来使用静态的 PV 就很不合适了，这种情况下我们就需要用到动态 PV，也就是 <code>StorageClass</code>。另外从资源的利用角度来讲，动态创建要更好一些。</p><h2 id="创建-Provisioner"><a href="#创建-Provisioner" class="headerlink" title="创建 Provisioner"></a>创建 Provisioner</h2><p>要使用 StorageClass，我们就得安装对应的自动配置程序，比如我们这里存储后端使用的是 nfs，那么我们就需要使用到一个 nfs-client 的自动配置程序，我们也叫它 Provisioner，这个程序使用我们已经配置好的 nfs 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p><ul><li>自动创建的 PV 以<code>${namespace}-${pvcName}-${pvName}</code>这样的命名格式创建在 NFS 服务器上的共享数据目录中</li><li>而当这个 PV 被回收后会以<code>archieved-${namespace}-${pvcName}-${pvName}</code>这样的命名格式存在 NFS 服务器上。</li></ul><p>当然在部署<code>nfs-client</code>之前，我们需要先成功安装上 nfs 服务器，我们的 NFS 服务地址部署在 master 节点上，IP 是<strong>172.31.0.2</strong>，共享数据目录是**/nfs/data**，参考此前的安装 <a href="https://zhangquan.me/2022/08/21/kubernetes-chi-jiu-hua-cun-chu-pv-he-pvc-de-shi-yong/">Kubernetes 持久化存储PV 和 PVC 的使用</a></p><p>查看  NFS server 状态：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# systemctl status nfs.service● nfs-server.service - NFS server and services   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; enabled; vendor preset: disabled)  Drop-In: /run/systemd/generator/nfs-server.service.d           └─order-with-mounts.conf   Active: active (exited) since Mon 2022-08-29 22:13:42 CST; 1min 44s ago  Process: 916 ExecStartPost=/bin/sh -c if systemctl -q is-active gssproxy; then systemctl reload gssproxy ; fi (code=exited, status=0/SUCCESS)  Process: 893 ExecStart=/usr/sbin/rpc.nfsd $RPCNFSDARGS (code=exited, status=0/SUCCESS)  Process: 887 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCCESS) Main PID: 893 (code=exited, status=0/SUCCESS)    Tasks: 0   Memory: 0B   CGroup: /system.slice/nfs-server.serviceAug 29 22:13:42 k8s-master systemd[1]: Starting NFS server and services...Aug 29 22:13:42 k8s-master systemd[1]: Started NFS server and services.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后接下来我们部署 nfs-client 即可，我们也可以直接参考<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/tree/master/deploy">nfs-client 的文档</a>，进行安装即可。</p><p>开始之前先创建一个文件夹来保存我们的资源文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# mkdir ~/nfs-storage-class[root@k8s-master ~]# cd ~/nfs-storage-class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>第一步</strong>：配置 Deployment，将里面的对应的参数替换成我们自己的 nfs 配置 deployment.yaml</p><p>参考：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/deployment.yaml">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/deployment.yaml</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> Recreate  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner          <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/sig<span class="token punctuation">-</span>storage/nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner<span class="token punctuation">:</span>v4.0.2          <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /persistentvolumes          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> PROVISIONER_NAME              <span class="token key atrule">value</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>sigs.io/nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_SERVER              <span class="token key atrule">value</span><span class="token punctuation">:</span> 172.31.0.2            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NFS_PATH              <span class="token key atrule">value</span><span class="token punctuation">:</span> /nfs/data      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>root          <span class="token key atrule">nfs</span><span class="token punctuation">:</span>            <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.31.0.2            <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第二步</strong>：将环境变量 NFS_SERVER 和 NFS_PATH 替换，当然也包括下面的 nfs 配置，我们可以看到我们这里使用了一个名为 nfs-client-provisioner 的<code>serviceAccount</code>，所以我们也需要创建一个 sa，然后绑定上对应的权限：rbac.yaml</p><p>参考：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/rbac.yaml">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/rbac.yaml</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"nodes"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumes"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"delete"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"persistentvolumeclaims"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storage.k8s.io"</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"storageclasses"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"events"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> run<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner<span class="token punctuation">-</span>runner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"endpoints"</span><span class="token punctuation">]</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">]</span><span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token comment"># replace with namespace where provisioner is deployed</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner    <span class="token comment"># replace with namespace where provisioner is deployed</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>locking<span class="token punctuation">-</span>nfs<span class="token punctuation">-</span>client<span class="token punctuation">-</span>provisioner  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们这里新建的一个名为 nfs-client-provisioner 的<code>ServiceAccount</code>，然后绑定了一个名为 nfs-client-provisioner-runner 的<code>ClusterRole</code>，而该<code>ClusterRole</code>声明了一些权限，其中就包括对<code>persistentvolumes</code>的增、删、改、查等权限，所以我们可以利用该<code>ServiceAccount</code>来自动创建 PV。</p><p><strong>第三步</strong>：nfs-client 的 Deployment 声明完成后，我们就可以来创建一个<code>StorageClass</code>对象了：class.yaml</p><p>参考：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/class.yaml">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/class.yaml</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> storage.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StorageClass<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client<span class="token key atrule">provisioner</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>sigs.io/nfs<span class="token punctuation">-</span>subdir<span class="token punctuation">-</span>external<span class="token punctuation">-</span>provisioner <span class="token comment"># or choose another name, must match deployment's env PROVISIONER_NAME'</span><span class="token key atrule">parameters</span><span class="token punctuation">:</span>  <span class="token key atrule">archiveOnDelete</span><span class="token punctuation">:</span> <span class="token string">"false"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们声明了一个名为 nfs-client  的<code>StorageClass</code>对象，注意下面的<code>provisioner</code>对应的值一定要和上面的<code>Deployment</code>下面的 PROVISIONER_NAME 这个环境变量的值一样。</p><p>现在我们来创建这些资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# kubectl create -f deployment.yamldeployment.apps/nfs-client-provisioner created[root@k8s-master nfs-storage-class]# kubectl create -f rbac.yamlserviceaccount/nfs-client-provisioner createdclusterrole.rbac.authorization.k8s.io/nfs-client-provisioner-runner createdclusterrolebinding.rbac.authorization.k8s.io/run-nfs-client-provisioner createdrole.rbac.authorization.k8s.io/leader-locking-nfs-client-provisioner createdrolebinding.rbac.authorization.k8s.io/leader-locking-nfs-client-provisioner created[root@k8s-master nfs-storage-class]# kubectl create -f class.yamlstorageclass.storage.k8s.io/nfs-client created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完成后查看下资源状态：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# kubectl get deploymentNAME                     READY   UP-TO-DATE   AVAILABLE   AGE......nfs-client-provisioner   1/1     1            1           6m50s......[root@k8s-master nfs-storage-class]# kubectl get podsNAME                                      READY   STATUS    RESTARTS   AGE......nfs-client-provisioner-6457456d4b-w54q6   1/1     Running   0          36s......[root@k8s-master nfs-storage-class]# kubectl get storageclassNAME         PROVISIONER                                   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGEnfs-client   k8s-sigs.io/nfs-subdir-external-provisioner   Delete          Immediate           false                  60s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="新建-PVC"><a href="#新建-PVC" class="headerlink" title="新建 PVC"></a>新建 PVC</h2><p>上面把<code>StorageClass</code>资源对象创建成功了，接下来我们来通过一个示例测试下动态 PV，首先创建一个 PVC 对象：test-claim.yaml</p><p>参考：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/test-claim.yaml">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/test-claim.yaml</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>claim<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们这里声明了一个<code>PVC</code>对象，采用 <code>ReadWriteMany</code> 的访问模式，请求 1Mi 的空间，我们可以看到上面的 PVC 和  nfs-client 这个 StorageClass 相关联，这个 PVC 对象能够自动绑定到 nfs-client 这个动态 PV 对象上。</p><p>直接创建即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]#  kubectl create -f test-claim.yamlpersistentvolumeclaim/test-claim created [root@k8s-master nfs-storage-class]# kubectl get pvcNAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGEtest-claim   Bound    pvc-c3d960df-2561-43cb-add2-357cc2d3ad55   1Mi        RWX            nfs-client     9s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到一个名为 test-claim 的 PVC 对象创建成功了，状态已经是<code>Bound</code>了，是不是也产生了一个对应的<code>VOLUME</code> 对象，最重要的一栏是<code>STORAGECLASS</code>，现在是不是也有值了，就是我们刚刚创建的<code>StorageClass</code>对象 nfs-client。</p><p>然后查看下 PV 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# kubectl get pvNAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS   REASON   AGEpvc-c3d960df-2561-43cb-add2-357cc2d3ad55   1Mi        RWX            Delete           Bound    default/test-claim   nfs-client              54s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到是不是自动生成了一个关联的 PV 对象，访问模式是<code>RWX</code>，回收策略是 <code>Delete</code>，这个 PV 对象并不是我们手动创建的吧，这是通过我们上面的 <code>StorageClass</code> 对象自动创建的。这就是 StorageClass 的创建方法。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>接下来我们还是用一个简单的示例来测试下我们上面用 StorageClass 方式声明的 PVC 对象：test-pod.yaml</p><p>参考：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/test-pod.yaml">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/blob/master/deploy/test-pod.yaml</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent    <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">"/bin/sh"</span>    <span class="token key atrule">args</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">"-c"</span>    <span class="token punctuation">-</span> <span class="token string">"touch /mnt/SUCCESS &amp;&amp; exit 0 || exit 1"</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>pvc      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/mnt"</span>  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> <span class="token string">"Never"</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>pvc    <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>      <span class="token key atrule">claimName</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>claim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个 Pod 非常简单，就是用一个 <strong>busybox</strong> 容器，在 /mnt 目录下面新建一个 SUCCESS 的文件，然后把 /mnt 目录挂载到上面我们新建的 test-claim 这个资源对象上面了，要验证很简单，只需要去查看下我们 nfs 服务器上面的共享数据目录下面是否有 SUCCESS 这个文件即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]#  kubectl create -f test-pod.yamlpod/test-pod created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后我们可以在 nfs 服务器的共享数据目录下面查看下数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# ls -l /nfs/data/total 4drwxr-xr-x 2 root root  6 Aug 21 22:19 01drwxr-xr-x 2 root root 24 Aug 21 22:24 02drwxr-xr-x 2 root root  6 Aug 21 22:19 03drwxrwxrwx 2 root root 21 Aug 29 22:23 default-test-claim-pvc-c3d960df-2561-43cb-add2-357cc2d3ad55drwxr-xr-x 2 root root 24 Aug 21 21:26 nginx-pv-rw-r--r-- 1 root root 17 Aug 21 20:56 test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到下面有名字很长的文件夹，这个文件夹的命名方式是不是和我们上面的规则：**${namespace}-${pvcName}-${pvName}**是一样的，再看下这个文件夹下面是否有其他文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# ls /nfs/data/default-test-claim-pvc-c3d960df-2561-43cb-add2-357cc2d3ad55/SUCCESS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们看到下面有一个 SUCCESS 的文件，证明我们上面的验证是成功的。</p><p>另外我们可以看到我们这里是手动创建的一个 PVC 对象，在实际工作中，使用 StorageClass 更多的是 StatefulSet 类型的服务，<code>StatefulSet</code>类型的服务我们也可以通过一个<code>volumeClaimTemplates</code>属性来直接使用 StorageClass，如下：test-statefulset-nfs.yaml</p><p>参考：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx <span class="token comment"># 必须匹配 .spec.template.metadata.labels</span>  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token comment"># 必须匹配 .spec.selector.matchLabels</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> web        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>  <span class="token comment">#让它自动创建一个 PVC，这和上面 test-claim.yaml 一样</span>  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> www <span class="token comment"># pvc 名字</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>client      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span>          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上 volumeClaimTemplates 下面就是一个 PVC 对象的模板，就类似于我们这里 StatefulSet 下面的 template，实际上就是一个 Pod 的模板，我们不单独创建成 PVC 对象，而用这种模板就可以动态的去创建了对象，这种方式在 StatefulSet 类型的服务下面使用得非常多。</p><p>直接创建上面的对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]#  kubectl create -f test-statefulset-nfs.yamlstatefulset.apps/web created [root@k8s-master nfs-storage-class]# kubectl get podsNAME                                      READY   STATUS      RESTARTS   AGE......web-0                                     1/1     Running     0          76sweb-1                                     1/1     Running     0          20sweb-2                                     1/1     Running     0          15s......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完成后可以看到上面的3个 Pod 已经运行成功，然后查看下 PVC 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# kubectl get pvcNAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGEtest-claim   Bound    pvc-c3d960df-2561-43cb-add2-357cc2d3ad55   1Mi        RWX            nfs-client     25mwww-web-0    Bound    pvc-6e6916f2-275b-4bc8-9097-dd96b0e06d8b   1Gi        RWO            nfs-client     106swww-web-1    Bound    pvc-fc8f5e03-be8c-422c-81c8-3c3374392791   1Gi        RWO            nfs-client     50swww-web-2    Bound    pvc-e0d2d4ab-a29f-4bc4-8283-17448a1ebff1   1Gi        RWO            nfs-client     45s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到是不是也生成了3个 PVC 对象，名称由模板名称 name 加上 Pod 的名称组合而成，这3个 PVC 对象也都是 绑定状态了，很显然我们查看 PV 也可以看到对应的3个 PV 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# kubectl get pvNAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS   REASON   AGEpvc-6e6916f2-275b-4bc8-9097-dd96b0e06d8b   1Gi        RWO            Delete           Bound    default/www-web-0    nfs-client              2m19spvc-c3d960df-2561-43cb-add2-357cc2d3ad55   1Mi        RWX            Delete           Bound    default/test-claim   nfs-client              25mpvc-e0d2d4ab-a29f-4bc4-8283-17448a1ebff1   1Gi        RWO            Delete           Bound    default/www-web-2    nfs-client              78spvc-fc8f5e03-be8c-422c-81c8-3c3374392791   1Gi        RWO            Delete           Bound    default/www-web-1    nfs-client              83s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 nfs 服务器上面的共享数据目录：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master nfs-storage-class]# ls -l /nfs/data/total 4drwxr-xr-x 2 root root  6 Aug 21 22:19 01drwxr-xr-x 2 root root 24 Aug 21 22:24 02drwxr-xr-x 2 root root  6 Aug 21 22:19 03drwxrwxrwx 2 root root 21 Aug 29 22:23 default-test-claim-pvc-c3d960df-2561-43cb-add2-357cc2d3ad55drwxrwxrwx 2 root root  6 Aug 29 22:43 default-www-web-0-pvc-6e6916f2-275b-4bc8-9097-dd96b0e06d8bdrwxrwxrwx 2 root root  6 Aug 29 22:44 default-www-web-1-pvc-fc8f5e03-be8c-422c-81c8-3c3374392791drwxrwxrwx 2 root root  6 Aug 29 22:44 default-www-web-2-pvc-e0d2d4ab-a29f-4bc4-8283-17448a1ebff1drwxr-xr-x 2 root root 24 Aug 21 21:26 nginx-pv-rw-r--r-- 1 root root 17 Aug 21 20:56 test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也有对应的3个数据目录，这就是我们的 StorageClass 简单使用方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/</a></li><li><a href="https://www.qikqiak.com/post/kubernetes-persistent-volume2/">https://www.qikqiak.com/post/kubernetes-persistent-volume2/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Ingress Traefik 的安装及简单使用</title>
      <link href="/2022/08/28/kubernetes-ingress-traefik-de-an-zhuang-ji-jian-dan-shi-yong/"/>
      <url>/2022/08/28/kubernetes-ingress-traefik-de-an-zhuang-ji-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Ingress-Traefik-的安装及简单使用"><a href="#Kubernetes-Ingress-Traefik-的安装及简单使用" class="headerlink" title="Kubernetes Ingress Traefik 的安装及简单使用"></a>Kubernetes Ingress Traefik 的安装及简单使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Ingress</code>其实就是从 kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，有的同学可能觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新服务加入的时候怎么改 Nginx 配置？不可能让我们去手动更改或者滚动更新前端的 Nginx Pod 吧？那我们再加上一个服务发现的工具比如 consul 如何？貌似是可以，对吧？而且在之前单独使用 docker 的时候，这种方式已经使用得很普遍了，Ingress 实际上就是这样实现的，只是服务发现的功能自己实现了，不需要使用第三方的服务了，然后再加上一个域名规则定义，路由信息的刷新需要一个靠 Ingress controller 来提供。</p><p>Ingress controller 可以理解为一个监听器，通过不断地与 kube-apiserver 打交道，实时的感知后端 service、pod 的变化，当得到这些变化信息后，Ingress controller 再结合 Ingress 的配置，更新反向代理负载均衡器，达到服务发现的作用。其实这点和服务发现工具 consul consul-template 非常类似。</p><p>现在可以供大家使用的 Ingress controller 有很多，比如 <a href="https://traefik.io/">traefik</a>、<a href="https://kubernetes.github.io/ingress-nginx/">nginx-controller</a>、<a href="https://konghq.com/blog/kubernetes-ingress-controller-for-kong/">Kubernetes Ingress Controller for Kong</a>、<a href="https://github.com/jcmoraisjr/haproxy-ingress">HAProxy Ingress controller</a>，当然你也可以自己实现一个 Ingress Controller，现在普遍用得较多的是 traefik 和 nginx-controller，traefik 的性能较 nginx-controller 差，但是配置使用要简单许多，我们这里会以更简单的 traefik 为例给大家介绍 ingress 的使用。</p><h2 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h2><p>Traefik 是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。目前支持 Docker、Swarm、Mesos/Marathon、 Mesos、Kubernetes、Consul、Etcd、Zookeeper、BoltDB、Rest API 等等后端模型。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220828194506.png"></p><p>要使用 traefik，我们同样需要部署 traefik 的 Pod，我们将 traefik 部署到 master 节点上。</p><p>创建存放 traefik 资源清单目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir ~/traefikcd ~/traefik<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先，为安全起见我们这里使用 RBAC 安全认证方式：(rbac.yaml)：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> services      <span class="token punctuation">-</span> endpoints      <span class="token punctuation">-</span> secrets    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get      <span class="token punctuation">-</span> list      <span class="token punctuation">-</span> watch  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> extensions    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ingresses    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get      <span class="token punctuation">-</span> list      <span class="token punctuation">-</span> watch<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接在集群中创建即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master traefik]# kubectl create -f rbac.yaml serviceaccount/traefik-ingress-controller createdclusterrole.rbac.authorization.k8s.io/traefik-ingress-controller createdclusterrolebinding.rbac.authorization.k8s.io/traefik-ingress-controller created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看创建的资源：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master traefik]# kubectl get sa traefik-ingress-controller -n kube-systemNAME                         SECRETS   AGEtraefik-ingress-controller   1         104s[root@k8s-master traefik]# kubectl get clusterrole  traefik-ingress-controller -n kube-system   NAME                         CREATED ATtraefik-ingress-controller   2022-08-28T11:59:53Z[root@k8s-master traefik]# kubectl get clusterrolebinding traefik-ingress-controller -n kube-sysgemNAME                         ROLE                                     AGEtraefik-ingress-controller   ClusterRole/traefik-ingress-controller   2m14s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用 Deployment 来管理 Pod，直接使用官方的 traefik 镜像部署即可（traefik.yaml）</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>lb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>lb  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>lb        <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>lb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller      <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">60</span>      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span>      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">kubernetes.io/hostname</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>master      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> traefik<span class="token punctuation">:</span>v1.7.17 <span class="token comment">#使用的traefik官方镜像</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>lb        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http          <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> admin          <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>api        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>kubernetes        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>logLevel=INFO<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>service  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">k8s-app</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>lb  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> web    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> admin  <span class="token comment">#端口名称</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接创建上面的资源对象即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master traefik]# kubectl create -f traefik.yamldeployment.apps/traefik-ingress-controller createdservice/traefik-ingress-service created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要注意上面 yaml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span><span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>  <span class="token key atrule">kubernetes.io/hostname</span><span class="token punctuation">:</span> k8<span class="token punctuation">-</span>master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以我们使用<code>nodeSelector</code>标签将<code>traefik</code>的固定调度到<code>master</code>这个节点上，那么上面的<strong>tolerations</strong>是干什么的呢？这个是因为我们集群使用的 kubeadm 安装的，master 节点默认是不能被普通应用调度的，要被调度的话就需要添加这里的 tolerations 属性，当然如果你的集群和我们的不太一样，直接去掉这里的调度策略就行。</p><blockquote><p>nodeSelector 和 tolerations 都属于 Pod 的调度策略</p></blockquote><p>可以使用下面的命令查看 master 节点的 labels：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master traefik]# kubectl get nodesNAME         STATUS   ROLES                  AGE   VERSIONk8s-master   Ready    control-plane,master   15d   v1.20.9k8s-node1    Ready    &lt;none&gt;                 15d   v1.20.9k8s-node2    Ready    &lt;none&gt;                 15d   v1.20.9[root@k8s-master traefik]# kubectl get nodes --show-labelsNAME         STATUS   ROLES                  AGE   VERSION   LABELSk8s-master   Ready    control-plane,master   15d   v1.20.9   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=k8s-node1    Ready    &lt;none&gt;                 15d   v1.20.9   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node1,kubernetes.io/os=linuxk8s-node2    Ready    &lt;none&gt;                 15d   v1.20.9   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node2,kubernetes.io/os=linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>traefik 还提供了一个 web ui 工具，就是上面的 8080 端口对应的服务，为了能够访问到该服务，我们这里将服务设置成的 NodePort：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master traefik]# kubectl get deployment traefik-ingress-controller -n kube-system  NAME                         READY   UP-TO-DATE   AVAILABLE   AGEtraefik-ingress-controller   1/1     1            1           5s[root@k8s-master traefik]# kubectl get svc traefik-ingress-service -n kube-systemNAME                      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                       AGEtraefik-ingress-service   NodePort   10.96.144.7   &lt;none&gt;        80:31000/TCP,8080:32313/TCP   8s[root@k8s-master traefik]# kubectl get pods -n kube-system -l k8s-app=traefik-ingress-lb -o wideNAME                                          READY   STATUS    RESTARTS   AGE   IP                NODE         NOMINATED NODE   READINESS GATEStraefik-ingress-controller-574b6698df-7cc59   1/1     Running   0          12s   192.168.235.234   k8s-master   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在在浏览器中输入 master_node_ip:32313 就可以访问到 traefik 的 dashboard 了：（hosts 文件中增加了 traefik.zq.io 对 master ip的映射）</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-traefik-1.png"></p><h2 id="Ingress-对象"><a href="#Ingress-对象" class="headerlink" title="Ingress 对象"></a>Ingress 对象</h2><p>现在我们是通过 NodePort 来访问 traefik 的 Dashboard 的，那怎样通过 ingress 来访问呢？ 首先，需要创建一个 ingress 对象：(ingress.yaml)</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>web<span class="token punctuation">-</span>ui  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">kubernetes.io/ingress.class</span><span class="token punctuation">:</span> traefik  <span class="token comment">#固定的</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> zq.ingress<span class="token punctuation">-</span>traefik.io    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>service <span class="token comment">#代理到哪个服务上去</span>          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">8080</span>  <span class="token comment">#代理到哪个端口，可以使用端口名称 admin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后为 traefik dashboard 创建对应的 ingress 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master traefik]# kubectl create -f ingress.yaml Warning: extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingressingress.extensions/traefik-web-ui created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要注意上面的 ingress 对象的规则，特别是 rules 区域，我们这里是要为 traefik 的 dashboard 建立一个 ingress 对象，所以这里的 serviceName 对应的是上面我们创建的 traefik-ingress-service，端口也要注意对应 8080 端口，为了避免端口更改，这里的 servicePort 的值也可以替换成上面定义的 port 的名字：<strong>admin</strong></p><p>创建完成后，我们应该怎么来测试呢？</p><ul><li><p>第一步，在本地的**/etc/hosts**里面添加上 zq.ingress-traefik.io与 master 节点外网 IP 的映射关系</p></li><li><p>第二步，在浏览器中访问：zq.ingress-traefik.io，我们会发现并没有得到我们期望的 dashboard 界面，这是因为我们上面部署 traefik 的时候使用的是 NodePort 这种 Service 对象，所以我们只能通过上面的 32313 端口访问到我们的目标对象：<a href="zq.ingress-traefik.io:32313">zq.ingress-traefik.io:32313</a>，第一种 dashboard 的访问方式是通过 NodePort 方式，现在这种 dashboard 是通过自定义域名通过 ingress 来访问：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220828205440.png"></p><p>加上端口后我们发现可以访问到 dashboard 了，而且在 dashboard 当中多了一条记录，正是上面我们创建的 ingress 对象的数据，我们还可以切换到 HEALTH 界面中，可以查看当前 traefik 代理的服务的整体的健康状态：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220828205700.png"></p><ul><li>第三步，上面我们可以通过自定义域名加上端口可以访问我们的服务了，但是我们平时服务别人的服务是不是都是直接用的域名啊，http 或者 https 的，几乎很少有在域名后面加上端口访问的吧？为什么？太麻烦啊，端口也记不住，要解决这个问题，怎么办，我们只需要把我们上面的 traefik 的核心应用的端口隐射到 master 节点上的 80 端口，是不是就可以了，因为 http 默认就是访问 80 端口，但是我们在 Service 里面是添加的一个 NodePort 类型的服务，没办法隐射 80 端口，怎么办？这里就可以直接在 Pod 中指定一个 hostPort 即可，更改上面的 traefik.yaml 文件中的容器端口：</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">containers</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> traefik<span class="token punctuation">:</span>v1.7.17 <span class="token comment">#使用的traefik官方镜像</span><span class="token key atrule">name</span><span class="token punctuation">:</span> traefik<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>lb<span class="token key atrule">ports</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http  <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token comment"># 添加这一行，traefik 的80端口映射到主机的 80</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> admin  <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加以后<code>hostPort: 80</code>，然后更新应用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f traefik.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新完成后，这个时候我们在浏览器中直接使用域名方法测试下。</p><ul><li>第四步，正常来说，我们如果有自己的域名，我们可以将我们的域名添加一条 DNS 记录，解析到 master 的外网 IP 上面，这样任何人都可以通过域名来访问我的暴露的服务了。</li></ul><blockquote><p>如果你有多个边缘节点的话，可以在每个边缘节点上部署一个 ingress-controller 服务，然后在边缘节点前面挂一个负载均衡器，比如 nginx，将所有的边缘节点均作为这个负载均衡器的后端，这样就可以实现 ingress-controller 的高可用和负载均衡了。</p></blockquote><p>到这里我们就通过 ingress 对象对外成功暴露了一个服务，当然 traefik 还有更多的用法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.qikqiak.com/post/ingress-traefik1/">https://www.qikqiak.com/post/ingress-traefik1/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes HPA</title>
      <link href="/2022/08/28/kubernetes-hpa/"/>
      <url>/2022/08/28/kubernetes-hpa/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-HPA"><a href="#Kubernetes-HPA" class="headerlink" title="Kubernetes HPA"></a>Kubernetes HPA</h1><p>在  k8s 中我们可以使用 <code>kubectl scale</code> 命令可以来实现 Pod 的扩缩容功能，但是这个毕竟是完全手动操作的，要应对线上的各种复杂情况，我们需要能够做到自动化去感知业务，来自动进行扩缩容。为此，Kubernetes 也为我们提供了这样的一个资源对象：<code>Horizontal Pod Autoscaling（Pod 水平自动伸缩）</code>，简称<code>HPA</code>，HPA 通过监控分析一些控制器控制的所有 Pod 的负载变化情况来确定是否需要调整 Pod 的副本数量，这是 HPA 最基本的原理：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-hpa-1.jpeg"></p><p>我们可以简单的通过 <code>kubectl autoscale</code> 命令来创建一个 HPA 资源对象，<code>HPA Controller</code>默认<code>30s</code>轮询一次（可通过 <code>kube-controller-manager</code> 的<code>--horizontal-pod-autoscaler-sync-period</code> 参数进行设置），查询指定的资源中的 Pod 资源使用率，并且与创建时设定的值和指标做对比，从而实现自动伸缩的功能。</p><h2 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics Server"></a>Metrics Server</h2><p><code>Metrics Server</code> 可以通过标准的 Kubernetes API 把监控数据暴露出来，有了 <code>Metrics Server</code> 之后，我们就完全可以通过标准的 Kubernetes API 来访问我们想要获取的监控数据了</p><p>参考说明：<a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/">https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl get --raw "/apis/metrics.k8s.io/v1beta1/namespaces/&lt;namespace-name&gt;/pods/&lt;pod-name&gt;" | jq '.'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是使用 <code>curl</code> 来完成的相同 API 调用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl https://localhost:8080/apis/metrics.k8s.io/v1beta1/namespaces/&lt;namespace-name&gt;/pods/&lt;pod-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如当我们访问上面的 API 的时候，我们就可以获取到该 Pod 的资源数据，这些数据其实是来自于 kubelet 的 <code>Summary API</code> 采集而来的。不过需要说明的是我们这里可以通过标准的 API 来获取资源监控数据，并不是因为 <code>Metrics Server</code> 就是 APIServer 的一部分，而是通过 Kubernetes 提供的 <code>Aggregator</code> 汇聚插件来实现的，是独立于 APIServer 之外运行的。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220828161732.png"></p><h3 id="聚合-API"><a href="#聚合-API" class="headerlink" title="聚合 API"></a>聚合 API</h3><p><code>Aggregator</code> 允许开发人员编写一个自己的服务，把这个服务注册到 Kubernetes 的 APIServer 里面去，这样我们就可以像原生的 APIServer 提供的 API 使用自己的 API 了，我们把自己的服务运行在 Kubernetes 集群里面，然后 Kubernetes 的 <code>Aggregator</code> 通过 Service 名称就可以转发到我们自己写的 Service 里面去了。这样这个聚合层就带来了很多好处：</p><ul><li>增加了 API 的扩展性，开发人员可以编写自己的 API 服务来暴露他们想要的 API。</li><li>丰富了 API，核心 kubernetes 团队阻止了很多新的 API 提案，通过允许开发人员将他们的 API 作为单独的服务公开，这样就无须社区繁杂的审查了。</li><li>开发分阶段实验性 API，新的 API 可以在单独的聚合服务中开发，当它稳定之后，在合并会 APIServer 就很容易了。</li><li>确保新 API 遵循 Kubernetes 约定，如果没有这里提出的机制，社区成员可能会被迫推出自己的东西，这样很可能造成社区成员和社区约定不一致。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们要使用 HPA，就需要在集群中安装 <code>Metrics Server</code> 服务，要安装 <code>Metrics Server</code> 就需要开启 <code>Aggregator</code>，因为 <code>Metrics Server</code> 就是通过该代理进行扩展的，不过我们集群是通过 Kubeadm 搭建的，默认已经开启了。</p><p><code>Aggregator</code> 聚合层启动完成后，就可以来安装 <code>Metrics Server</code> 了，我们可以获取该仓库的官方安装资源清单：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 官方仓库地址：https://github.com/kubernetes-sigs/metrics-server$ wget https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.6/components.yaml -O ~/download/metrics-server.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在部署之前，修改 <code>components.yaml</code> 的镜像地址为：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">containers:- name: metrics-server  image: registry.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等部署完成后，可以查看 Pod 日志是否正常：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f download/metrics-server.yaml  [root@k8s-master ~]# kubectl get pods -n kube-system -l k8s-app=metrics-serverNAME                             READY   STATUS    RESTARTS   AGEmetrics-server-75665d756-jdpw5   1/1     Running   0          2m22s[root@k8s-master ~]# kubectl logs -f metrics-server-75665d756-jdpw5 -n kube-system......E0828 08:29:03.977217       1 manager.go:111] unable to fully collect metrics: [unable to fully scrape metrics from source kubelet_summary:k8s-node2: unable to fetch metrics from Kubelet k8s-node2 (k8s-node2): Get https://k8s-node2:10250/stats/summary?only_cpu_and_memory=true: dial tcp: lookup k8s-node2 on 10.96.0.10:53: no such host, unable to fully scrape metrics from source kubelet_summary:k8s-node1: unable to fetch metrics from Kubelet k8s-node1 (k8s-node1): Get https://k8s-node1:10250/stats/summary?only_cpu_and_memory=true: dial tcp: lookup k8s-node1 on 10.96.0.10:53: no such host, unable to fully scrape metrics from source kubelet_summary:k8s-master: unable to fetch metrics from Kubelet k8s-master (k8s-master): Get https://k8s-master:10250/stats/summary?only_cpu_and_memory=true: dial tcp: lookup k8s-master on 10.96.0.10:53: no such host]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现 Pod 中出现了一些错误信息：<code>xxx: no such host</code>，我们看到这个错误信息一般就可以确定是 DNS 解析不了造成的，我们可以看到 Metrics Server 会通过 kubelet 的 10250 端口获取信息，使用的是 hostname，我们部署集群的时候在节点的 <code>/etc/hosts</code> 里面添加了节点的 hostname 和 ip 的映射，但是是我们的 Metrics Server 的 Pod 内部并没有这个 hosts 信息，当然也就不识别 hostname 了，要解决这个问题，有两种方法：</p><p>第一种方法就是在集群内部的 DNS 服务里面添加上 hostname 的解析，比如我们这里集群中使用的是 <code>CoreDNS</code>，我们就可以去修改下 CoreDNS 的 Configmap 信息，添加上 hosts 信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ kubectl edit configmap coredns -n kube-systemapiVersion: v1data:  Corefile: |    .:53 {        errors        health        hosts {  # 添加集群节点hosts隐射信息          172.31.0.2 k8s-master          172.31.0.3 k8s-node1          172.31.0.4 k8s-node2          fallthrough        }        kubernetes cluster.local in-addr.arpa ip6.arpa {           pods insecure           upstream           fallthrough in-addr.arpa ip6.arpa        }        prometheus :9153        proxy . /etc/resolv.conf        cache 30        reload    }kind: ConfigMapmetadata:  creationTimestamp: 2019-05-18T11:07:46Z  name: coredns  namespace: kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样当在集群内部的 Pod 访问集群节点的 hostname 的时候就可以解析到对应的 ip 了，另外一种方法（<a href="https://github.com/kubernetes-sigs/metrics-server%EF%BC%89%E5%B0%B1%E6%98%AF%E5%9C%A8">https://github.com/kubernetes-sigs/metrics-server）就是在</a> metrics-server 的启动参数中修改 <code>kubelet-preferred-address-types</code> 参数，如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">args:- --cert-dir=/tmp- --secure-port=4443- --kubelet-preferred-address-types=InternalIP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们这里使用第二种方式，然后重新安装：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete -f download/metrics-server.yaml[root@k8s-master ~]# kubectl apply -f download/metrics-server.yaml [root@k8s-master ~]# kubectl get pods -n kube-system -l k8s-app=metrics-serverNAME                              READY   STATUS    RESTARTS   AGEmetrics-server-78f654ccdd-wcf8t   1/1     Running   0          91s[root@k8s-master ~]# kubectl logs -f metrics-server-78f654ccdd-wcf8t -n kube-system......E0828 08:47:12.412582       1 manager.go:111] unable to fully collect metrics: [unable to fully scrape metrics from source kubelet_summary:k8s-node1: unable to fetch metrics from Kubelet k8s-node1 (172.31.0.3): Get https://172.31.0.3:10250/stats/summary?only_cpu_and_memory=true: x509: cannot validate certificate for 172.31.0.3 because it doesn't contain any IP SANs, unable to fully scrape metrics from source kubelet_summary:k8s-master: unable to fetch metrics from Kubelet k8s-master (172.31.0.2): Get https://172.31.0.2:10250/stats/summary?only_cpu_and_memory=true: x509: cannot validate certificate for 172.31.0.2 because it doesn't contain any IP SANs, unable to fully scrape metrics from source kubelet_summary:k8s-node2: unable to fetch metrics from Kubelet k8s-node2 (172.31.0.4): Get https://172.31.0.4:10250/stats/summary?only_cpu_and_memory=true: x509: cannot validate certificate for 172.31.0.4 because it doesn't contain any IP SANs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为部署集群的时候，CA 证书并没有把各个节点的 IP 签上去，所以这里 <code>Metrics Server</code> 通过 IP 去请求时，提示签的证书没有对应的 IP（错误：<code>x509: cannot validate certificate for 172.31.0.3 because it doesn’t contain any IP SANs</code>），我们可以添加一个<code>--kubelet-insecure-tls</code>参数跳过证书校验：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">args:- --cert-dir=/tmp- --secure-port=4443- --kubelet-insecure-tls- --kubelet-preferred-address-types=InternalIP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再重新安装即可成功！可以通过如下命令来验证：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete -f download/metrics-server.yaml[root@k8s-master ~]# kubectl apply -f download/metrics-server.yaml [root@k8s-master ~]# kubectl get pods -n kube-system -l k8s-app=metrics-serverNAME                             READY   STATUS    RESTARTS   AGEmetrics-server-9b4dc89d7-jnmr7   1/1     Running   0          14s[root@k8s-master ~]# kubectl logs -f metrics-server-9b4dc89d7-jnmr7 -n kube-systemI0828 08:51:12.584555       1 serving.go:312] Generated self-signed cert (/tmp/apiserver.crt, /tmp/apiserver.key)I0828 08:51:13.012958       1 secure_serving.go:116] Serving securely on [::]:4443......[root@k8s-master ~]#  kubectl get apiservice | grep metricsv1beta1.metrics.k8s.io                 kube-system/metrics-server   True        67s[root@k8s-master ~]# kubectl get --raw "/apis/metrics.k8s.io/v1beta1/nodes"{"kind":"NodeMetricsList","apiVersion":"metrics.k8s.io/v1beta1","metadata":{"selfLink":"/apis/metrics.k8s.io/v1beta1/nodes"},"items":[{"metadata":{"name":"k8s-master","selfLink":"/apis/metrics.k8s.io/v1beta1/nodes/k8s-master","creationTimestamp":"2022-08-28T08:53:06Z"},"timestamp":"2022-08-28T08:52:05Z","window":"30s","usage":{"cpu":"135321453n","memory":"1509068Ki"}},{"metadata":{"name":"k8s-node1","selfLink":"/apis/metrics.k8s.io/v1beta1/nodes/k8s-node1","creationTimestamp":"2022-08-28T08:53:06Z"},"timestamp":"2022-08-28T08:52:11Z","window":"30s","usage":{"cpu":"64140701n","memory":"708528Ki"}},{"metadata":{"name":"k8s-node2","selfLink":"/apis/metrics.k8s.io/v1beta1/nodes/k8s-node2","creationTimestamp":"2022-08-28T08:53:06Z"},"timestamp":"2022-08-28T08:52:04Z","window":"30s","usage":{"cpu":"63743191n","memory":"830800Ki"}}]}[root@k8s-master ~]# kubectl top nodesNAME         CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%   k8s-master   151m         7%     1456Mi          37%       k8s-node1    72m          3%     689Mi           17%       k8s-node2    65m          3%     811Mi           21% <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们可以通过 <code>kubectl top</code> 命令来获取到资源数据了，证明 <code>Metrics Server</code> 已经安装成功了。</p><h2 id="HAP"><a href="#HAP" class="headerlink" title="HAP"></a>HAP</h2><p>现在我们用 Deployment 来创建一个 Nginx Pod，然后利用 <code>HPA</code> 来进行自动扩缩容。资源清单如下所示：（hpa-demo.yaml）</p><p>把 hap 相关资源文件统一放在 hap 目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# mkdir ~/hap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hpa<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接创建 Deployment：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f hpa/hpa-demo.yaml deployment.apps/hpa-demo created[root@k8s-master ~]# kubectl get pods -l app=nginxNAME                        READY   STATUS    RESTARTS   AGEhpa-demo-7848d4b86f-9sw8b   1/1     Running   0          18s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们来创建一个 <code>HPA</code> 资源对象，可以使用<code>kubectl autoscale</code>命令来创建：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl autoscale deployment hpa-demo --cpu-percent=10 --min=1 --max=10  horizontalpodautoscaler.autoscaling/hpa-demo autoscaled[root@k8s-master ~]# kubectl get hpaNAME       REFERENCE             TARGETS         MINPODS   MAXPODS   REPLICAS   AGEhpa-demo   Deployment/hpa-demo   &lt;unknown&gt;/10%   1         10        0          11s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此命令创建了一个关联资源 hpa-demo 的 HPA，最小的 Pod 副本数为1，最大为10。HPA 会根据设定的 cpu 使用率（10%）动态的增加或者减少 Pod 数量。</p><p>当然我们依然还是可以通过创建 YAML 文件的形式来创建 HPA 资源对象。如果我们不知道怎么编写的话，可以查看上面命令行创建的HPA的YAML文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get hpa hpa-demo -o yamlapiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata:  annotations:    autoscaling.alpha.kubernetes.io/conditions: '[{"type":"AbleToScale","status":"True","lastTransitionTime":"2022-08-28T09:04:49Z","reason":"SucceededGetScale","message":"the      HPA controller was able to get the target''s current scale"},{"type":"ScalingActive","status":"False","lastTransitionTime":"2022-08-28T09:04:49Z","reason":"FailedGetResourceMetric","message":"the      HPA was unable to compute the replica count: failed to get cpu utilization:      missing request for cpu"}]'  creationTimestamp: "2022-08-28T09:04:34Z"  managedFields:  - apiVersion: autoscaling/v1    fieldsType: FieldsV1    fieldsV1:      f:spec:        f:maxReplicas: {}        f:minReplicas: {}        f:scaleTargetRef:          f:apiVersion: {}          f:kind: {}          f:name: {}        f:targetCPUUtilizationPercentage: {}    manager: kubectl-autoscale    operation: Update    time: "2022-08-28T09:04:34Z"  - apiVersion: autoscaling/v1    fieldsType: FieldsV1    fieldsV1:      f:metadata:        f:annotations:          .: {}          f:autoscaling.alpha.kubernetes.io/conditions: {}      f:status:        f:currentReplicas: {}    manager: kube-controller-manager    operation: Update    time: "2022-08-28T09:04:49Z"  name: hpa-demo  namespace: default  resourceVersion: "126191"  uid: c9a2ee21-cced-4518-863f-61fcf4f76c8espec:  maxReplicas: 10  minReplicas: 1  scaleTargetRef:    apiVersion: apps/v1    kind: Deployment    name: hpa-demo  targetCPUUtilizationPercentage: 10status:  currentReplicas: 1  desiredReplicas: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们可以根据上面的 YAML 文件就可以自己来创建一个基于 YAML 的 HPA 描述文件了。但是我们发现上面信息里面出现了一些 Fail 信息，我们来查看下这个 HPA 对象的信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl describe hpa hpa-demoName:                                                  hpa-demoNamespace:                                             defaultLabels:                                                &lt;none&gt;Annotations:                                           &lt;none&gt;CreationTimestamp:                                     Sun, 28 Aug 2022 17:04:34 +0800Reference:                                             Deployment/hpa-demoMetrics:                                               ( current / target )  resource cpu on pods  (as a percentage of request):  &lt;unknown&gt; / 10%Min replicas:                                          1Max replicas:                                          10Deployment pods:                                       1 current / 0 desiredConditions:  Type           Status  Reason                   Message  ----           ------  ------                   -------  AbleToScale    True    SucceededGetScale        the HPA controller was able to get the target's current scale  ScalingActive  False   FailedGetResourceMetric  the HPA was unable to compute the replica count: failed to get cpu utilization: missing request for cpuEvents:  Type     Reason                        Age               From                       Message  ----     ------                        ----              ----                       -------  Warning  FailedGetResourceMetric       4s (x5 over 66s)  horizontal-pod-autoscaler  failed to get cpu utilization: missing request for cpu  Warning  FailedComputeMetricsReplicas  4s (x5 over 66s)  horizontal-pod-autoscaler  invalid metrics (1 invalid out of 1), first error is: failed to get cpu utilization: missing request for cpu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到上面的事件信息里面出现了 <code>failed to get cpu utilization: missing request for cpu</code> 这样的错误信息。这是因为我们上面创建的 Pod 对象没有添加 request 资源声明，这样导致 HPA 读取不到 CPU 指标信息，所以如果要想让 HPA 生效，对应的 Pod 资源必须添加 requests 资源声明，更新我们的资源清单文件（hpa-demo.yaml）：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hpa<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 50Mi            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 50m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后重新更新 Deployment，重新创建 HPA 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete -f hpa/hpa-demo.yaml deployment.apps "hpa-demo" deleted[root@k8s-master ~]# kubectl apply -f hpa/hpa-demo.yaml deployment.apps/hpa-demo created[root@k8s-master ~]# kubectl get pods -o wide -l app=nginxNAME                        READY   STATUS    RESTARTS   AGE   IP              NODE        NOMINATED NODE   READINESS GATEShpa-demo-6b4467b546-lndbp   1/1     Running   0          59s   192.168.36.72   k8s-node1   &lt;none&gt;           &lt;none&gt;[root@k8s-master ~]# kubectl get hpa NAME       REFERENCE             TARGETS         MINPODS   MAXPODS   REPLICAS   AGEhpa-demo   Deployment/hpa-demo   &lt;unknown&gt;/10%   1         10        1          5m46s[root@k8s-master ~]# kubectl delete hpa hpa-demohorizontalpodautoscaler.autoscaling "hpa-demo" deleted[root@k8s-master ~]# kubectl autoscale deployment hpa-demo --cpu-percent=10 --min=1 --max=10  horizontalpodautoscaler.autoscaling/hpa-demo autoscaled[root@k8s-master ~]# kubectl describe hpa hpa-demoName:                                                  hpa-demoNamespace:                                             defaultLabels:                                                &lt;none&gt;Annotations:                                           &lt;none&gt;CreationTimestamp:                                     Sun, 28 Aug 2022 17:11:37 +0800Reference:                                             Deployment/hpa-demoMetrics:                                               ( current / target )  resource cpu on pods  (as a percentage of request):  0% (0) / 10%Min replicas:                                          1Max replicas:                                          10Deployment pods:                                       1 current / 1 desiredConditions:  Type            Status  Reason               Message  ----            ------  ------               -------  AbleToScale     True    ScaleDownStabilized  recent recommendations were higher than current one, applying the highest recent recommendation  ScalingActive   True    ValidMetricFound     the HPA was able to successfully calculate a replica count from cpu resource utilization (percentage of request)  ScalingLimited  False   DesiredWithinRange   the desired count is within the acceptable rangeEvents:           &lt;none&gt;[root@k8s-master ~]# kubectl get hpaNAME       REFERENCE             TARGETS   MINPODS   MAXPODS   REPLICAS   AGEhpa-demo   Deployment/hpa-demo   0%/10%    1         10        1          68s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在可以看到 HPA 资源对象已经正常了，现在我们来增大负载进行测试：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 开启另一个终端查看 hap-demo Pod 的 ip[root@k8s-master ~]# kubectl get pods NAME                        READY   STATUS    RESTARTS   AGEhpa-demo-6b4467b546-lndbp   1/1     Running   0          10m[root@k8s-master ~]# kubectl get pod hpa-demo-6b4467b546-lndbp -o wideNAME                        READY   STATUS    RESTARTS   AGE   IP              NODE        NOMINATED NODE   READINESS GATEShpa-demo-6b4467b546-lndbp   1/1     Running   0          11m   192.168.36.72   k8s-node1   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来创建一个 busybox 的 Pod，并且循环访问上面创建的 Pod：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]#  kubectl run -it --image busybox test-hpa --restart=Never --rm /bin/shIf you don't see a command prompt, try pressing enter./ # while true; do wget -q -O- http://192.168.36.72; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下图可以看到，HPA 已经开始工作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get hpaNAME       REFERENCE             TARGETS   MINPODS   MAXPODS   REPLICAS   AGEhpa-demo   Deployment/hpa-demo   0%/10%    1         10        10         17m[root@k8s-master ~]#  kubectl get pods -l app=nginx --watchNAME                        READY   STATUS    RESTARTS   AGEhpa-demo-6b4467b546-dlgk5   0/1     ContainerCreating   0          1shpa-demo-6b4467b546-5plpg   0/1     ContainerCreating   0          1shpa-demo-6b4467b546-wprxt   1/1     Running             0          17shpa-demo-6b4467b546-dlgk5   1/1     Running             0          2shpa-demo-6b4467b546-nd5rh   1/1     Running             0          18shpa-demo-6b4467b546-rbv2x   0/1     Pending             0          0shpa-demo-6b4467b546-rbv2x   0/1     Pending             0          0shpa-demo-6b4467b546-6bcg2   0/1     Pending             0          0shpa-demo-6b4467b546-6bcg2   0/1     Pending             0          0shpa-demo-6b4467b546-6bcg2   0/1     ContainerCreating   0          0shpa-demo-6b4467b546-rbv2x   0/1     ContainerCreating   0          0shpa-demo-6b4467b546-6bcg2   0/1     ContainerCreating   0          0shpa-demo-6b4467b546-rbv2x   0/1     ContainerCreating   0          0shpa-demo-6b4467b546-nphlm   1/1     Running             0          33shpa-demo-6b4467b546-5plpg   1/1     Running             0          17shpa-demo-6b4467b546-rbv2x   1/1     Running             0          2shpa-demo-6b4467b546-rpwpf   1/1     Running             0          32shpa-demo-6b4467b546-6bcg2   1/1     Running             0          32shpa-demo-6b4467b546-rxp2d   1/1     Running             0          47s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到已经自动拉起了很多新的 Pod，最后定格在了我们上面设置的 10 个 Pod，同时查看资源 hpa-demo 的副本数量，副本数量已经从原来的1变成了10个：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deployment hpa-demoNAME       READY   UP-TO-DATE   AVAILABLE   AGEhpa-demo   10/10   10           10          15m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看 HPA 资源的对象了解工作过程：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl describe hpa hpa-demoName:                                                  hpa-demoNamespace:                                             defaultLabels:                                                &lt;none&gt;Annotations:                                           &lt;none&gt;CreationTimestamp:                                     Sun, 28 Aug 2022 17:11:37 +0800Reference:                                             Deployment/hpa-demoMetrics:                                               ( current / target )  resource cpu on pods  (as a percentage of request):  0% (0) / 10%Min replicas:                                          1Max replicas:                                          10Deployment pods:                                       10 current / 10 desiredConditions:  Type            Status  Reason               Message  ----            ------  ------               -------  AbleToScale     True    ScaleDownStabilized  recent recommendations were higher than current one, applying the highest recent recommendation  ScalingActive   True    ValidMetricFound     the HPA was able to successfully calculate a replica count from cpu resource utilization (percentage of request)  ScalingLimited  True    TooManyReplicas      the desired replica count is more than the maximum replica countEvents:  Type    Reason             Age    From                       Message  ----    ------             ----   ----                       -------  Normal  SuccessfulRescale  7m     horizontal-pod-autoscaler  New size: 4; reason: cpu resource utilization (percentage of request) above target  Normal  SuccessfulRescale  6m44s  horizontal-pod-autoscaler  New size: 8; reason: cpu resource utilization (percentage of request) above target  Normal  SuccessfulRescale  6m29s  horizontal-pod-autoscaler  New size: 10; reason: cpu resource utilization (percentage of request) above target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的这个时候我们来关掉 busybox 来减少负载，然后等待一段时间观察下 HPA 和 Deployment 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get hpaNAME       REFERENCE             TARGETS   MINPODS   MAXPODS   REPLICAS   AGEhpa-demo   Deployment/hpa-demo   0%/10%    1         10        1          19m[root@k8s-master ~]# kubectl get deployment hpa-demoNAME       READY   UP-TO-DATE   AVAILABLE   AGEhpa-demo   1/1     1            1           21m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到副本数量已经由 10 变为 1，当前我们只是演示了 CPU 使用率这一个指标，我们还可以根据自定义的监控指标来自动对 Pod 进行扩缩容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://v1-21.docs.kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/">https://v1-21.docs.kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/</a></li><li><a href="https://v1-21.docs.kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale/">https://v1-21.docs.kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale/</a></li><li><a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a></li><li><a href="https://www.qikqiak.com/k8strain/controller/hpa/">https://www.qikqiak.com/k8strain/controller/hpa/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Security Context</title>
      <link href="/2022/08/28/kubernetes-security-context/"/>
      <url>/2022/08/28/kubernetes-security-context/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Security-Context"><a href="#Kubernetes-Security-Context" class="headerlink" title="Kubernetes Security Context"></a>Kubernetes Security Context</h1><p>我们有时候在运行一个容器的时候，可能需要使用 <code>sysctl</code> 命令来修改内核参数，比如 <code>net</code>、<code>vm</code>、<code>kernel</code> 等参数，但是 <code>systcl</code> 需要容器拥有超级权限，才可以使用，在 Docker 容器启动的时候我们可以加上 <code>--privileged</code> 参数来使用特权模式。那么在 Kubernetes 中应该如何来使用呢？</p><p>这个时候我们就需要使用到 Kubernetes 中的 <code>Security Context</code>，也就是常说的安全上下文，主要是来限制容器非法操作宿主节点的系统级别的内容，使得节点的系统或者节点上其他容器组受到影响。Kubernetes 提供了三种配置安全上下文级别的方法：</p><ul><li>Container-level Security Context：仅应用到指定的容器</li><li>Pod-level Security Context：应用到 Pod 内所有容器以及 Volume</li><li>Pod Security Policies（PSP）：应用到集群内部所有 Pod 以及 Volume</li></ul><p>我们可以用如下几种方式来设置 <code>Security Context</code>：</p><ul><li>访问权限控制：根据用户 ID（UID）和组 ID（GID）来限制对资源（比如：文件）的访问权限</li><li>Security Enhanced Linux (SELinux)：为对象分配 <code>SELinux</code> 标签</li><li>以 privileged（特权）模式运行</li><li>Linux Capabilities：给某个特定的进程超级权限，而不用给 root 用户所有的 privileged 权限</li><li>AppArmor：使用程序文件来限制单个程序的权限</li><li>Seccomp：过滤容器中进程的系统调用（system call）</li><li>AllowPrivilegeEscalation（允许特权扩大）：此项配置是一个布尔值，定义了一个进程是否可以比其父进程获得更多的特权，直接效果是，容器的进程上是否被设置 no_new_privs 标记。当出现如下情况时，AllowPrivilegeEscalation 的值始终为 true：<ul><li>容器以 <code>privileged</code> 模式运行</li><li>容器拥有 <code>CAP_SYS_ADMIN</code> 的 Linux Capability</li></ul></li></ul><h2 id="为-Pod-设置-Security-Context"><a href="#为-Pod-设置-Security-Context" class="headerlink" title="为 Pod 设置 Security Context"></a>为 Pod 设置 Security Context</h2><p>我们只需要在 Pod 定义的资源清单文件中添加 <code>securityContext</code> 字段，就可以为 Pod 指定安全上下文相关的设定，通过该字段指定的内容将会对当前 Pod 中的所有容器生效。</p><p>新建一个目录来存放相关资源文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir ~/security-context<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>security-context-pod-demo-1.yaml 内容如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> security<span class="token punctuation">-</span>context<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>ctx<span class="token punctuation">-</span>vol    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>    <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">1000</span>    <span class="token key atrule">runAsGroup</span><span class="token punctuation">:</span> <span class="token number">3000</span>    <span class="token key atrule">fsGroup</span><span class="token punctuation">:</span> <span class="token number">2000</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>ctx<span class="token punctuation">-</span>demo    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"sleep 60m"</span><span class="token punctuation">]</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>ctx<span class="token punctuation">-</span>vol      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /pod/demo    <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>      <span class="token key atrule">allowPrivilegeEscalation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在当前资源清单文件中我们在 Pod 下面添加了 <code>securityContext</code> 字段，其中：</p><ul><li><code>runAsUser</code> 字段指定了该 Pod 中所有容器的进程都以 UID 1000 的身份运行，<code>runAsGroup</code> 字段指定了该 Pod 中所有容器的进程都以 GID 3000 的身份运行<ul><li>如果省略该字段，容器进程的 GID 为 <code>root(0)</code></li><li>容器中创建的文件，其所有者为 userID 1000，groupID 3000</li></ul></li><li><code>fsGroup</code> 字段指定了该 Pod 的 fsGroup 为 2000<ul><li>数据卷 （对应挂载点 <code>/pod/demo</code> 的数据卷为 <code>sec-ctx-demo</code>） 的所有者以及在该数据卷下创建的任何文件，其 GID 都为 2000</li></ul></li></ul><p>下表是我们常用的一些 <code>securityContext</code> 字段设置内容介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220827114703.png"></p><p>直接创建上面的 Pod 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# kubectl apply -f security-context-pod-demo-1.yamlpod/security-context-pod-demo created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行完成后，我们可以验证下容器中的进程运行的 ownership：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# kubectl exec security-context-pod-demo topkubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.Mem: 1805912K used, 2239124K free, 11532K shrd, 2076K buff, 1067660K cachedCPU:  0.0% usr  0.0% sys  0.0% nic  100% idle  0.0% io  0.0% irq  0.0% sirqLoad average: 0.00 0.08 0.08 1/515 13  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND    8     0 1000     R     1312  0.0   1  0.0 top    1     0 1000     S     1300  0.0   1  0.0 sleep 60m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们直接运行一个 <code>top</code> 进程，查看容器中的所有正在执行的进程，我们可以看到 USER ID 都为 1000（<code>runAsUser</code> 指定的），然后查看下挂载的数据卷的 ownership：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# kubectl exec security-context-pod-demo -- ls -la /podtotal 0drwxr-xr-x    3 root     root            18 Aug 28 02:42 .drwxr-xr-x    1 root     root            28 Aug 28 02:42 ..drwxrwsrwx    2 root     2000             6 Aug 28 02:42 demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为上面我们指定了 <code>fsGroup=2000</code>，所以声明挂载的数据卷 <code>/pod/demo</code> 的 GID 也变成了 2000。直接调用容器中的 id 命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# kubectl exec security-context-pod-demo idkubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.uid=1000 gid=3000 groups=2000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以看到 gid 为 3000，与 <code>runAsGroup</code> 字段所指定的一致，如果 <code>runAsGroup</code> 字段被省略，则 gid 取值为 0（即 root），此时容器中的进程将可以操作 root Group 的文件。</p><p>比如我们现在想要去删除容器中的 <code>/tmp</code> 目录就没有权限了，因为该目录的用户和组都是 root，而我们当前要去删除使用的进程的 ID 号就变成了 1000:3000，所以没有权限操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# kubectl exec security-context-pod-demo -- ls -la /tmptotal 0drwxrwxrwt    2 root     root             6 Dec 29  2021 .drwxr-xr-x    1 root     root            28 Aug 28 02:42 ..[root@k8s-master security-context]# kubectl exec security-context-pod-demo -- rm -rf /tmp/rm: can't remove '/tmp': Permission deniedcommand terminated with exit code 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为容器设置-Security-Context"><a href="#为容器设置-Security-Context" class="headerlink" title="为容器设置 Security Context"></a>为容器设置 Security Context</h2><p>除了在 Pod 中可以设置安全上下文之外，我们还可以单独为某个容器设置安全上下文，同样也是通过 <code>securityContext</code> 字段设置，当该字段的配置与 Pod 级别的 securityContext 配置相冲突时，容器级别的配置将覆盖 Pod 级别的配置。容器级别的 securityContext 不影响 Pod 中的数据卷。如下资源清单所示：security-context-pod-demo-2.yaml </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> security<span class="token punctuation">-</span>context<span class="token punctuation">-</span>container<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>    <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">1000</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>ctx<span class="token punctuation">-</span>demo    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"sleep 60m"</span> <span class="token punctuation">]</span>    <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>      <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">2000</span>      <span class="token key atrule">allowPrivilegeEscalation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接创建上面的 Pod 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# kubectl apply -f security-context-pod-demo-2.yaml pod/security-context-container-demo created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样我们直接执行容器中的 <code>top</code> 命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# kubectl exec security-context-container-demo topkubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.Mem: 1711628K used, 2333408K free, 10900K shrd, 2076K buff, 1029436K cachedCPU:  5.0% usr  0.0% sys  0.0% nic 95.0% idle  0.0% io  0.0% irq  0.0% sirqLoad average: 0.00 0.06 0.05 1/449 19  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND    8     0 2000     S     1312  0.0   1  0.0 top   14     0 2000     R     1312  0.0   0  0.0 top    1     0 2000     S     1300  0.0   1  0.0 sleep 60m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器的进程以 UID 2000 的身份运行，该取值由 <code>spec.containers[*].securityContext.runAsUser</code> 容器组中的字段定义。Pod 中定义的 <code>spec.securityContext.runAsUser</code> 取值 1000 被覆盖。</p><h2 id="设置-Linux-Capabilities"><a href="#设置-Linux-Capabilities" class="headerlink" title="设置 Linux Capabilities"></a>设置 Linux Capabilities</h2><p>我们使用 <code>docker run</code> 的时候可以通过 <code>--cap-add</code> 和 <code>--cap-drop</code> 命令来给容器添加 <code>Linux Capabilities</code>。那么在 Kubernetes 下面如何来设置呢？要了解如何设置，首先我们还是需要了解下 <code>Linux Capabilities</code> 是什么？</p><h3 id="Linux-Capabilities"><a href="#Linux-Capabilities" class="headerlink" title="Linux Capabilities"></a>Linux Capabilities</h3><p>要了解 <code>Linux Capabilities</code>，这就得从 Linux 的权限控制发展来说明。在 Linux 2.2 版本之前，当内核对进程进行权限验证的时候，Linux 将进程划分为两类：特权进程（UID=0，也就是超级用户）和非特权进程（UID!=0），特权进程拥有所有的内核权限，而非特权进程则根据进程凭证（effective UID, effective GID，supplementary group 等）进行权限检查。</p><p>比如我们以常用的 <code>passwd</code> 命令为例，修改用户密码需要具有 root 权限，而普通用户是没有这个权限的。但是实际上普通用户又可以修改自己的密码，这是怎么回事呢？在 Linux 的权限控制机制中，有一类比较特殊的权限设置，比如 SUID(Set User ID on execution)，允许用户以可执行文件的 owner 的权限来运行可执行文件。因为程序文件 <code>/bin/passwd</code> 被设置了 <code>SUID</code> 标识，所以普通用户在执行 passwd 命令时，进程是以 passwd 的所有者，也就是 root 用户的身份运行，从而就可以修改密码了。</p><p>但是使用 <code>SUID</code> 却带来了新的安全隐患，当我们运行设置了 <code>SUID</code> 的命令时，通常只是需要很小一部分的特权，但是 <code>SUID</code> 却给了它 root 具有的全部权限，一旦 被设置了 <code>SUID</code> 的命令出现漏洞，是不是就很容易被利用了。</p><p>为此 Linux 引入了 <code>Capabilities</code> 机制来对 root 权限进行了更加细粒度的控制，实现按需进行授权，这样就大大减小了系统的安全隐患。</p><h4 id="什么是-Capabilities"><a href="#什么是-Capabilities" class="headerlink" title="什么是 Capabilities"></a>什么是 Capabilities</h4><p>从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 <code>capabilites</code>。<code>Capabilites</code> 每个单元都可以独立启用和禁用。这样当系统在作权限检查的时候就变成了：<strong>在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作</strong>。比如如果我们要设置系统时间，就得具有 <code>CAP_SYS_TIME</code> 这个 capabilites。下面是从 <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page</a> 中摘取的 capabilites 列表：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220827115800.png"></p><h4 id="如何使用-Capabilities"><a href="#如何使用-Capabilities" class="headerlink" title="如何使用 Capabilities"></a>如何使用 Capabilities</h4><p>我们可以通过 <code>getcap</code> 和 <code>setcap</code> 两条命令来分别查看和设置程序文件的 <code>capabilities</code> 属性。比如当前我们是<code>zhangquan</code> 这个用户，使用 <code>getcap</code> 命令查看 <code>ping</code> 命令目前具有的 <code>capabilities</code>：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[zhangquan@10 ~]$ ll /bin/ping-rwxr-xr-x. 1 root root 66176 8月   4 2017 /bin/ping[zhangquan@10 ~]$ getcap /bin/ping/bin/ping = cap_net_admin,cap_net_raw+p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到具有 <code>cap_net_admin</code> 这个属性，所以我们现在可以执行 <code>ping</code> 命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[zhangquan@10 ~]$ ping www.zhangquan.mePING dendi875.github.io (185.199.111.153) 56(84) bytes of data.64 bytes from cdn-185-199-111-153.github.com (185.199.111.153): icmp_seq=1 ttl=63 time=134 ms64 bytes from cdn-185-199-111-153.github.com (185.199.111.153): icmp_seq=2 ttl=63 time=128 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果我们把命令的 <code>capabilities</code> 属性移除掉：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[zhangquan@10 ~]$ sudo setcap cap_net_admin,cap_net_raw-p /bin/ping[zhangquan@10 ~]$ getcap /bin/ping/bin/ping =<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候我们执行 <code>ping</code> 命令可以发现已经没有权限了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[zhangquan@10 ~]$ ping www.zhangquan.meping: socket: 不允许的操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为 ping 命令在执行时需要访问网络，所需的 <code>capabilities</code> 为 <code>cap_net_admin</code> 和 <code>cap_net_raw</code>，所以我们可以通过 <code>setcap</code> 命令可来添加它们：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[zhangquan@10 ~]$ sudo setcap cap_net_admin,cap_net_raw+p /bin/ping  [zhangquan@10 ~]$ getcap /bin/ping/bin/ping = cap_net_admin,cap_net_raw+p[zhangquan@10 ~]$ ping www.zhangquan.mePING www.zhangquan.me (185.199.111.153) 56(84) bytes of data.64 bytes from 153.111.199.185.in-addr.arpa (185.199.111.153): icmp_seq=1 ttl=63 time=122 ms64 bytes from 153.111.199.185.in-addr.arpa (185.199.111.153): icmp_seq=2 ttl=63 time=124 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令中的 <code>p</code> 表示 <code>Permitted</code> 集合(接下来会介绍)，<code>+</code> 号表示把指定的<code>capabilities</code> 添加到这些集合中，<code>-</code> 号表示从集合中移除。</p><p>对于可执行文件的属性中有三个集合来保存三类 <code>capabilities</code>，它们分别是：</p><ul><li>Permitted：在进程执行时，Permitted 集合中的 capabilites 自动被加入到进程的 Permitted 集合中。</li><li>Inheritable：Inheritable 集合中的 capabilites 会与进程的 Inheritable 集合执行与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。</li><li>Effective：Effective 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。</li></ul><p>对于进程中有五种 <code>capabilities</code> 集合类型，相比文件的 <code>capabilites</code>，进程的 <code>capabilities</code> 多了两个集合，分别是 <code>Bounding</code> 和 <code>Ambient</code>。</p><p>我们可以通过下面的命名来查看当前进程的 <code>capabilities</code> 信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 获取当前 shell 进程的pid[zhangquan@10 ~]$ echo $$1581# 查看当前指定 pid 进程的 capabilities[zhangquan@10 ~]$ cat /proc/1581/status | grep 'Cap'CapInh: 0000000000000000CapPrm: 0000000000000000CapEff: 0000000000000000CapBnd: 0000001fffffffffCapAmb: 0000000000000000# 使用 capsh 命令把它们转义为可读的格式[zhangquan@10 ~]$ capsh --decode=0000001fffffffff0x0000001fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-Container-Capabilities"><a href="#Docker-Container-Capabilities" class="headerlink" title="Docker Container Capabilities"></a>Docker Container Capabilities</h3><p>我们说 Docker 容器本质上就是一个进程，所以理论上容器就会和进程一样会有一些默认的开放权限，默认情况下 Docker 会删除必须的 <code>capabilities</code> 之外的所有 <code>capabilities</code>，因为在容器中我们经常会以 root 用户来运行，使用 <code>capabilities</code> 现在后，容器中的使用的 root 用户权限就比我们平时在宿主机上使用的 root 用户权限要少很多了，这样即使出现了安全漏洞，也很难破坏或者获取宿主机的 root 权限，所以 Docker 支持 <code>Capabilities</code> 对于容器的安全性来说是非常有必要的。</p><p>不过我们在运行容器的时候可以通过指定 <code>--privileded</code> 参数来开启容器的超级权限，这个参数一定要慎用，因为他会获取系统 root 用户所有能力赋值给容器，并且会扫描宿主机的所有设备文件挂载到容器内部，所以是非常危险的操作。</p><p>但是如果你确实需要一些特殊的权限，我们可以通过 <code>--cap-add</code> 和 <code>--cap-drop</code> 这两个参数来动态调整，可以最大限度地保证容器的使用安全。下面表格中列出的 <code>Capabilities</code> 是 Docker 默认给容器添加的，我们可以通过 <code>--cap-drop</code> 去除其中一个或者多个：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220827121751.png"></p><p>下面表格中列出的 <code>Capabilities</code> 是 Docker 默认删除的，我们可以通过<code>--cap-add</code>添加其中一个或者多个：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220827121859.png"></p><blockquote><pre class="line-numbers language-none"><code class="language-none">--cap-add 和 --cap-drop  这两参数都支持 `ALL` 值，比如如果你想让某个容器拥有除了 `MKNOD` 之外的所有内核权限，那么可以执行下面的命令： $ sudo docker run --cap-add=ALL --cap-drop=MKNOD ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>比如现在我们需要修改网络接口数据，默认情况下是没有权限的，因为需要的 <code>NET_ADMIN</code> 这个 <code>Capabilities</code> 默认被移除了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# docker run -it --rm busybox /bin/sh/ # ip link add dummy0 type dummyip: RTNETLINK answers: Operation not permitted/ # <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以在不使用 <code>--privileged</code> 的情况下（不建议）我们可以使用 <code>--cap-add=NET_ADMIN</code> 将这个 <code>Capabilities</code> 添加回来：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]# docker run -it --rm --cap-add=NET_ADMIN busybox /bin/sh/ #  ip link add dummy0 type dummy/ # <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到已经 OK 了。</p><h3 id="Kubernetes-配置-Capabilities"><a href="#Kubernetes-配置-Capabilities" class="headerlink" title="Kubernetes 配置 Capabilities"></a>Kubernetes 配置 Capabilities</h3><p>上面我介绍了在 Docker 容器下如何来配置 <code>Capabilities</code>，在 Kubernetes 中也可以很方便的来定义，我们只需要添加到 Pod 定义的 <code>spec.containers.sercurityContext.capabilities</code>中即可，也可以进行 <code>add</code> 和 <code>drop</code> 配置，同样上面的示例，我们要给 busybox 容器添加 <code>NET_ADMIN</code> 这个 <code>Capabilities</code>，对应的 YAML 文件可以这样定义：(cpb-demo.yaml)</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> cpb<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cpb    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">args</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> sleep    <span class="token punctuation">-</span> <span class="token string">"3600"</span>    <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>      <span class="token key atrule">capabilities</span><span class="token punctuation">:</span>        <span class="token key atrule">add</span><span class="token punctuation">:</span> <span class="token comment"># 添加</span>        <span class="token punctuation">-</span> NET_ADMIN        <span class="token key atrule">drop</span><span class="token punctuation">:</span>  <span class="token comment"># 删除</span>        <span class="token punctuation">-</span> KILL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在 <code>securityContext</code> 下面添加了 <code>capabilities</code> 字段，其中添加了 <code>NET_ADMIN</code> 并且删除了 <code>KILL</code>这个默认的容器 <code>Capabilities</code>，这样我们就可以在 Pod 中修改网络接口数据了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master security-context]#  kubectl apply -f cpb-demo.yamlpod/cpb-demo created[root@k8s-master security-context]#  kubectl exec -it  cpb-demo -- /bin/sh/ # ip link add dummy0 type dummy/ # <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Kubernetes 中通过 <code>sercurityContext.capabilities</code> 进行配置容器的 <code>Capabilities</code>，当然最终还是通过 Docker 的 <code>libcontainer</code> 去借助 <code>Linux kernel capabilities</code> 实现的权限管理。</p><h2 id="为容器设置-SELinux-标签"><a href="#为容器设置-SELinux-标签" class="headerlink" title="为容器设置 SELinux 标签"></a>为容器设置 <code>SELinux</code> 标签</h2><p><code>SELinux</code> (Security-Enhanced Linux) 是一种强制访问控制（mandatory access control）的实现。它的作法是以最小权限原则（principle of least privilege）为基础，在 Linux 核心中使用 Linux 安全模块（Linux Security Modules）。Pod 或容器定义的 securityContext 中 <code>seLinuxOptions</code> 字段是一个 <a href="https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#selinuxoptions-v1-core">SELinuxOptions 对象</a>，该字段可用于为容器指定 <code>SELinux</code> 标签。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">securityContext</span><span class="token punctuation">:</span>  <span class="token key atrule">seLinuxOptions</span><span class="token punctuation">:</span>    <span class="token key atrule">level</span><span class="token punctuation">:</span> <span class="token string">"s0:c123,c456"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">https://kubernetes.io/docs/tasks/configure-pod-container/security-context/</a></li><li><a href="https://www.qikqiak.com/k8strain/security/security-context/">https://www.qikqiak.com/k8strain/security/security-context/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes RBAC 权限控制</title>
      <link href="/2022/08/25/kubernetes-rbac-quan-xian-kong-zhi/"/>
      <url>/2022/08/25/kubernetes-rbac-quan-xian-kong-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-RBAC-权限控制"><a href="#Kubernetes-RBAC-权限控制" class="headerlink" title="Kubernetes RBAC 权限控制"></a>Kubernetes RBAC 权限控制</h1><p>基于角色的访问控制（Role-Based Access Control，即”RBAC”）使用 <code>rbac.authorization.k8s.io</code> API Group 实现授权决策，允许管理员通过 Kubernetes API 动态配置策略。</p><p>要启用 RBAC，需要在 kube-apiserver 中添加参数<code>--authorization-mode=RBAC</code>，如果使用的kubeadm 安装的集群那么是默认开启了 <code>RBAC</code> 的，可以通过查看 Master 节点上 apiserver 的静态 Pod 定义文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# cat /etc/kubernetes/manifests/kube-apiserver.yaml ......    - --authorization-mode=Node,RBAC......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="API-对象"><a href="#API-对象" class="headerlink" title="API 对象"></a>API 对象</h2><p>我们知道，在 Kubernetes 集群中，Kubernetes 对象是我们持久化的实体，就是最终存入 etcd 中的数据，集群中通过这些实体来表示整个集群的状态。一般我们都直接编写 YAML 文件，通过 kubectl 来提交的资源清单文件，然后创建的对应的资源对象，那么它究竟是如何将我们的 YAML 文件转换成集群中的一个 API 对象的呢？</p><p>这个就需要去了解下<strong>声明式 API</strong>的设计，Kubernetes API 是一个以 JSON 为主要序列化方式的 HTTP 服务，除此之外也支持 Protocol Buffers 序列化方式，主要用于集群内部组件间的通信。为了可扩展性，Kubernetes 在不同的 API 路径（比如<code>/api/v1</code> 或者 <code>/apis/batch</code>）下面支持了多个 API 版本，不同的 API 版本意味着不同级别的稳定性和支持：</p><ul><li>Alpha 级别，例如 <code>v1alpha1</code> 默认情况下是被禁用的，可以随时删除对功能的支持，所以要慎用</li><li>Beta 级别，例如 <code>v2beta1</code> 默认情况下是启用的，表示代码已经经过了很好的测试，但是对象的语义可能会在随后的版本中以不兼容的方式更改</li><li>稳定级别，比如 <code>v1</code> 表示已经是稳定版本了，也会出现在后续的很多版本中。</li></ul><p>在 Kubernetes 集群中，一个 API 对象在 Etcd 里的完整资源路径，是由：<code>Group（API 组）</code>、<code>Version（API 版本）</code>和 <code>Resource（API 资源类型）</code>三个部分组成的。通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-api-tree.png"></p><p>从上图中我们也可以看出 Kubernetes 的 API 对象的组织方式，在顶层，我们可以看到有一个核心组<code>/api/v1</code> 和命名组（路径 <code>/apis/$NAME/$VERSION</code>）和系统范围内的实体，比如 <code>/metrics</code>。我们也可以用下面的命令来查看集群中的 API 组织形式：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get --raw /{  "paths": [    "/.well-known/openid-configuration",    "/api",    "/api/v1",    "/apis",    "/apis/",    "/apis/admissionregistration.k8s.io",    "/apis/admissionregistration.k8s.io/v1",    "/apis/admissionregistration.k8s.io/v1beta1",    "/apis/apiextensions.k8s.io",    "/apis/apiextensions.k8s.io/v1",    "/apis/apiextensions.k8s.io/v1beta1",    "/apis/apiregistration.k8s.io",    "/apis/apiregistration.k8s.io/v1",    "/apis/apiregistration.k8s.io/v1beta1",    "/apis/apps",    "/apis/apps/v1",    "/apis/authentication.k8s.io",    "/apis/authentication.k8s.io/v1",    "/apis/authentication.k8s.io/v1beta1",    "/apis/authorization.k8s.io",    "/apis/authorization.k8s.io/v1",    "/apis/authorization.k8s.io/v1beta1",    "/apis/autoscaling",    "/apis/autoscaling/v1",    "/apis/autoscaling/v2beta1",    "/apis/autoscaling/v2beta2",    "/apis/batch",    "/apis/batch/v1",    "/apis/batch/v1beta1",    "/apis/certificates.k8s.io",    "/apis/certificates.k8s.io/v1",    "/apis/certificates.k8s.io/v1beta1",    "/apis/coordination.k8s.io",    "/apis/coordination.k8s.io/v1",    "/apis/coordination.k8s.io/v1beta1",    "/apis/crd.projectcalico.org",    "/apis/crd.projectcalico.org/v1",    "/apis/discovery.k8s.io",    "/apis/discovery.k8s.io/v1beta1",    "/apis/events.k8s.io",    "/apis/events.k8s.io/v1",    "/apis/events.k8s.io/v1beta1",    "/apis/extensions",    "/apis/extensions/v1beta1",    "/apis/flowcontrol.apiserver.k8s.io",    "/apis/flowcontrol.apiserver.k8s.io/v1beta1",    "/apis/networking.k8s.io",    "/apis/networking.k8s.io/v1",    "/apis/networking.k8s.io/v1beta1",    "/apis/node.k8s.io",    "/apis/node.k8s.io/v1",    "/apis/node.k8s.io/v1beta1",    "/apis/policy",    "/apis/policy/v1beta1",    "/apis/rbac.authorization.k8s.io",    "/apis/rbac.authorization.k8s.io/v1",    "/apis/rbac.authorization.k8s.io/v1beta1",    "/apis/scheduling.k8s.io",    "/apis/scheduling.k8s.io/v1",    "/apis/scheduling.k8s.io/v1beta1",    "/apis/storage.k8s.io",    "/apis/storage.k8s.io/v1",    "/apis/storage.k8s.io/v1beta1",    "/healthz",    "/healthz/autoregister-completion",    "/healthz/etcd",    "/healthz/log",    "/healthz/ping",    "/healthz/poststarthook/aggregator-reload-proxy-client-cert",    "/healthz/poststarthook/apiservice-openapi-controller",    "/healthz/poststarthook/apiservice-registration-controller",    "/healthz/poststarthook/apiservice-status-available-controller",    "/healthz/poststarthook/bootstrap-controller",    "/healthz/poststarthook/crd-informer-synced",    "/healthz/poststarthook/generic-apiserver-start-informers",    "/healthz/poststarthook/kube-apiserver-autoregistration",    "/healthz/poststarthook/priority-and-fairness-config-consumer",    "/healthz/poststarthook/priority-and-fairness-config-producer",    "/healthz/poststarthook/priority-and-fairness-filter",    "/healthz/poststarthook/rbac/bootstrap-roles",    "/healthz/poststarthook/scheduling/bootstrap-system-priority-classes",    "/healthz/poststarthook/start-apiextensions-controllers",    "/healthz/poststarthook/start-apiextensions-informers",    "/healthz/poststarthook/start-cluster-authentication-info-controller",    "/healthz/poststarthook/start-kube-aggregator-informers",    "/healthz/poststarthook/start-kube-apiserver-admission-initializer",    "/livez",    "/livez/autoregister-completion",    "/livez/etcd",    "/livez/log",    "/livez/ping",    "/livez/poststarthook/aggregator-reload-proxy-client-cert",    "/livez/poststarthook/apiservice-openapi-controller",    "/livez/poststarthook/apiservice-registration-controller",    "/livez/poststarthook/apiservice-status-available-controller",    "/livez/poststarthook/bootstrap-controller",    "/livez/poststarthook/crd-informer-synced",    "/livez/poststarthook/generic-apiserver-start-informers",    "/livez/poststarthook/kube-apiserver-autoregistration",    "/livez/poststarthook/priority-and-fairness-config-consumer",    "/livez/poststarthook/priority-and-fairness-config-producer",    "/livez/poststarthook/priority-and-fairness-filter",    "/livez/poststarthook/rbac/bootstrap-roles",    "/livez/poststarthook/scheduling/bootstrap-system-priority-classes",    "/livez/poststarthook/start-apiextensions-controllers",    "/livez/poststarthook/start-apiextensions-informers",    "/livez/poststarthook/start-cluster-authentication-info-controller",    "/livez/poststarthook/start-kube-aggregator-informers",    "/livez/poststarthook/start-kube-apiserver-admission-initializer",    "/logs",    "/metrics",    "/openapi/v2",    "/openid/v1/jwks",    "/readyz",    "/readyz/autoregister-completion",    "/readyz/etcd",    "/readyz/informer-sync",    "/readyz/log",    "/readyz/ping",    "/readyz/poststarthook/aggregator-reload-proxy-client-cert",    "/readyz/poststarthook/apiservice-openapi-controller",    "/readyz/poststarthook/apiservice-registration-controller",    "/readyz/poststarthook/apiservice-status-available-controller",    "/readyz/poststarthook/bootstrap-controller",    "/readyz/poststarthook/crd-informer-synced",    "/readyz/poststarthook/generic-apiserver-start-informers",    "/readyz/poststarthook/kube-apiserver-autoregistration",    "/readyz/poststarthook/priority-and-fairness-config-consumer",    "/readyz/poststarthook/priority-and-fairness-config-producer",    "/readyz/poststarthook/priority-and-fairness-filter",    "/readyz/poststarthook/rbac/bootstrap-roles",    "/readyz/poststarthook/scheduling/bootstrap-system-priority-classes",    "/readyz/poststarthook/start-apiextensions-controllers",    "/readyz/poststarthook/start-apiextensions-informers",    "/readyz/poststarthook/start-cluster-authentication-info-controller",    "/readyz/poststarthook/start-kube-aggregator-informers",    "/readyz/poststarthook/start-kube-apiserver-admission-initializer",    "/readyz/shutdown",    "/version"  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如我们来查看批处理这个操作，在我们当前这个版本中存在两个版本的操作：<code>/apis/batch/v1</code> 和 <code>/apis/batch/v1beta1</code>，分别暴露了可以查询和操作的不同实体集合，同样我们还是可以通过 kubectl 来查询对应对象下面的数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get --raw /apis/batch/v1 | python -m json.tool{    "apiVersion": "v1",    "groupVersion": "batch/v1",    "kind": "APIResourceList",    "resources": [        {            "categories": [                "all"            ],            "kind": "Job",            "name": "jobs",            "namespaced": true,            "singularName": "",            "storageVersionHash": "mudhfqk/qZY=",            "verbs": [                "create",                "delete",                "deletecollection",                "get",                "list",                "patch",                "update",                "watch"            ]        },        {            "kind": "Job",            "name": "jobs/status",            "namespaced": true,            "singularName": "",            "verbs": [                "get",                "patch",                "update"            ]        }    ]}[root@k8s-master ~]# kubectl get --raw /apis/batch/v1beta1 | python -m json.tool{    "apiVersion": "v1",    "groupVersion": "batch/v1beta1",    "kind": "APIResourceList",    "resources": [        {            "categories": [                "all"            ],            "kind": "CronJob",            "name": "cronjobs",            "namespaced": true,            "shortNames": [                "cj"            ],            "singularName": "",            "storageVersionHash": "h/JlFAZkyyY=",            "verbs": [                "create",                "delete",                "deletecollection",                "get",                "list",                "patch",                "update",                "watch"            ]        },        {            "kind": "CronJob",            "name": "cronjobs/status",            "namespaced": true,            "singularName": "",            "verbs": [                "get",                "patch",                "update"            ]        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个操作和我们平时操作 HTTP 服务的方式不太一样，这里我们可以通过 <code>kubectl proxy</code> 命令来开启对 apiserver 的访问：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl proxyStarting to serve on 127.0.0.1:8001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后重新开启一个新的终端，我们可以通过如下方式来访问批处理的 API 服务：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# curl http://127.0.0.1:8001/apis/batch/v1{  "kind": "APIResourceList",  "apiVersion": "v1",  "groupVersion": "batch/v1",  "resources": [    {      "name": "jobs",      "singularName": "",      "namespaced": true,      "kind": "Job",      "verbs": [        "create",        "delete",        "deletecollection",        "get",        "list",        "patch",        "update",        "watch"      ],      "categories": [        "all"      ],      "storageVersionHash": "mudhfqk/qZY="    },    {      "name": "jobs/status",      "singularName": "",      "namespaced": true,      "kind": "Job",      "verbs": [        "get",        "patch",        "update"      ]    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样也可以去访问另外一个版本的对象数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# curl http://127.0.0.1:8001/apis/batch/v1beta1......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通常，Kubernetes API 支持通过标准 HTTP <code>POST</code>、<code>PUT</code>、<code>DELETE</code> 和 <code>GET</code> 在指定 PATH 路径上创建、更新、删除和检索操作，并使用 JSON 作为默认的数据交互格式。</p><p>比如现在我们要创建一个 Deployment 对象，那么我们的 YAML 文件的声明就需要这么写：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-api-1.png"></p><p>其中 <code>apps</code> 就是它的组（Group），<code>v1</code>就是它的版本（Version），<code>Deployment</code> 就是这个 API 对象的资源类型（Resource）。API Group、Version 和 Resource就唯一定义了一个 HTTP 路径，然后在 kube-apiserver 端对这个 url 进行了监听，然后把对应的请求传递给了对应的控制器进行处理而已，当然在 Kuberentes 中的实现过程是非常复杂的。</p><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p>Kubernetes 所有资源对象都是模型化的 API 对象，允许执行 <code>CRUD(Create、Read、Update、Delete)</code> 操作(也就是我们常说的增、删、改、查操作)，比如下面的这些资源：</p><ul><li>Pods</li><li>ConfigMaps</li><li>Deployments</li><li>Nodes</li><li>Secrets</li><li>Namespaces</li><li>……</li></ul><p>对于上面这些资源对象的可能存在的操作有：</p><ul><li>create</li><li>get</li><li>delete</li><li>list</li><li>update</li><li>edit</li><li>watch</li><li>exec</li><li>patch</li></ul><p>在更上层，这些资源和 API Group 进行关联，比如 Pods 属于 Core API Group，而 Deployements 属于 apps API Group。</p><p>现在我们要在 Kubernetes 中通过 RBAC 来对资源进行权限管理，除了上面的这些资源和操作以外，我们还需要了解另外几个概念：</p><ul><li><code>Rule</code>：规则，规则是一组属于不同 API Group 资源上的一组操作的集合</li><li><code>Role</code> 和 <code>ClusterRole</code>：角色和集群角色，这两个对象都包含上面的 Rules 元素，二者的区别在于，在 Role 中，定义的规则只适用于单个命名空间，也就是和 namespace 关联的，而 ClusterRole 是集群范围内的，因此定义的规则不受命名空间的约束。另外 Role 和 ClusterRole 在Kubernetes 中都被定义为集群内部的 API 资源，和我们前面学习过的 Pod、Deployment 这些对象类似，都是我们集群的资源对象，所以同样的可以使用 YAML 文件来描述，用 kubectl 工具来管理</li><li><code>Subject</code>：主题，对应集群中尝试操作的对象，集群中定义了3种类型的主题资源：<ul><li><code>User Account</code>：用户，这是有外部独立服务进行管理的，管理员进行私钥的分配，用户可以使用 KeyStone 或者 Goolge 帐号，甚至一个用户名和密码的文件列表也可以。对于用户的管理集群内部没有一个关联的资源对象，所以用户不能通过集群内部的 API 来进行管理</li><li><code>Group</code>：组，这是用来关联多个账户的，集群中有一些默认创建的组，比如 cluster-admin</li><li><code>Service Account</code>：服务帐号也是k8s集群内部使用的用户，通过 Kubernetes API 来管理的一些用户帐号，和 namespace 进行关联的，适用于集群内部运行的应用程序，需要通过 API 来完成权限认证，所以在集群内部进行权限操作，我们都需要使用到 ServiceAccount</li></ul></li><li><code>RoleBinding</code> 和 <code>ClusterRoleBinding</code>：角色绑定和集群角色绑定，简单来说就是把声明的 Subject 和我们的 Role 进行绑定的过程（给某个用户绑定上操作的权限），二者的区别也是作用范围的区别：RoleBinding 只会影响到当前 namespace 下面的资源操作权限，而 ClusterRoleBinding 会影响到所有的 namespace。</li></ul><h3 id="只能访问某个-namespace-的普通用户"><a href="#只能访问某个-namespace-的普通用户" class="headerlink" title="只能访问某个 namespace 的普通用户"></a>只能访问某个 namespace 的普通用户</h3><p>我们想要创建一个 User Account，只能访问 kube-system 这个命名空间，对应的用户信息如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">username</span><span class="token punctuation">:</span> zq<span class="token key atrule">group</span><span class="token punctuation">:</span> zqgroup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="创建一个普通用户（User-Account）"><a href="#创建一个普通用户（User-Account）" class="headerlink" title="创建一个普通用户（User Account）"></a>创建一个普通用户（User Account）</h4><p>不过要创建一个用户帐号的话也是挺简单的，利用管理员分配给你的一个私钥就可以创建了，这个我们可以参考官方文档中的方法，这里我们来使用 <code>OpenSSL</code> 证书来创建一个 User，当然我们也可以使用更简单的 <code>cfssl</code>工具来创建：</p><p>首先创建一个文件夹存放私钥和证书：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# mkdir ~/certs <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>给用户 zq 创建一个私钥，命名成 <code>zq.key</code>：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master certs]# openssl genrsa -out zq.key 2048Generating RSA private key, 2048 bit long modulus.....................................+++.......................................................................+++e is 65537 (0x10001)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用我们刚刚创建的私钥创建一个证书签名请求文件：<code>cnych.csr</code>，要注意需要确保在<code>-subj</code>参数中指定用户名和组(CN表示用户名，O表示组)：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master certs]#  openssl req -new -key zq.key -out zq.csr -subj "/CN=zq/O=zqgroup"[root@k8s-master certs]# lszq.csr  zq.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后找到我们的 Kubernetes 集群的 <code>CA</code> 证书，我们使用的是 kubeadm 安装的集群，CA 相关证书位于 <code>/etc/kubernetes/pki/</code> 目录下面，如果你是二进制方式搭建的，你应该在最开始搭建集群的时候就已经指定好了 CA 的目录，我们会利用该目录下面的 <code>ca.crt</code> 和 <code>ca.key</code>两个文件来批准上面的证书请求。生成最终的证书文件，我们这里设置证书的有效期为 10 年：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master certs]# ls /etc/kubernetes/pki/apiserver.crt              apiserver-etcd-client.key  apiserver-kubelet-client.crt  ca.crt  etcd                front-proxy-ca.key      front-proxy-client.key  sa.pubapiserver-etcd-client.crt  apiserver.key              apiserver-kubelet-client.key  ca.key  front-proxy-ca.crt  front-proxy-client.crt  sa.key[root@k8s-master certs]# openssl x509 -req -in zq.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out zq.crt -days 3650Signature oksubject=/CN=zq/O=zqgroupGetting CA Private Key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在查看我们当前文件夹下面是否生成了一个证书文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master certs]# lszq.crt  zq.csr  zq.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在我们可以使用刚刚创建的证书文件和私钥文件在集群中创建新的<strong>凭证</strong>和<strong>上下文(Context)</strong>:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master certs]# kubectl config set-credentials zq --client-certificate=zq.crt --client-key=zq.keyUser "zq" set.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以看到一个用户 <code>zq</code> 创建了，然后为这个用户设置新的 Context，我们这里指定特定的一个 namespace：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master certs]# kubectl config set-context zq-context --cluster=kubernetes --namespace=kube-system --user=zqContext "zq-context" created.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到这里，我们的用户 <code>zq</code> 就已经创建成功了，现在我们使用当前的这个配置文件来操作 kubectl 命令的时候，应该会出现错误，因为我们还没有为该用户定义任何操作的权限呢：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 使用默认认的 context[root@k8s-master certs]# kubectl get podsNAME          READY   STATUS             RESTARTS   AGEnginx-sa      1/1     Running            1          17hprivate-php   0/1     CrashLoopBackOff   23         2d20hredis         1/1     Running            4          2d22hsecret-pod3   1/1     Running            3          2d21hsecret1-pod   0/1     CrashLoopBackOff   42         2d22hsecret2-pod   0/1     CrashLoopBackOff   41         2d22htestcm1-pod   0/1     CrashLoopBackOff   57         2d23htestcm2-pod   0/1     CrashLoopBackOff   55         2d23h# 使用我们自己创建的 context[root@k8s-master certs]# kubectl get pods --context=zq-contextError from server (Forbidden): pods is forbidden: User "zq" cannot list resource "pods" in API group "" in the namespace "kube-system"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建角色（Role）"><a href="#创建角色（Role）" class="headerlink" title="创建角色（Role）"></a>创建角色（Role）</h4><p>首先创建一个文件夹来存放我们资源文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master certs]# mkdir ~/rbactest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户创建完成后，接下来就需要给该用户添加操作权限，我们来定义一个 YAML 文件，创建一个允许用户操作 Deployment、Pod、ReplicaSets 的角色，如下定义：<em>zq-role.yaml</em></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>role  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"apps"</span><span class="token punctuation">]</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"deployments"</span><span class="token punctuation">,</span> <span class="token string">"replicasets"</span><span class="token punctuation">,</span> <span class="token string">"pods"</span><span class="token punctuation">]</span>  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">,</span> <span class="token string">"delete"</span><span class="token punctuation">]</span> <span class="token comment"># 也可以使用['*']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 Pod 属于 <code>core</code> 这个 API Group，在 YAML 中用空字符就可以，而 Deployment 和 ReplicaSet 现在都属于 <code>apps</code> 这个 API Group（如果不知道则可以用 <code>kubectl explain</code> 命令查看），所以 <code>rules</code> 下面的 <code>apiGroups</code> 就综合了这几个资源的 API Group：[“”, “apps”]，其中<code>verbs</code>就是我们上面提到的可以对这些资源对象执行的操作，我们这里需要所有的操作方法，所以我们也可以使用[‘*’]来代替。然后直接创建这个 Role：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl create -f zq-role.yamlrole.rbac.authorization.k8s.io/zq-role created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看我们创建的 Role：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看 kube-system 命名空间下的所有 Role[root@k8s-master rbactest]# kubectl get role -n kube-systemNAME                                             CREATED ATextension-apiserver-authentication-reader        2022-08-13T11:17:28Zkube-proxy                                       2022-08-13T11:17:30Zkubeadm:kubelet-config-1.20                      2022-08-13T11:17:28Zkubeadm:nodes-kubeadm-config                     2022-08-13T11:17:28Zsystem::leader-locking-kube-controller-manager   2022-08-13T11:17:28Zsystem::leader-locking-kube-scheduler            2022-08-13T11:17:28Zsystem:controller:bootstrap-signer               2022-08-13T11:17:28Zsystem:controller:cloud-provider                 2022-08-13T11:17:28Zsystem:controller:token-cleaner                  2022-08-13T11:17:28Zzq-role                                          2022-08-25T06:31:25Z# 查看 zq-role 这个 Role 的详细信息[root@k8s-master rbactest]# kubectl get role zq-role -n kube-system -o yamlapiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata:  creationTimestamp: "2022-08-25T06:31:25Z"  managedFields:  - apiVersion: rbac.authorization.k8s.io/v1    fieldsType: FieldsV1    fieldsV1:      f:rules: {}    manager: kubectl-create    operation: Update    time: "2022-08-25T06:31:25Z"  name: zq-role  namespace: kube-system  resourceVersion: "103263"  uid: 1e8f3b6d-ea9e-4cae-bfc7-b42069789244rules:- apiGroups:  - ""  - apps  resources:  - deployments  - replicasets  - pods  verbs:  - get  - list  - watch  - create  - update  - patch  - delete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里我们没有使用上面的 <code>zq-context</code> 这个上下文，因为暂时还没有权限。</p><h4 id="创建角色权限绑定（RoleBinding）"><a href="#创建角色权限绑定（RoleBinding）" class="headerlink" title="创建角色权限绑定（RoleBinding）"></a>创建角色权限绑定（RoleBinding）</h4><p>Role 创建完成了，但是很明显现在我们这个 <code>Role</code> 和我们的用户 <code>zq</code> 还没有任何关系，这里就需要创建一个 <code>RoleBinding</code> 对象，在 kube-system 这个命名空间下面将上面的 <code>zq-role</code>角色和用户 <code>zq</code> 进行绑定：zq-rolebinding.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>rolebinding  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">subjects</span><span class="token punctuation">:</span> <span class="token comment"># 声明用户</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token key atrule">roleRef</span><span class="token punctuation">:</span> <span class="token comment"># 这用户分配角色</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>role  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token comment"># 留空字符串也可以，则使用当前的apiGroup</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 YAML 文件中我们看到了 <code>subjects</code> 字段，这里就是我们上面提到的用来尝试操作集群的对象，这里对应上面的 <code>User</code> 帐号 <code>zq</code>，使用kubectl 创建上面的资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]#  kubectl create -f zq-rolebinding.yamlrolebinding.rbac.authorization.k8s.io/zq-rolebinding created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看我们创建的 RoleBinding：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl get rolebindingNo resources found in default namespace.# 查看 kube-system 命名空间下所的有 RoleBinding[root@k8s-master rbactest]# kubectl get rolebinding -n kube-systemNAME                                                ROLE                                                  AGEkube-proxy                                          Role/kube-proxy                                       11dkubeadm:kubelet-config-1.20                         Role/kubeadm:kubelet-config-1.20                      11dkubeadm:nodes-kubeadm-config                        Role/kubeadm:nodes-kubeadm-config                     11dsystem::extension-apiserver-authentication-reader   Role/extension-apiserver-authentication-reader        11dsystem::leader-locking-kube-controller-manager      Role/system::leader-locking-kube-controller-manager   11dsystem::leader-locking-kube-scheduler               Role/system::leader-locking-kube-scheduler            11dsystem:controller:bootstrap-signer                  Role/system:controller:bootstrap-signer               11dsystem:controller:cloud-provider                    Role/system:controller:cloud-provider                 11dsystem:controller:token-cleaner                     Role/system:controller:token-cleaner                  11dzq-rolebinding                                      Role/zq-role                                          77s# 我们查看一个系统自带的 rolebinding[root@k8s-master rbactest]# kubectl get rolebinding system::leader-locking-kube-controller-manager -n kube-system -o yamlapiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata:  annotations:    rbac.authorization.kubernetes.io/autoupdate: "true"  creationTimestamp: "2022-08-13T11:17:28Z"  labels:    kubernetes.io/bootstrapping: rbac-defaults  managedFields:  - apiVersion: rbac.authorization.k8s.io/v1    fieldsType: FieldsV1    fieldsV1:      f:metadata:        f:annotations:          .: {}          f:rbac.authorization.kubernetes.io/autoupdate: {}        f:labels:          .: {}          f:kubernetes.io/bootstrapping: {}      f:roleRef:        f:apiGroup: {}        f:kind: {}        f:name: {}      f:subjects: {}    manager: kube-apiserver    operation: Update    time: "2022-08-13T11:17:28Z"  name: system::leader-locking-kube-controller-manager  namespace: kube-system  resourceVersion: "196"  uid: 7fe913a2-ee8d-47f0-9c90-35f661a4977aroleRef:  apiGroup: rbac.authorization.k8s.io  kind: Role  name: system::leader-locking-kube-controller-managersubjects:- apiGroup: rbac.authorization.k8s.io  kind: User  name: system:kube-controller-manager- kind: ServiceAccount  name: kube-controller-manager  namespace: kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h4><p>现在我们应该可以上面的 <code>zq-context</code> 上下文来操作集群了：</p><pre class="line-numbers language-none"><code class="language-none">[root@k8s-master rbactest]# kubectl get pods --context=zq-contextNAME                                       READY   STATUS    RESTARTS   AGEcalico-kube-controllers-5bb48c55fd-ghkdz   1/1     Running   9          11dcalico-node-6vwgq                          1/1     Running   9          11dcalico-node-rnwvk                          1/1     Running   9          11dcalico-node-wz5r2                          1/1     Running   10         11dcoredns-5897cd56c4-kqfn2                   1/1     Running   9          11dcoredns-5897cd56c4-wcgdh                   1/1     Running   9          11detcd-k8s-master                            1/1     Running   9          11dkube-apiserver-k8s-master                  1/1     Running   10         11dkube-controller-manager-k8s-master         1/1     Running   9          11dkube-proxy-jlmvb                           1/1     Running   9          11dkube-proxy-rnt4v                           1/1     Running   9          11dkube-proxy-vpbsl                           1/1     Running   10         11dkube-scheduler-k8s-master                  1/1     Running   9          11d[root@k8s-master rbactest]# kubectl get pods  -n kube-systemNAME                                       READY   STATUS    RESTARTS   AGEcalico-kube-controllers-5bb48c55fd-ghkdz   1/1     Running   9          11dcalico-node-6vwgq                          1/1     Running   9          11dcalico-node-rnwvk                          1/1     Running   9          11dcalico-node-wz5r2                          1/1     Running   10         11dcoredns-5897cd56c4-kqfn2                   1/1     Running   9          11dcoredns-5897cd56c4-wcgdh                   1/1     Running   9          11detcd-k8s-master                            1/1     Running   9          11dkube-apiserver-k8s-master                  1/1     Running   10         11dkube-controller-manager-k8s-master         1/1     Running   9          11dkube-proxy-jlmvb                           1/1     Running   9          11dkube-proxy-rnt4v                           1/1     Running   9          11dkube-proxy-vpbsl                           1/1     Running   10         11dkube-scheduler-k8s-master                  1/1     Running   9          11d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到我们使用 kubectl 的使用并没有指定 namespace，这是因为我们我们上面创建<code>zq-context</code>这个 Context 的时候就绑定在了 kube-system 这个命名空间下面，所以上面输出结果是一样的，如果我们在后面加上一个<code>-n default</code>试看看呢？</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl --context=zq-context get pods --namespace=defaultError from server (Forbidden): pods is forbidden: User "zq" cannot list resource "pods" in API group "" in the namespace "default"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果去获取其他的资源对象呢：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]#  kubectl --context=zq-context get svcError from server (Forbidden): services is forbidden: User "zq" cannot list resource "services" in API group "" in the namespace "kube-system"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以看到没有权限获取，因为我们并没有为当前操作用户指定其他对象资源的访问权限，是符合我们的预期的。这样我们就创建了一个只有单个命名空间访问权限的普通 User 。</p><h3 id="只能访问某个-namespace-的-ServiceAccount"><a href="#只能访问某个-namespace-的-ServiceAccount" class="headerlink" title="只能访问某个 namespace 的 ServiceAccount"></a>只能访问某个 namespace 的 ServiceAccount</h3><p>上面我们创建了一个只能访问某个命名空间下面的<strong>普通用户</strong>，我们前面也提到过 <code>subjects</code> 下面还有一种类型的主题资源：<code>ServiceAccount</code>，现在我们来创建一个集群内部的用户只能操作 kube-system 这个命名空间下面的 pods 和 deployments</p><p>我们把下面所有的资源文件放到  <code>/root/rbactest</code> 下</p><h4 id="创建一个集群内部使用的用户（ServiceAccount）"><a href="#创建一个集群内部使用的用户（ServiceAccount）" class="headerlink" title="创建一个集群内部使用的用户（ServiceAccount）"></a>创建一个集群内部使用的用户（ServiceAccount）</h4><ul><li><p>准备 zq-sa.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl create -f zq-sa.yaml serviceaccount/zq-sa created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl get sa -n kube-system | grep zq-sazq-sa                                1         53s# 获取 zq-sa 这个 ServiceAccount 详细信息[root@k8s-master rbactest]# kubectl get sa zq-sa -n kube-system -o yamlapiVersion: v1kind: ServiceAccountmetadata:  creationTimestamp: "2022-08-25T08:03:30Z"  name: zq-sa  namespace: kube-system  resourceVersion: "112076"  uid: 2f89ba9a-4509-4350-a543-5d321813c737secrets:- name: zq-sa-token-rcswr# 获取 zq-sa 这个 ServiceAccount 关联的 secret[root@k8s-master rbactest]# kubectl get secret zq-sa-token-rcswr -n kube-system -o yaml apiVersion: v1data:  ca.crt: -  namespace: a3ViZS1zeXN0ZW0=  token: xxxxxxxxkind: Secretmetadata:  annotations:    kubernetes.io/service-account.name: zq-sa    kubernetes.io/service-account.uid: 2f89ba9a-4509-4350-a543-5d321813c737  creationTimestamp: "2022-08-25T08:03:30Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:ca.crt: {}        f:namespace: {}        f:token: {}      f:metadata:        f:annotations:          .: {}          f:kubernetes.io/service-account.name: {}          f:kubernetes.io/service-account.uid: {}      f:type: {}    manager: kube-controller-manager    operation: Update    time: "2022-08-25T08:03:30Z"  name: zq-sa-token-rcswr  namespace: kube-system  resourceVersion: "112075"  uid: 728d0487-00d9-422e-abad-8693fa8a4aa5type: kubernetes.io/service-account-token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="创建角色（Role）-1"><a href="#创建角色（Role）-1" class="headerlink" title="创建角色（Role）"></a>创建角色（Role）</h4><ul><li><p>准备 zq-sa-role.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>role  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"pods"</span><span class="token punctuation">]</span>  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">]</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"apps"</span><span class="token punctuation">]</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"deployments"</span><span class="token punctuation">]</span>  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> <span class="token string">"watch"</span><span class="token punctuation">,</span> <span class="token string">"create"</span><span class="token punctuation">,</span> <span class="token string">"update"</span><span class="token punctuation">,</span> <span class="token string">"patch"</span><span class="token punctuation">,</span> <span class="token string">"delete"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建Role对象</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl create -f zq-sa-role.yaml role.rbac.authorization.k8s.io/zq-sa-role created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl get role -n kube-system | grep zq-sa-rolezq-sa-role                                       2022-08-25T08:08:24Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="创建角色权限绑定（RoleBinding）-1"><a href="#创建角色权限绑定（RoleBinding）-1" class="headerlink" title="创建角色权限绑定（RoleBinding）"></a>创建角色权限绑定（RoleBinding）</h4><p>然后创建一个 <code>RoleBinding</code> 对象，将上面的 用户<code>zq-sa</code> 和角色 zq-sa-role 进行绑定：</p><ul><li><p>准备 zq-sa-rolebinding.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>rolebinding  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">roleRef</span><span class="token punctuation">:</span> <span class="token comment"># 引用的角色</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>role  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建</p><pre class="line-numbers language-she" data-language="she"><code class="language-she">  [root@k8s-master rbactest]#  kubectl create -f zq-sa-rolebinding.yaml      rolebinding.rbac.authorization.k8s.io/zq-sa-rolebinding created*  查看  ```shell  [root@k8s-master rbactest]# kubectl get rolebinding -n kube-system  NAME                                                ROLE                                                  AGE  kube-proxy                                          Role/kube-proxy                                       11d  kubeadm:kubelet-config-1.20                         Role/kubeadm:kubelet-config-1.20                      11d  kubeadm:nodes-kubeadm-config                        Role/kubeadm:nodes-kubeadm-config                     11d  system::extension-apiserver-authentication-reader   Role/extension-apiserver-authentication-reader        11d  system::leader-locking-kube-controller-manager      Role/system::leader-locking-kube-controller-manager   11d  system::leader-locking-kube-scheduler               Role/system::leader-locking-kube-scheduler            11d  system:controller:bootstrap-signer                  Role/system:controller:bootstrap-signer               11d  system:controller:cloud-provider                    Role/system:controller:cloud-provider                 11d  system:controller:token-cleaner                     Role/system:controller:token-cleaner                  11d  zq-rolebinding                                      Role/zq-role                                          95m  zq-sa-rolebinding                                   Role/zq-sa-role                                       39s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="测试验证-1"><a href="#测试验证-1" class="headerlink" title="测试验证"></a>测试验证</h4><p>ServiceAccount 会生成一个 Secret 对象和它进行映射，这个 Secret 里面包含一个 token，我们可以利用这个 token 去登录 Dashboard，然后我们就可以在 Dashboard 中来验证我们的功能是否符合预期了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 获取 kube-system 这个命令空间下 zq-sa 这个 ServiceAccount 的详细信息[root@k8s-master rbactest]# kubectl get sa zq-sa -n kube-system -o yamlapiVersion: v1kind: ServiceAccountmetadata:  creationTimestamp: "2022-08-25T08:03:30Z"  name: zq-sa  namespace: kube-system  resourceVersion: "112076"  uid: 2f89ba9a-4509-4350-a543-5d321813c737secrets:- name: zq-sa-token-rcswr# 获取 zq-sa 这个 ServiceAccount 关联的 secret 的信息[root@k8s-master rbactest]# kubectl get secret  zq-sa-token-rcswr -n kube-system -o yamlapiVersion: v1data:  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeU1EZ3hNekV4TVRjeE1sb1hEVE15TURneE1ERXhNVGN4TWxvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTWN4ClVrNit1TlA4NDZ2ekRxUW9VTlg4MEgzSXhyV3dzVHJZdXdxc1pqei9vb2tFVUF3dDgxQm1aOXl2eXpxSGcya2UKckNjcU1TaE5HcmJiems0NWlCekcwaGtSZDdsSVlEZmI3WHhGWmtwV2RZZlZBK1ZCTkpGRU1VRVVLc2Y2OFFXTQpDVENxajRvTysyUlFLaFFOQ2ZVVm9LUGFwai9lTEZWR2dMSzgyWDBmVllEV1NZMWcrSk1BZWI4V29qa2tVSXQ3CjJNbmlRRjgxMnNGb1A3MkNydGdoU1RzWG1ueldmVkxTMUhxY21GbVBOZG02RjNnSk5CVzFrWmFOaVY3dy9RVzIKNFQ5U1RtQlc0NnhjRm5pKzdPaTVuVzZaWEF5RENPN09MZGhtUWN3TlQzekZLZ3N2SEJRZDNxY0NCb2ZUeUhWRAp1U1dzVWNKYjFleWtnL2NzMy9zQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZISUdnaXBjcEVaTm55Y3Z1bUo5K3VSNFdqeFhNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFBTmVmelo1QjI1aGlNUzZDM0RtNHZDcmtMSEVWZm44NzlEZ3kyc1ZLTVl5VGt2Q0N3LwpWUDhXNmUzcGNnRDBSd29GMytGWDh3YkhGdmlaa2pDd1dwelhOeWszRGFUUWxaeXQwWG93eTd5bVRjdi92L0wvClliMmIrN0pmWmRtb2JxMDZYUEk0L0Y1TllRRkl3MkZOMXlrdnR6TzJoNEp1ZmhMSTUwRSswdnRZZ2t0NDFHOEsKd1VjWGZ2NWx1K3BoZHQ4QXpWdjV3akcrU1h4emV0TjgvU29icnRvRmxZVjZLcHpMSysrRUtFTWd0Z0g0OUNxcQpUYmpsNFIybjNqcU1wVWpEdUpFTFF5ZDg3N2g5V240WCtEdUdEYVRHNEJPVFlHUkZvSTcxS1FzZWlTWFd0NUJmCjd3SG40T3ZkN1U1S0o1dkEzWEZIVWJPanExY3RITTlreWJCMAotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==  namespace: a3ViZS1zeXN0ZW0=  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklqRkpYMHRtYkZvelFXUTFSMnR5TjNkTVprTkJaRFowUkdwZlkyaFNVbU5vYUZJM1VUTndWbUpMVmtVaWZRLmV5SnBjM01pT2lKcmRXSmxjbTVsZEdWekwzTmxjblpwWTJWaFkyTnZkVzUwSWl3aWEzVmlaWEp1WlhSbGN5NXBieTl6WlhKMmFXTmxZV05qYjNWdWRDOXVZVzFsYzNCaFkyVWlPaUpyZFdKbExYTjVjM1JsYlNJc0ltdDFZbVZ5Ym1WMFpYTXVhVzh2YzJWeWRtbGpaV0ZqWTI5MWJuUXZjMlZqY21WMExtNWhiV1VpT2lKNmNTMXpZUzEwYjJ0bGJpMXlZM04zY2lJc0ltdDFZbVZ5Ym1WMFpYTXVhVzh2YzJWeWRtbGpaV0ZqWTI5MWJuUXZjMlZ5ZG1salpTMWhZMk52ZFc1MExtNWhiV1VpT2lKNmNTMXpZU0lzSW10MVltVnlibVYwWlhNdWFXOHZjMlZ5ZG1salpXRmpZMjkxYm5RdmMyVnlkbWxqWlMxaFkyTnZkVzUwTG5WcFpDSTZJakptT0RsaVlUbGhMVFExTURrdE5ETTFNQzFoTlRRekxUVmtNekl4T0RFell6Y3pOeUlzSW5OMVlpSTZJbk41YzNSbGJUcHpaWEoyYVdObFlXTmpiM1Z1ZERwcmRXSmxMWE41YzNSbGJUcDZjUzF6WVNKOS5kSnZHNjB2TlQ3a3lfX2FWU0hCT2dXZllvYm0yNmJfOFJrNGNHYVVieGJxRmZzc1drZ2dZek5BRmR0RFdoTWdicWlsdENNTjlzd20wWmVIUU4zb29IZU5Zd2c5U0ZiTDJBZDN3WExsQzUyVzZ1Z0JfeEVieGoxMlpPZTMzT2tWNk9Fd1NoeldBOFdqMXZTbGp3aHRPZUs0b1d4S2VSSHFKVW0tZVBjQ0lqcWhxOF92QTlhMXJuQ3VXSTNPT0RmX0NPdUlxdDdZRVktdElSbWhyZ1pRZVRMdXY5eUxhWVFIekpFSTRVVURfbWRIRVZFQzMtN1E2eDhoQnZudnNydmlyajhtYy1kYXFTd2FkU3NGbHhXeUxlTkFPQm1Cc0JzY3VjVEV0SnhORl9jQ1VGbHNwT0dfMFREY01NWWJVTDI3eFRSSkFZOFRoUTdfSUg5VHROMml4UXc=kind: Secretmetadata:  annotations:    kubernetes.io/service-account.name: zq-sa    kubernetes.io/service-account.uid: 2f89ba9a-4509-4350-a543-5d321813c737  creationTimestamp: "2022-08-25T08:03:30Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:ca.crt: {}        f:namespace: {}        f:token: {}      f:metadata:        f:annotations:          .: {}          f:kubernetes.io/service-account.name: {}          f:kubernetes.io/service-account.uid: {}      f:type: {}    manager: kube-controller-manager    operation: Update    time: "2022-08-25T08:03:30Z"  name: zq-sa-token-rcswr  namespace: kube-system  resourceVersion: "112075"  uid: 728d0487-00d9-422e-abad-8693fa8a4aa5type: kubernetes.io/service-account-token# 对 token 解码[root@k8s-master rbactest]# kubectl get secret zq-sa-token-rcswr -o jsonpath={.data.token} -n kube-system |base64 -d                 eyJhbGciOiJSUzI1NiIsImtpZCI6IjFJX0tmbFozQWQ1R2tyN3dMZkNBZDZ0RGpfY2hSUmNoaFI3UTNwVmJLVkUifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJ6cS1zYS10b2tlbi1yY3N3ciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJ6cS1zYSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjJmODliYTlhLTQ1MDktNDM1MC1hNTQzLTVkMzIxODEzYzczNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTp6cS1zYSJ9.dJvG60vNT7ky__aVSHBOgWfYobm26b_8Rk4cGaUbxbqFfssWkggYzNAFdtDWhMgbqiltCMN9swm0ZeHQN3ooHeNYwg9SFbL2Ad3wXLlC52W6ugB_xEbxj12ZOe33OkV6OEwShzWA8Wj1vSljwhtOeK4oWxKeRHqJUm-ePcCIjqhq8_vA9a1rnCuWI3OODf_COuIqt7YEY-tIRmhrgZQeTLuv9yLaYQHzJEI4UUD_mdHEVEC3-7Q6x8hBvnvsrvirj8mc-daqSwadSsFlxWyLeNAOBmBsBscucTEtJxNF_cCUFlspOG_0TDcMMYbUL27xTRJAY8ThQ7_IH9TtN2ixQw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这里的 解码后 token 去 Dashboard 页面进行登录然后验证权限是否符合我们的预期：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-rbac-sa-1.png"></p><p>我们可以看到上面的提示信息说我们现在使用的这个 ServiceAccount 没有权限获取当前命名空间下面的资源对象，这是因为我们登录进来后默认跳转到 default 命名空间，我们切换到 kube-system 命名空间下面就可以了：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-rbac-sa-2.png"></p><p>我们试着删除一个 Pod 看看</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-rbac-sa-3.png"></p><p>可以看到禁止我们删除，这是因为 zq-sa 这个用户我们只授权它Pod  “get”, “watch”, “list”的操作权限。</p><h3 id="可以全局访问的-ServiceAccount"><a href="#可以全局访问的-ServiceAccount" class="headerlink" title="可以全局访问的 ServiceAccount"></a>可以全局访问的 ServiceAccount</h3><p>刚刚我们创建的 zq-sa 这个 <code>ServiceAccount</code> 和一个 <code>Role</code> 角色进行绑定的，如果我们现在创建一个新的 ServiceAccount，需要它操作的权限作用于所有的 namespace，这个时候我们就需要使用到 <code>ClusterRole</code> 和 <code>ClusterRoleBinding</code> 这两种资源对象了。</p><h4 id="创建一个集群内部使用的用户（ServiceAccount）-1"><a href="#创建一个集群内部使用的用户（ServiceAccount）-1" class="headerlink" title="创建一个集群内部使用的用户（ServiceAccount）"></a>创建一个集群内部使用的用户（ServiceAccount）</h4><ul><li><p>准备 zq-sa-cluster.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>cluster  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl create -f zq-sa-cluster.yaml serviceaccount/zq-sa-cluster created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="创建集群角色（ClusterRole）"><a href="#创建集群角色（ClusterRole）" class="headerlink" title="创建集群角色（ClusterRole）"></a>创建集群角色（ClusterRole）</h4><p>我们就不创建 clusterRole 了，我们就使用系统内置的 ClusterRole</p><h4 id="创建集群角色权限绑定（ClusterRoleBinding）"><a href="#创建集群角色权限绑定（ClusterRoleBinding）" class="headerlink" title="创建集群角色权限绑定（ClusterRoleBinding）"></a>创建集群角色权限绑定（ClusterRoleBinding）</h4><ul><li><p>准备 zq-sa-clusterolebinding.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>clusterolebinding<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> zq<span class="token punctuation">-</span>sa<span class="token punctuation">-</span>cluster  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面我们可以看到我们没有为这个资源对象声明 namespace，因为这是一个 ClusterRoleBinding 资源对象，是作用于整个集群的，我们也没有单独新建一个 ClusterRole 对象，而是使用的 <code>cluster-admin</code> 这个对象，这是 Kubernetes 集群内置的 ClusterRole 对象，我们可以使用 <code>kubectl get clusterrole</code> 和 <code>kubectl get clusterrolebinding</code> 查看系统内置的一些集群角色和集群角色绑定，这里我们使用的 <code>cluster-admin</code> 这个集群角色是拥有最高权限的集群角色，所以一般需要谨慎使用该集群角色。</p></li><li><p>创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl create -f zq-sa-clusterolebinding.yaml clusterrolebinding.rbac.authorization.k8s.io/zq-sa-clusterolebinding created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl get clusterrole cluster-adminNAME            CREATED ATcluster-admin   2022-08-13T11:17:28Z[root@k8s-master rbactest]# kubectl get clusterrolebinding zq-sa-clusterolebinding -n kube-systemNAME                      ROLE                        AGEzq-sa-clusterolebinding   ClusterRole/cluster-admin   102s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="测试验证-2"><a href="#测试验证-2" class="headerlink" title="测试验证"></a>测试验证</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master rbactest]# kubectl get sa -n kube-systemNAME                                 SECRETS   AGE......zq-sa                                1         56mzq-sa-cluster                        1         6m9s......[root@k8s-master rbactest]# kubectl get sa zq-sa-cluster -n kube-system -o yamlapiVersion: v1kind: ServiceAccountmetadata:  creationTimestamp: "2022-08-25T08:53:35Z"  name: zq-sa-cluster  namespace: kube-system  resourceVersion: "116844"  uid: c4bfbe6d-70df-4194-846d-30c74db8e0c1secrets:- name: zq-sa-cluster-token-xzff2# 查看 zq-sa-cluster 这个 ServiceAccount 关联的 secret[root@k8s-master rbactest]# kubectl get secret zq-sa-cluster-token-xzff2 -n kube-system -o yamlapiVersion: v1data:  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeU1EZ3hNekV4TVRjeE1sb1hEVE15TURneE1ERXhNVGN4TWxvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTWN4ClVrNit1TlA4NDZ2ekRxUW9VTlg4MEgzSXhyV3dzVHJZdXdxc1pqei9vb2tFVUF3dDgxQm1aOXl2eXpxSGcya2UKckNjcU1TaE5HcmJiems0NWlCekcwaGtSZDdsSVlEZmI3WHhGWmtwV2RZZlZBK1ZCTkpGRU1VRVVLc2Y2OFFXTQpDVENxajRvTysyUlFLaFFOQ2ZVVm9LUGFwai9lTEZWR2dMSzgyWDBmVllEV1NZMWcrSk1BZWI4V29qa2tVSXQ3CjJNbmlRRjgxMnNGb1A3MkNydGdoU1RzWG1ueldmVkxTMUhxY21GbVBOZG02RjNnSk5CVzFrWmFOaVY3dy9RVzIKNFQ5U1RtQlc0NnhjRm5pKzdPaTVuVzZaWEF5RENPN09MZGhtUWN3TlQzekZLZ3N2SEJRZDNxY0NCb2ZUeUhWRAp1U1dzVWNKYjFleWtnL2NzMy9zQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZISUdnaXBjcEVaTm55Y3Z1bUo5K3VSNFdqeFhNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFBTmVmelo1QjI1aGlNUzZDM0RtNHZDcmtMSEVWZm44NzlEZ3kyc1ZLTVl5VGt2Q0N3LwpWUDhXNmUzcGNnRDBSd29GMytGWDh3YkhGdmlaa2pDd1dwelhOeWszRGFUUWxaeXQwWG93eTd5bVRjdi92L0wvClliMmIrN0pmWmRtb2JxMDZYUEk0L0Y1TllRRkl3MkZOMXlrdnR6TzJoNEp1ZmhMSTUwRSswdnRZZ2t0NDFHOEsKd1VjWGZ2NWx1K3BoZHQ4QXpWdjV3akcrU1h4emV0TjgvU29icnRvRmxZVjZLcHpMSysrRUtFTWd0Z0g0OUNxcQpUYmpsNFIybjNqcU1wVWpEdUpFTFF5ZDg3N2g5V240WCtEdUdEYVRHNEJPVFlHUkZvSTcxS1FzZWlTWFd0NUJmCjd3SG40T3ZkN1U1S0o1dkEzWEZIVWJPanExY3RITTlreWJCMAotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==  namespace: a3ViZS1zeXN0ZW0=  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklqRkpYMHRtYkZvelFXUTFSMnR5TjNkTVprTkJaRFowUkdwZlkyaFNVbU5vYUZJM1VUTndWbUpMVmtVaWZRLmV5SnBjM01pT2lKcmRXSmxjbTVsZEdWekwzTmxjblpwWTJWaFkyTnZkVzUwSWl3aWEzVmlaWEp1WlhSbGN5NXBieTl6WlhKMmFXTmxZV05qYjNWdWRDOXVZVzFsYzNCaFkyVWlPaUpyZFdKbExYTjVjM1JsYlNJc0ltdDFZbVZ5Ym1WMFpYTXVhVzh2YzJWeWRtbGpaV0ZqWTI5MWJuUXZjMlZqY21WMExtNWhiV1VpT2lKNmNTMXpZUzFqYkhWemRHVnlMWFJ2YTJWdUxYaDZabVl5SWl3aWEzVmlaWEp1WlhSbGN5NXBieTl6WlhKMmFXTmxZV05qYjNWdWRDOXpaWEoyYVdObExXRmpZMjkxYm5RdWJtRnRaU0k2SW5weExYTmhMV05zZFhOMFpYSWlMQ0pyZFdKbGNtNWxkR1Z6TG1sdkwzTmxjblpwWTJWaFkyTnZkVzUwTDNObGNuWnBZMlV0WVdOamIzVnVkQzUxYVdRaU9pSmpOR0ptWW1VMlpDMDNNR1JtTFRReE9UUXRPRFEyWkMwek1HTTNOR1JpT0dVd1l6RWlMQ0p6ZFdJaU9pSnplWE4wWlcwNmMyVnlkbWxqWldGalkyOTFiblE2YTNWaVpTMXplWE4wWlcwNmVuRXRjMkV0WTJ4MWMzUmxjaUo5LmotcURjMkNETGlJa29FMTQxRmJCU1lqSDE3bVNvZWFhVDNVcFBHeDRDeVhoaGwxcm9ob2w5b2lOaUFQM0dROUJWbGxUR0MybXZ1Skk0Z1RPUUpXOEpfRy1xRHhpeklhMndaQTd5UXZFd3lrNjZYSldhamFmT1RIZ0ttVnpxR2hpVjRXeS1xVGlCTjVJdzlqNTctMXBHUkh5N3JZTFpJVlpNSl9sX1FQMTQ4bTZQY05HbFhRemJlaDI5eE1KRnoyaDE1QUg5dkJYZEMtcmhjQkR6dWp4ck8yeXR1WG4yckhvampaeXZ5bjZBMm5kMXZZcDVvOUVGT01zb0thNUVHOWRkTmFubFFMTGprU2ZGZm5nSTJ3NFFPZkdWRkJxdEtHTHE0c2pHYldDZWFTeEpRZ0o3V3FUOUoxemxOR292aXJnd1NORExYLWN0SW5HLUdZVmQ2V29fUQ==kind: Secretmetadata:  annotations:    kubernetes.io/service-account.name: zq-sa-cluster    kubernetes.io/service-account.uid: c4bfbe6d-70df-4194-846d-30c74db8e0c1  creationTimestamp: "2022-08-25T08:53:35Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:ca.crt: {}        f:namespace: {}        f:token: {}      f:metadata:        f:annotations:          .: {}          f:kubernetes.io/service-account.name: {}          f:kubernetes.io/service-account.uid: {}      f:type: {}    manager: kube-controller-manager    operation: Update    time: "2022-08-25T08:53:35Z"  name: zq-sa-cluster-token-xzff2  namespace: kube-system  resourceVersion: "116843"  uid: 209e069d-f475-4d95-a848-abff78c28113type: kubernetes.io/service-account-token# 对 secret 中的 token base64解码[root@k8s-master rbactest]# kubectl get secret zq-sa-cluster-token-xzff2 -o jsonpath={.data.token} -n kube-system |base64 -d                      eyJhbGciOiJSUzI1NiIsImtpZCI6IjFJX0tmbFozQWQ1R2tyN3dMZkNBZDZ0RGpfY2hSUmNoaFI3UTNwVmJLVkUifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJ6cS1zYS1jbHVzdGVyLXRva2VuLXh6ZmYyIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6InpxLXNhLWNsdXN0ZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJjNGJmYmU2ZC03MGRmLTQxOTQtODQ2ZC0zMGM3NGRiOGUwYzEiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06enEtc2EtY2x1c3RlciJ9.j-qDc2CDLiIkoE141FbBSYjH17mSoeaaT3UpPGx4CyXhhl1rohol9oiNiAP3GQ9BVllTGC2mvuJI4gTOQJW8J_G-qDxizIa2wZA7yQvEwyk66XJWajafOTHgKmVzqGhiV4Wy-qTiBN5Iw9j57-1pGRHy7rYLZIVZMJ_l_QP148m6PcNGlXQzbeh29xMJFz2h15AH9vBXdC-rhcBDzujxrO2ytuXn2rHojjZyvyn6A2nd1vYp5o9EFOMsoKa5EG9ddNanlQLLjkSfFfngI2w4QOfGVFBqtKGLq4sjGbWCeaSxJQgJ7WqT9J1zlNGovirgwSNDLX-ctInG-GYVd6Wo_Q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拿着解码后的 token 去 dashboard 上登录验证：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20220825170504.png"></p><p>可以看到它有所有命名空间的权限。</p><p>我们在最开始接触到 RBAC 认证的时候，可能不太熟悉，特别是不知道应该怎么去编写 rules 规则，可以去分析系统自带的 <code>clusterrole</code>、<code>clusterrolebinding</code> 这些资源对象的编写方法，怎么分析？还是利用 kubectl 的 <code>get</code>、<code>describe</code>、 <code>-o yaml</code> 这些操作。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/">https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/</a></li><li><a href="https://v1-21.docs.kubernetes.io/docs/reference/using-api/">https://v1-21.docs.kubernetes.io/docs/reference/using-api/</a></li><li><a href="https://v1-21.docs.kubernetes.io/docs/reference/using-api/api-concepts/">https://v1-21.docs.kubernetes.io/docs/reference/using-api/api-concepts/</a></li><li><a href="https://v1-21.docs.kubernetes.io/docs/reference/access-authn-authz/rbac/">https://v1-21.docs.kubernetes.io/docs/reference/access-authn-authz/rbac/</a></li><li><a href="https://www.qikqiak.com/k8strain/security/rbac/">https://www.qikqiak.com/k8strain/security/rbac/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes ServiceAccount</title>
      <link href="/2022/08/25/kubernetes-serviceaccount/"/>
      <url>/2022/08/25/kubernetes-serviceaccount/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-ServiceAccount"><a href="#Kubernetes-ServiceAccount" class="headerlink" title="Kubernetes ServiceAccount"></a>Kubernetes ServiceAccount</h1><p><code>ServiceAccount</code> 主要是用于解决 Pod 在集群中的身份认证问题。认证使用的授权信息其实就是利用一个类型为 <code>kubernetes.io/service-account-token</code> 进行管理的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>ServiceAccount</code> 是命名空间级别的，每一个命名空间创建的时候就会自动创建一个名为 <code>default</code> 的 <code>ServiceAccount</code> 对象:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create ns kube-testnamespace/kube-test created[root@k8s-master ~]# kubectl get ServiceAccount -n kube-test NAME      SECRETS   AGEdefault   1         29s[root@k8s-master ~]# kubectl get secret -n kube-testNAME                  TYPE                                  DATA   AGEdefault-token-5ppzb   kubernetes.io/service-account-token   3      47s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 <code>ServiceAccount</code> 会自动关联到一个 <code>Secret</code> 对象上：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root@k8s-master ~]# kubectl get sa default -n kube-test -o yamlapiVersion: v1kind: ServiceAccountmetadata:  creationTimestamp: "2022-08-24T12:26:22Z"  name: default  namespace: kube-test  resourceVersion: "98033"  uid: 0424a9f9-9df3-4a09-afed-9f1fa1329ee3secrets:- name: default-token-5ppzb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 Secret 对象是 ServiceAccount 控制器自动创建的，我们可以查看这个关联的 <code>Secret</code> 对象信息：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-account.png"></p><p>在 <code>data</code> 区域我们可以看到有3个信息：</p><ul><li><code>ca.crt</code>：用于校验服务端的证书信息</li><li><code>namespace</code>：表示当前管理的命名空间</li><li><code>token</code>：用于 Pod 身份认证的 Token</li></ul><p>默认情况下当前 namespace 下面的 Pod 会默认使用 <code>default</code> 这个 ServiceAccount，对应的 <code>Secret</code> 会自动挂载到 Pod 的 <code>/var/run/secrets/kubernetes.io/serviceaccount/</code> 目录中，这样我们就可以在 Pod 里面获取到用于身份认证的信息了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>如下所示我们随意创建一个 Pod：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root@k8s-master ~]# kubectl run nginx-sa --image nginx:1.7.9pod/nginx-sa created[root@k8s-master ~]# kubectl get podsNAME          READY   STATUS             RESTARTS   AGEnginx-sa      1/1     Running            0          12s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入这个 Pod 中查看：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root@k8s-master ~]# kubectl exec -it nginx-sa /bin/bash -- /bin/bashroot@nginx-sa:/# lsbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  varroot@nginx-sa:/#  ls /run/secrets/kubernetes.io/serviceaccount/ca.crt  namespace  tokenroot@nginx-sa:/# ls /var/run/secrets/kubernetes.io/serviceaccount/ca.crt  namespace  token#可以看到在 /var/run/secrets/kubernetes.io/serviceaccount/中的确有三个文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看这个 Pod 的详细信息：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[root@k8s-master ~]# kubectl get pod nginx-sa -o yaml | grep serviceAccount  serviceAccount: default  serviceAccountName: default  # 可以看到 Pod 的确有名字为 default的 ServiceAccount，serviceAccountName是新版本推荐使用的  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看这个 Pod 使用的 <code>default</code> 这个 ServiceAccount：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get sa NAME      SECRETS   AGEdefault   1         11d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看 default 的ServiceAccount详细信息，可以看到它 Mount 了一个 secret ：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl describe sa defaultName:                defaultNamespace:           defaultLabels:              &lt;none&gt;Annotations:         &lt;none&gt;Image pull secrets:  &lt;none&gt;Mountable secrets:   default-token-pvpv2Tokens:              default-token-pvpv2Events:              &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 secret</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get secretNAME                  TYPE                                  DATA   AGEdefault-token-pvpv2   kubernetes.io/service-account-token   3      11dmyregistry            kubernetes.io/dockerconfigjson        1      2d3hmysecret              Opaque                                2      2d4h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>实际上这个自动挂载过程是在 Pod 创建的时候通过 <code>Admisson Controller（准入控制器）</code> 来实现的。</p><p><code>Admission Controller（准入控制）</code>是 Kubernetes API Server 用于拦截请求的一种手段。<code>Admission</code> 可以做到对请求的资源对象进行校验，修改，Pod 创建时 <code>Admission Controller</code> 会根据指定的的 <code>ServiceAccount</code>（默认的 default）把对应的 <code>Secret</code> 挂载到容器中的固定目录下 <code>/var/run/secrets/kubernetes.io/serviceaccount/</code>。</p><blockquote><p>Admission Controller（准入控制）<code>是 Kubernetes API Server 用于拦截请求的一种手段。</code>Admission<code>可以做到对请求的资源对象进行校验，修改，Pod 创建时</code>Admission Controller<code>会根据指定的的</code>ServiceAccount<code>（默认的 default）把对应的 </code>Secret<code>挂载到容器中的固定目录下</code>/var/run/secrets/kubernetes.io/serviceaccount/`。</p></blockquote><p>然后当我们在 Pod 里面访问集群的时候，就可以默认利用挂载到 Pod 内部的 <code>token</code> 文件来认证 Pod 的身份，<code>ca.crt</code> 则用来校验服务端。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Secret 敏感信息配置管理</title>
      <link href="/2022/08/24/kubernetes-secret-min-gan-xin-xi-pei-zhi-guan-li/"/>
      <url>/2022/08/24/kubernetes-secret-min-gan-xin-xi-pei-zhi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Secret-敏感信息配置管理"><a href="#Kubernetes-Secret-敏感信息配置管理" class="headerlink" title="Kubernetes Secret 敏感信息配置管理"></a>Kubernetes Secret 敏感信息配置管理</h1><p>Secret 和 Configmap 类似，不过 Secret 是加密后的，一般用于存储敏感数据，如 比如密码，token，密钥等。</p><p>Secret 主要使用的有以下几种类型：</p><ul><li><code>Opaque</code>：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也可以通过<code>base64 –decode</code>解码得到原始数据，所有加密性很弱。</li><li><code>kubernetes.io/dockerconfigjson</code>：用来存储私有<code>docker registry</code>的认证信息。</li><li><code>kubernetes.io/service-account-token</code>：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的 /run/secrets/kubernetes.io/serviceaccount 目录中</li></ul><h2 id="Opaque"><a href="#Opaque" class="headerlink" title="Opaque"></a>Opaque</h2><p><code>Opaque</code> 类型的数据是一个 map 类型，要求 value 必须是 <code>base64</code> 编码格式，比如我们来创建一个用户名为 admin，密码为 admin321 的 <code>Secret</code> 对象，首先我们需要先把用户名和密码做 <code>base64</code>编码：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ echo -n "admin" | base64YWRtaW4=$ echo -n "admin321" | base64YWRtaW4zMjE=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们就可以利用上面编码过后的数据来编写一个 YAML 文件：<em>secret-demo.yaml</em></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">username</span><span class="token punctuation">:</span> YWRtaW4=  <span class="token key atrule">password</span><span class="token punctuation">:</span> YWRtaW4zMjE=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们就可以使用 kubectl 命令来创建了：</p><pre class="line-numbers language-none"><code class="language-none">[root@k8s-master ~]# kubectl create -f secret/secret-demo.yaml secret/mysecret created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用<code>get secret</code>命令查看：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get secretNAME                  TYPE                                  DATA   AGEdefault-token-pvpv2   kubernetes.io/service-account-token   3      8dmysecret              Opaque                                2      11s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中 default-token-pvpv2为创建集群时默认创建的 Secret，被 <code>serviceacount/default</code> 引用。我们可以使用 <code>describe</code> 命令查看详情：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl describe secret mysecretName:         mysecretNamespace:    defaultLabels:       &lt;none&gt;Annotations:  &lt;none&gt;Type:  OpaqueData====password:  8 bytesusername:  5 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到利用 describe 命令查看到的 Data 没有直接显示出来，如果想看到 Data 里面的详细信息，同样我们可以输出成YAML 文件进行查看：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master ~<span class="token punctuation">]</span><span class="token comment"># kubectl describe secret mysecret</span><span class="token key atrule">Name</span><span class="token punctuation">:</span>         mysecret<span class="token key atrule">Namespace</span><span class="token punctuation">:</span>    default<span class="token key atrule">Labels</span><span class="token punctuation">:</span>       &lt;none<span class="token punctuation">&gt;</span><span class="token key atrule">Annotations</span><span class="token punctuation">:</span>  &lt;none<span class="token punctuation">&gt;</span><span class="token key atrule">Type</span><span class="token punctuation">:</span>  OpaqueData====<span class="token key atrule">password</span><span class="token punctuation">:</span>  8 bytes<span class="token key atrule">username</span><span class="token punctuation">:</span>  5 bytes<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get secret mysecret -o yaml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">password</span><span class="token punctuation">:</span> YWRtaW4zMjE=  <span class="token key atrule">username</span><span class="token punctuation">:</span> YWRtaW4=<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">creationTimestamp</span><span class="token punctuation">:</span> <span class="token string">"2022-08-22T08:18:53Z"</span>  <span class="token key atrule">managedFields</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1    <span class="token key atrule">fieldsType</span><span class="token punctuation">:</span> FieldsV1    <span class="token key atrule">fieldsV1</span><span class="token punctuation">:</span>      <span class="token key atrule">f:data</span><span class="token punctuation">:</span>        <span class="token key atrule">.</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token key atrule">f:password</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token key atrule">f:username</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token key atrule">f:type</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token key atrule">manager</span><span class="token punctuation">:</span> kubectl<span class="token punctuation">-</span>create    <span class="token key atrule">operation</span><span class="token punctuation">:</span> Update    <span class="token key atrule">time</span><span class="token punctuation">:</span> <span class="token string">"2022-08-22T08:18:53Z"</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">resourceVersion</span><span class="token punctuation">:</span> <span class="token string">"87952"</span>  <span class="token key atrule">uid</span><span class="token punctuation">:</span> eff0b3d4<span class="token punctuation">-</span>8b5e<span class="token punctuation">-</span>43e2<span class="token punctuation">-</span>b198<span class="token punctuation">-</span>46d9fcbecc5c<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建好 <code>Secret</code>对象后，有两种方式来使用它：</p><ul><li>以环境变量的形式</li><li>以Volume的形式挂载</li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>首先我们来测试下环境变量的方式，同样的，我们来使用一个简单的 busybox 镜像来测试下：<em>secret1-pod.yaml</em></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret1<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret1    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"env"</span> <span class="token punctuation">]</span>    <span class="token key atrule">env</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> USERNAME      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret          <span class="token key atrule">key</span><span class="token punctuation">:</span> username    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> PASSWORD      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret          <span class="token key atrule">key</span><span class="token punctuation">:</span> password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要需要注意的是上面环境变量中定义的 <code>secretKeyRef</code> 字段，和ConfigMap中的 <code>configMapKeyRef</code> 类似，一个是从 <code>Secret</code> 对象中获取，一个是从 <code>ConfigMap</code> 对象中获取，创建上面的 Pod并查看日志：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create -f secret/secret1-pod.yaml pod/secret1-pod created [root@k8s-master ~]# kubectl logs secret1-pod......USERNAME=adminPASSWORD=admin321......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Volume-挂载"><a href="#Volume-挂载" class="headerlink" title="Volume 挂载"></a>Volume 挂载</h3><p>同样的我们用一个 Pod 来验证下 <code>Volume</code> 挂载，创建一个 Pod 文件：<em>secret2-pod.yaml</em></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret2<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secret2    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"ls /etc/secrets"</span><span class="token punctuation">]</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/secrets  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets    <span class="token key atrule">secret</span><span class="token punctuation">:</span>     <span class="token key atrule">secretName</span><span class="token punctuation">:</span> mysecret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 Pod，然后查看输出日志：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create -f secret/secret2-pod.yaml pod/secret2-pod created[root@k8s-master ~]# kubectl logs secret2-podpasswordusername<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 Secret 把两个 key 挂载成了两个对应的文件。</p><h2 id="kubernetes-io-dockerconfigjson"><a href="#kubernetes-io-dockerconfigjson" class="headerlink" title="kubernetes.io/dockerconfigjson"></a>kubernetes.io/dockerconfigjson</h2><p>除了上面的 <code>Opaque</code> 这种类型外，我们还可以来创建用户 <code>docker registry</code> 认证的 <code>Secret</code>，比如我们把自己在 docker hub 上某个仓库镜像设置为私有的</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-secret-dockerhub.png"></p><p>然后观察下创建 Pod 时 docker hub 上的私有仓库来拉取镜像会发生什么 </p><p>准备好创建Pod的资源文件 <em>secret-private-php.yaml</em></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>php<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>php    <span class="token key atrule">image</span><span class="token punctuation">:</span> dendi875/php<span class="token punctuation">-</span>php<span class="token punctuation">:</span><span class="token number">7.3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着创建 Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f secret/secret-private-php.yaml pod/private-php created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>观察事件</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-secret-dockerhub-2.png"></p><p>可以看到这个  Pod 是创建失败，因为我们的仓库镜像是私有的</p><p>我们先删除这个 Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete -f secret/secret-private-php.yaml pod "private-php" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果这时我们需要从私有仓库拉取镜像怎么办呢？</p><p>我们可以使用 <code>kubectl create secret docker-registry </code> 来创建一个 secret，如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create secret docker-registry myregistry \--docker-server=&lt;你的镜像仓库服务器&gt; \--docker-username=&lt;你的用户名&gt; \--docker-password=&lt;你的密码&gt; \--docker-email=&lt;你的邮箱地址&gt;secret/myregistry created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后查看 Secret 列表：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get secretNAME                  TYPE                                  DATA   AGEdefault-token-pvpv2   kubernetes.io/service-account-token   3      8dmyregistry            kubernetes.io/dockerconfigjson        1      14smysecret              Opaque                                2      73m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意看上面的 TYPE 类型，myregistry 对应的type是 <code>kubernetes.io/dockerconfigjson</code>，同样的可以使用 describe 或 get -o yaml 命令来查看详细信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]#  kubectl describe secret myregistryName:         myregistryNamespace:    defaultLabels:       &lt;none&gt;Annotations:  &lt;none&gt;Type:  kubernetes.io/dockerconfigjsonData====.dockerconfigjson:  152 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-secret-dockerhub-4.png"></p><p>把上面的 <code>data.dockerconfigjson</code> 下面的数据做一个 <code>base64</code> 解码，内容就如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"auths"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"DOCKER_SERVER"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">"DOCKER_USER"</span><span class="token punctuation">,</span>            <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"DOCKER_PASSWORD"</span><span class="token punctuation">,</span>            <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"DOCKER_EMAIL"</span><span class="token punctuation">,</span>            <span class="token property">"auth"</span><span class="token operator">:</span> <span class="token string">"RE9DS0VSX1VTRVI6RE9DS0VSX1BBU1NXT1JE"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要拉取私有仓库镜像，我们就需要在 Pod 中指定 <code>imagePullSecrets</code>，在 <em>secret-private-php.yaml</em> 中加入 <code>imagePullSecrets</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>php<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> private<span class="token punctuation">-</span>php    <span class="token key atrule">image</span><span class="token punctuation">:</span> dendi875/php<span class="token punctuation">-</span>php<span class="token punctuation">:</span><span class="token number">7.3</span>  <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myregistry  <span class="token comment"># 创建的 secret 名字  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f secret/secret-private-php.yaml pod/private-php created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在次观察</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-secret-dockerhub-3.png"></p><p>可以发现镜像已经成功拉取</p><p>去 node2机器上也能看到镜像被成功拉取</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-node2 ~]# docker images | grep dendi875dendi875/php-php                                                            7.3        d5a49dc91b8c   2 years ago     183MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>ImagePullSecrets</code> 与 <code>Secrets</code> 不同，因为 <code>Secrets</code> 可以挂载到 Pod 中，但是 <code>ImagePullSecrets</code> 只能由 Kubelet 访问。</p></blockquote><p>除了设置 <code>Pod.spec.imagePullSecrets</code> 这种方式来获取私有镜像之外，我们还可以通过在 <code>ServiceAccount</code> 中设置 <code>imagePullSecrets</code>，然后就会自动为使用该 ServiceAccount 的 Pod 注入 <code>imagePullSecrets</code>信息：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">creationTimestamp</span><span class="token punctuation">:</span> <span class="token string">"2019-11-08T12:00:04Z"</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> default  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">resourceVersion</span><span class="token punctuation">:</span> <span class="token string">"332"</span>  <span class="token key atrule">selfLink</span><span class="token punctuation">:</span> /api/v1/namespaces/default/serviceaccounts/default  <span class="token key atrule">uid</span><span class="token punctuation">:</span> cc37a719<span class="token punctuation">-</span>c4fe<span class="token punctuation">-</span>4ebf<span class="token punctuation">-</span>92da<span class="token punctuation">-</span>e92c3e24d5d0<span class="token key atrule">secrets</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> default<span class="token punctuation">-</span>token<span class="token punctuation">-</span>5tsh4<span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myregistry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="kubernetes-io-service-account-token"><a href="#kubernetes-io-service-account-token" class="headerlink" title="kubernetes.io/service-account-token"></a>kubernetes.io/service-account-token</h2><p>另外一种 <code>Secret</code> 类型就是 <code>kubernetes.io/service-account-token</code>，用于被 <code>ServiceAccount</code> 引用。<code>ServiceAccout</code> 创建时 Kubernetes 会默认创建对应的 <code>Secret</code>。Pod 如果使用了 <code>ServiceAccount</code>，对应的 <code>Secret</code> 会自动挂载到 Pod 的 <code>/var/run/secrets/kubernetes.io/serviceaccount/</code> 目录中。如下所示我们随意创建一个 Pod：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl run secret-pod3 --image nginx:1.7.9pod/secret-pod3 created[root@k8s-master ~]# kubectl get podsNAME          READY   STATUS             RESTARTS   AGE......secret-pod3   1/1     Running            0          57s......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以直接查看这个 Pod 的详细信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">......    volumeMounts:    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount      name: default-token-pvpv2      readOnly: true  ......  serviceAccount: default  serviceAccountName: default  ......  volumes:  - name: default-token-pvpv2    secret:      defaultMode: 420      secretName: default-token-pvpv2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到默认把名为 <code>default</code>（自动创建的）的 <code>ServiceAccount</code> 对应的 Secret 对象通过 Volume 挂载到了容器的 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 的目录中</p><h2 id="Secret-vs-ConfigMap"><a href="#Secret-vs-ConfigMap" class="headerlink" title="Secret vs ConfigMap"></a>Secret vs ConfigMap</h2><p>最后我们来对比下 <code>Secret</code> 和 <code>ConfigMap</code>这两种资源对象的异同点：</p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li><p>key/value的形式</p></li><li><p>属于某个特定的命名空间</p></li><li><p>可以导出到环境变量</p></li><li><p>可以通过目录/文件形式挂载</p></li><li><p>通过 volume 挂载的配置信息均可热更新</p></li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li><p>Secret 可以被 ServerAccount 关联</p></li><li><p>Secret 可以存储 <code>docker register</code> 的鉴权信息，用在 <code>ImagePullSecret</code> 参数中，用于拉取私有仓库的镜像</p></li><li><p>Secret 支持 <code>Base64</code> 加密</p></li><li><p>Secret 分为 <code>kubernetes.io/service-account-token</code>、<code>kubernetes.io/dockerconfigjson</code>、<code>Opaque</code> 三种类型，而 <code>Configmap</code> 不区分类型</p><blockquote><p><strong>Warning</strong></p><p>同样 Secret 文件大小限制为 <code>1MB</code>（ETCD 的要求）；Secret 虽然采用 <code>Base64</code> 编码，但是我们还是可以很方便解码获取到原始信息，所以对于非常重要的数据还是需要慎重考虑，可以考虑使用 <a href="https://www.vaultproject.io/">Vault</a> 来进行加密管理。</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://kubernetes.io/docs/concepts/configuration/secret/">https://kubernetes.io/docs/concepts/configuration/secret/</a></p></li><li><p> <a href="https://www.qikqiak.com/k8strain/config/secret/#opaque-secret">https://www.qikqiak.com/k8strain/config/secret/#opaque-secret</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes ConfigMap 可变配置管理</title>
      <link href="/2022/08/24/kubernetes-configmap-ke-bian-pei-zhi-guan-li/"/>
      <url>/2022/08/24/kubernetes-configmap-ke-bian-pei-zhi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-ConfigMap-可变配置管理"><a href="#Kubernetes-ConfigMap-可变配置管理" class="headerlink" title="Kubernetes ConfigMap 可变配置管理"></a>Kubernetes ConfigMap 可变配置管理</h1><p>我们经常都需要为我们的应用程序配置一些特殊的数据，比如密钥、Token 、数据库连接地址或者其他私密的信息。</p><p>对于应用的可变配置在 Kubernetes 中是通过一个 <code>ConfigMap</code> 资源对象来实现的，我们知道许多应用经常会有从配置文件、命令行参数或者环境变量中读取一些配置信息的需求，这些配置信息我们肯定不会直接写死到应用程序中去的，比如你一个应用连接一个 redis 服务，下一次想更换一个了的，还得重新去修改代码，重新制作一个镜像，这肯定是不可取的，而<code>ConfigMap</code> 就给我们提供了向容器中注入配置信息的能力，不仅可以用来保存单个属性，还可以用来保存整个配置文件，比如我们可以用来配置一个 redis 服务的访问地址，也可以用来保存整个 redis 的配置文件。接下来我们就来了解下 <code>ConfigMap</code> 这种资源对象的使用方法。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ConfigMap 顾名思义，叫配置集。它是用于保存配置数据的键值对，可以用来保存单个属性，也可以保存配置文件。</p><blockquote><p>就是把数据存放到 Etcd 中。然后，你就可以通过在 Pod 的容器里挂载 Volume 的方式，访问到这些 ConfigMap 里保存的信息。</p></blockquote><p>configmap 简写为 cm，常用命令如下： </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 创建$ kubectl create configmap# 删除$ kubectl delete configmap ConfigMap名称# 编辑$ kubectl edit configmap ConfigMap名称# 查看-列表$ kubectl get configmap# 查看-详情$ kubectl describe configmap ConfigMap名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们可以使用<code>kubectl create configmap -h</code>来查看关于创建 <code>ConfigMap</code> 的帮助信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Examples:  # Create a new configmap named my-config based on folder bar  kubectl create configmap my-config --from-file=path/to/bar    # Create a new configmap named my-config with specified keys instead of file basenames on disk  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt    # Create a new configmap named my-config with key1=config1 and key2=config2  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2    # Create a new configmap named my-config from the key=value pairs in the file  kubectl create configmap my-config --from-file=path/to/bar    # Create a new configmap named my-config from an env file  kubectl create configmap my-config --from-env-file=path/to/bar.env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到可以使用多种方式来创建ConfigMap</p><ul><li>1）<strong>yaml 描述文件</strong>：事先写好标准的configmap的yaml文件，然后kubectl create -f 创建</li><li>2）<strong>–from-file</strong>：通过指定目录或文件创建，将一个或多个配置文件创建为一个ConfigMap</li><li>3）<strong>–from-literal</strong>：通过直接在命令行中通过 key-value 字符串方式指定configmap参数创建</li><li>4）<strong>–from-env-file</strong>：从 env 文件读取配置信息并创建为一个ConfigMap</li></ul><h3 id="从yaml描述文件创建-ConfigMap"><a href="#从yaml描述文件创建-ConfigMap" class="headerlink" title="从yaml描述文件创建 ConfigMap"></a>从yaml描述文件创建 ConfigMap</h3><p>cm-demo.yaml 如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>demo  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">data.1</span><span class="token punctuation">:</span> hello  <span class="token key atrule">data.2</span><span class="token punctuation">:</span> world  <span class="token key atrule">config</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    property.1=value-1    property.2=value-2    property.3=value-3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ConfigMap</code> 资源对象使用 <code>key-value</code> 形式的键值对来配置数据，这些数据可以在 Pod 里面使用。其中配置数据在 <code>data</code> 属性下面进行配置，前两个被用来保存单个属性，后面一个被用来保存一个配置文件。</p><p>创建 configMap </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create -f cm/cm-demo.yaml configmap/cm-demo created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="从一个给定的目录来创建ConfigMap"><a href="#从一个给定的目录来创建ConfigMap" class="headerlink" title="从一个给定的目录来创建ConfigMap"></a>从一个给定的目录来创建ConfigMap</h3><p>我们可以从一个给定的目录来创建一个 <code>ConfigMap</code> 对象，比如我们有一个 testcm 的目录，该目录下面包含一些配置文件，redis 和 mysql 的连接信息，如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ls testcmredis.confmysql.conf$ cat testcm/redis.confhost=127.0.0.1port=6379$ cat testcm/mysql.confhost=127.0.0.1port=3306<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们就可以使用 <code>from-file</code> 关键字来创建包含这个目录下面所有配置文件的 <code>ConfigMap</code>：</p><pre class="line-numbers language-none"><code class="language-none">[root@k8s-master ~]# kubectl create cm cm-demo1 --from-file=testcmconfigmap/cm-demo1 created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中 <code>from-file</code> 参数指定在该目录下面的所有文件都会被用在 <code>ConfigMap</code> 里面创建一个键值对，<strong>键的名字就是文件名，值就是文件的内容</strong>。创建完成后，同样我们可以使用如下命令来查看 <code>ConfigMap</code> 列表：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get cmNAME               DATA   AGEcm-demo            3      101scm-demo1           2      8skube-root-ca.crt   1      8d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到已经创建了一个 cm-demo1 的 <code>ConfigMap</code> 对象，然后可以使用 <code>describe</code> 命令查看详细信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl describe cm cm-demo1Name:         cm-demo1Namespace:    defaultLabels:       &lt;none&gt;Annotations:  &lt;none&gt;Data====mysql.conf:----host=127.0.0.1port=3306redis.conf:----host=127.0.0.1port=6379Events:  &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到两个 <code>key</code> 是 testcm 目录下面的文件名称，对应的 <code>value</code> 值就是文件内容，这里值得注意的是如果文件里面的配置信息很大的话，<code>describe</code> 的时候可能不会显示对应的值，要查看完整的键值，可以使用如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get cm cm-demo1 -o yamlapiVersion: v1data:  mysql.conf: |    host=127.0.0.1    port=3306  redis.conf: |    host=127.0.0.1    port=6379kind: ConfigMapmetadata:  creationTimestamp: "2022-08-22T06:39:38Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:mysql.conf: {}        f:redis.conf: {}    manager: kubectl-create    operation: Update    time: "2022-08-22T06:39:38Z"  name: cm-demo1  namespace: default  resourceVersion: "80137"  uid: 2c23a5a2-b4ac-47e9-b0fa-a50d7395797c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用指定的文件进行创建ConfigMap"><a href="#使用指定的文件进行创建ConfigMap" class="headerlink" title="使用指定的文件进行创建ConfigMap"></a>使用指定的文件进行创建ConfigMap</h3><p>以上面的配置文件为例，我们为 redis 的配置单独创建一个 <code>ConfigMap</code> 对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create cm cm-demo2 --from-file=testcm/redis.conf configmap/cm-demo2 created[root@k8s-master ~]# kubectl get cmNAME               DATA   AGEcm-demo            3      4m56scm-demo1           2      3m23scm-demo2           1      36skube-root-ca.crt   1      8d[root@k8s-master ~]# kubectl get cm cm-demo2 -o yamlapiVersion: v1data:  redis.conf: |    host=127.0.0.1    port=6379kind: ConfigMapmetadata:  creationTimestamp: "2022-08-22T06:42:25Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:redis.conf: {}    manager: kubectl-create    operation: Update    time: "2022-08-22T06:42:25Z"  name: cm-demo2  namespace: default  resourceVersion: "80395"  uid: 75652115-e5f6-4968-ac1e-504675b98530<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在命令行中通过字符串方式创建ConfigMap"><a href="#在命令行中通过字符串方式创建ConfigMap" class="headerlink" title="在命令行中通过字符串方式创建ConfigMap"></a>在命令行中通过字符串方式创建ConfigMap</h3><p>通过帮助文档我们可以看到我们还可以直接使用字符串进行创建，通过 <code>--from-literal</code> 参数传递配置信息，同样的，这个参数可以使用多次，格式如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create configmap cm-demo3 --from-literal=db.host=localhost --from-literal=db.port=3306configmap/cm-demo3 created[root@k8s-master ~]# kubectl get cm cm-demo3 -o yamlapiVersion: v1data:  db.host: localhost  db.port: "3306"kind: ConfigMapmetadata:  creationTimestamp: "2022-08-22T06:44:36Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:db.host: {}        f:db.port: {}    manager: kubectl-create    operation: Update    time: "2022-08-22T06:44:36Z"  name: cm-demo3  namespace: default  resourceVersion: "80599"  uid: 88bc0a75-de42-48c3-aaf9-29cf30af8dfa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从-env-文件读取配置信息并创建ConfigMap"><a href="#从-env-文件读取配置信息并创建ConfigMap" class="headerlink" title="从 env 文件读取配置信息并创建ConfigMap"></a>从 env 文件读取配置信息并创建ConfigMap</h3><p><code>conf.env</code>文件如下</p><blockquote><p>语法为 key=value</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">id=1name=zhangquan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>–from-env-file</code>创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]#  kubectl create cm cm-demo4 --from-env-file=cm/conf.envconfigmap/cm-demo4 created[root@k8s-master ~]# kubectl get cm cm-demo4 -o yamlapiVersion: v1data:  id: "1"  name: zhangquankind: ConfigMapmetadata:  creationTimestamp: "2022-08-22T06:51:52Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:id: {}        f:name: {}    manager: kubectl-create    operation: Update    time: "2022-08-22T06:51:52Z"  name: cm-demo4  namespace: default  resourceVersion: "81265"  uid: a96487d0-b2ac-4db6-8f51-e693dbe35883<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>ConfigMap</code> 创建成功了，那么我们应该怎么在 Pod 中来使用呢？ <code>ConfigMap</code> 这些配置数据可以通过很多种方式在 Pod 里使用，主要有以下几种方式：</p><ul><li>用作环境变量</li><li>在容器里设置命令行参数</li><li>使用 Volume 将 ConfigMap 作为文件或目录挂载</li></ul><p><strong>注意</strong></p><ol><li><p>ConfigMap 必须在 Pod 使用它之前创建</p></li><li><p>使用 envFrom 时，将会自动忽略无效的键</p></li><li><p>一个Pod 只能使用同一个命名空间的 ConfigMap</p></li></ol><h3 id="用作环境变量"><a href="#用作环境变量" class="headerlink" title="用作环境变量"></a>用作环境变量</h3><p>首先，我们使用 <code>ConfigMap</code> 来填充我们的环境变量，如下所示的 Pod 资源对象：testcm1.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> testcm1<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> testcm1      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"env"</span> <span class="token punctuation">]</span>      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> DB_HOST          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>demo3              <span class="token key atrule">key</span><span class="token punctuation">:</span> db.host        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> DB_PORT          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>demo3              <span class="token key atrule">key</span><span class="token punctuation">:</span> db.port      <span class="token key atrule">envFrom</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">configMapRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>demo1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>env</code>单个指定或者通过<code>envFrom</code>直接加载整个 configmap</p><p>根据以上 yaml 文件创建 pod 并查看日志</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f cm/testcm1.yaml pod/testcm1-pod created# 查看日志 会打印出一堆环境变量 其中就有我们指定的 configmap[root@k8s-master ~]# kubectl logs testcm1-pod......DB_HOST=localhostDB_PORT=3306mysql.conf=host=127.0.0.1port=3306redis.conf=host=127.0.0.1port=6379......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在容器里设置命令行参数"><a href="#在容器里设置命令行参数" class="headerlink" title="在容器里设置命令行参数"></a>在容器里设置命令行参数</h3><p><code>ConfigMap</code> 也可以被用来设置容器中的命令或者参数值，如下 Pod:  testcm2.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> testcm2<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> testcm2      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo $(DB_HOST) $(DB_PORT)"</span> <span class="token punctuation">]</span>      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> DB_HOST          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>demo3              <span class="token key atrule">key</span><span class="token punctuation">:</span> db.host        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> DB_PORT          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>demo3              <span class="token key atrule">key</span><span class="token punctuation">:</span> db.port<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据以上 yaml 文件创建 pod 并查看日志：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f cm/testcm2.yaml pod/testcm2-pod created[root@k8s-master ~]# kubectl logs testcm2-pod localhost 3306<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用-Volume-将-ConfigMap-作为文件或目录挂载"><a href="#使用-Volume-将-ConfigMap-作为文件或目录挂载" class="headerlink" title="使用 Volume 将 ConfigMap 作为文件或目录挂载"></a>使用 Volume 将 ConfigMap 作为文件或目录挂载</h3><p>另外一种是非常常见的使用 <code>ConfigMap</code> 的方式：通过<strong>数据卷</strong>使用，在数据卷里面使用 ConfigMap，就是将文件填入数据卷，在这个文件中，键就是文件名，键值就是文件内容，</p><ul><li><p>先创建 ConfigMap</p><ul><li><p>redis.conf 文件内容如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">appendonly yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建 ConfigMap</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create cm redis-conf --from-file=cm/redis.confconfigmap/redis-conf created[root@k8s-master ~]# kubectl get cm redis-conf -o yamlapiVersion: v1data:  redis.conf: |    appendonly yeskind: ConfigMapmetadata:  creationTimestamp: "2022-08-22T07:26:54Z"  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:data:        .: {}        f:redis.conf: {}    manager: kubectl-create    operation: Update    time: "2022-08-22T07:26:54Z"  name: redis-conf  namespace: default  resourceVersion: "84601"  uid: 309e08bc-1ea3-4370-9998-332eb3d22016<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>创建测试 Pod，如下资源对象所示：testcmredis.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> redis    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis    <span class="token key atrule">command</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> redis<span class="token punctuation">-</span>server      <span class="token punctuation">-</span> <span class="token string">"/redis-master/redis.conf"</span>  <span class="token comment">#指的是redis容器内部的位置</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data      <span class="token key atrule">name</span><span class="token punctuation">:</span> data    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /redis<span class="token punctuation">-</span>master      <span class="token key atrule">name</span><span class="token punctuation">:</span> config  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data      <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>conf        <span class="token key atrule">items</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> redis.conf          <span class="token key atrule">path</span><span class="token punctuation">:</span> redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-configMap-1.png"></p><ul><li><p>根据以上 yaml 文件创建 pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f cm/testcmredis.yaml pod/redis created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>进入 Pod 查看配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl exec -it redis -- redis-cli127.0.0.1:6379&gt; CONFIG GET appendonly1) "appendonly"2) "yes"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在外面把修改了，容器里的配置也会跟着修改</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 修改配置[root@k8s-master ~]# kubectl edit cm redis-conf# Please edit the object below. Lines beginning with a '#' will be ignored,# and an empty file will abort the edit. If an error occurs while saving this file will be# reopened with the relevant failures.#apiVersion: v1data:  redis.conf: |    appendonly yes    requirepass 123456  #新增这一行kind: ConfigMapmetadata:  creationTimestamp: "2022-08-22T07:26:54Z"  name: redis-conf  namespace: default  resourceVersion: "84601"  uid: 309e08bc-1ea3-4370-9998-332eb3d22016  # 进入 Pod 内查看配置文件内容[root@k8s-master ~]# kubectl exec -it redis -- /bin/bashroot@redis:/data# cat /redis-master/redis.conf appendonly yesrequirepass 123456# 连接上redis服务器查看配置，可以看到 requirepass 配置没有生效，这是因为文件是热更新了，但应用没有热更新# 所以，当 `ConfigMap` 以数据卷的形式挂载进 `Pod` 的时，这时更新 `ConfigMap（或删掉重建ConfigMap）`，Pod 内挂载的配# # 置信息会热更新。这时可以增加一些监测配置文件变更的脚本，然后重加载对应服务就可以实现应用的热更新。[root@k8s-master ~]# kubectl exec -it redis -- /bin/bashroot@redis:/data# redis-cli127.0.0.1:6379&gt; CONFIG GET appendonly1) "appendonly"2) "yes"127.0.0.1:6379&gt; CONFIG GET requirepass1) "requirepass"2) ""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/</a></p></li><li><p><a href="https://www.qikqiak.com/k8strain/config/configmap/">https://www.qikqiak.com/k8strain/config/configmap/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 持久化存储PV 和 PVC 的使用</title>
      <link href="/2022/08/21/kubernetes-chi-jiu-hua-cun-chu-pv-he-pvc-de-shi-yong/"/>
      <url>/2022/08/21/kubernetes-chi-jiu-hua-cun-chu-pv-he-pvc-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-持久化存储PV-和-PVC-的使用"><a href="#Kubernetes-持久化存储PV-和-PVC-的使用" class="headerlink" title="Kubernetes 持久化存储PV 和 PVC 的使用"></a>Kubernetes 持久化存储PV 和 PVC 的使用</h1><p>我们知道可以通过 <code>hostPath</code> 或者 <code>emptyDir</code> 的方式来持久化我们的数据，但是显然我们还需要更加可靠的存储来保存应用的持久化数据，这样容器在重建后，依然可以使用之前的数据。但是显然存储资源和 CPU 资源以及内存资源有很大不同，为了屏蔽底层的技术实现细节，让用户更加方便的使用，<code>Kubernetes</code> 便引入了 <code>PV</code> 和 <code>PVC</code> 两个重要的资源对象来实现对存储的管理。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>PV</code> 的全称是：<code>PersistentVolume</code>（持久化卷），是对底层的共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 <code>Ceph</code>、<code>GlusterFS</code>、<code>NFS</code> 等，都是通过插件机制完成与共享存储的对接。</p><p><code>PVC</code> 的全称是：<code>PersistentVolumeClaim</code>（持久化卷声明），PVC 是用户存储的一种声明，PVC 和 Pod 比较类似，Pod 消耗的是节点，PVC 消耗的是 PV 资源，Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直接使用 PVC 即可。</p><p>但是通过 PVC 请求到一定的存储空间也很有可能不足以满足应用对于存储设备的各种需求，而且不同的应用程序对于存储性能的要求可能也不尽相同，比如读写速度、并发性能等，为了解决这一问题，Kubernetes 又为我们引入了一个新的资源对象：<code>StorageClass</code>，通过 StorageClass 的定义，管理员可以将存储资源定义为某种类型的资源，比如快速存储、慢速存储等，用户根据 StorageClass 的描述就可以非常直观的知道各种存储资源的具体特性了，这样就可以根据应用的特性去申请合适的存储资源了。</p><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><p>我们这里为了演示方便，使用相对简单的 NFS 这种存储资源，接下来我们在节点 <strong>k8s-master</strong> 上来安装 NFS 服务器，数据目录：/nfs/data，k8s-node1，k8s-node2安装NFS 客户端</p><h3 id="k8s-master-节点上操作"><a href="#k8s-master-节点上操作" class="headerlink" title="k8s-master 节点上操作"></a>k8s-master 节点上操作</h3><ul><li><p>安装 NFS 服务器软件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum install -y  nfs-utils rpcbind<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建挂载目录并设置权限</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 创建挂载目录mkdir -p /nfs/data# 设置权限chmod 755 /nfs/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置 nfs，nfs 的默认配置文件在 /etc/exports 文件下，在该文件中添加下面的配置信息：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ vi /etc/exports/nfs/data/ *(insecure,rw,sync,no_root_squash)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置说明：</p><ul><li><p><code>/nfs/data/</code>：是共享的数据目录</p></li><li><p><code>*</code>：表示任何人都有权限连接，当然也可以是一个网段，一个 IP，也可以是域名</p></li><li><p>insecure：允许客户端从大于1024的tcp/ip端口连接服务器</p></li><li><p>rw：读写的权限</p></li><li><p>sync：表示文件同时写入硬盘和内存</p></li><li><p>no_root_squash：当登录 NFS 主机使用共享目录的使用者是 root 时，其权限将被转换成为匿名使用者，通常它的 UID 与 GID，都会变成 nobody 身份</p><p>当然 nfs 的配置还有很多，感兴趣的同学可以在网上去查找一下。</p></li></ul></li><li><p>先启动 rpcbind</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# systemctl start rpcbind.service[root@k8s-master ~]# systemctl enable rpcbind[root@k8s-master ~]# systemctl status rpcbind● rpcbind.service - RPC bind service   Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled)   Active: active (running) since Sun 2022-08-21 20:40:07 CST; 9s ago Main PID: 5229 (rpcbind)   CGroup: /system.slice/rpcbind.service           └─5229 /sbin/rpcbind -wAug 21 20:40:07 k8s-master systemd[1]: Starting RPC bind service...Aug 21 20:40:07 k8s-master systemd[1]: Started RPC bind service.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后启动 nfs 服务器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# systemctl start nfs.service[root@k8s-master ~]# systemctl enable nfsCreated symlink from /etc/systemd/system/multi-user.target.wants/nfs-server.service to /usr/lib/systemd/system/nfs-server.service.[root@k8s-master ~]# systemctl status nfs● nfs-server.service - NFS server and services   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; enabled; vendor preset: disabled)  Drop-In: /run/systemd/generator/nfs-server.service.d           └─order-with-mounts.conf   Active: active (exited) since Sun 2022-08-21 20:40:32 CST; 9s ago Main PID: 5689 (code=exited, status=0/SUCCESS)   CGroup: /system.slice/nfs-server.serviceAug 21 20:40:32 k8s-master systemd[1]: Starting NFS server and services...Aug 21 20:40:32 k8s-master systemd[1]: Started NFS server and services.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使配置生效</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">exportfs -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>确认配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# exportfs/nfs/data       &lt;world&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="K8s-node1、k8s-node2-节点上操作"><a href="#K8s-node1、k8s-node2-节点上操作" class="headerlink" title="K8s-node1、k8s-node2 节点上操作"></a>K8s-node1、k8s-node2 节点上操作</h3><p>到这里我们就把 nfs server 给安装成功了，接下来我们在 node 节点上来安装 nfs 的客户端来验证下 nfs</p><ul><li><p>安装 NFS客户端 软件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum install -y  nfs-utils rpcbind<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>挂载数据目录 客户端启动完成后，我们在客户端来挂载下 nfs 测试下</p><ul><li><p>查看下 NFS 服务器有哪些目录供我们挂载</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 使用内网 ip 查看就行[root@k8s-node1 ~]# showmount -e 172.31.0.2Export list for 172.31.0.2:/nfs/data *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后我们在客户端上新建目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p /root/nfsmount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将 nfs 共享目录挂载到上面的目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mount -t nfs 172.31.0.2:/nfs/data /root/nfsmount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>挂载成功后，在客户端上面的目录中新建一个文件，然后我们观察下 nfs 服务端的共享目录下面是否也会出现该文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 在 nfs server 上写一个测试文件[root@k8s-master ~]# echo "hello nfs server" &gt; /nfs/data/test.txt # 然后在 nfs client端查看[root@k8s-node1 ~]# cat /root/nfsmount/test.txt hello nfs server[root@k8s-node2 ~]# cat /root/nfsmount/test.txt hello nfs server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="原生方式数据挂载"><a href="#原生方式数据挂载" class="headerlink" title="原生方式数据挂载"></a>原生方式数据挂载</h2><ul><li>资源文件 nginx-pv-demo.yaml </li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pv<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token key atrule">nfs</span><span class="token punctuation">:</span>            <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.31.0.2 <span class="token comment">#写上自己master节点的内网ip</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/nginx<span class="token punctuation">-</span>pv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面资源清单文件的意思是我们生成两个Pod，这两个Pod的镜像来自nginx，<code>volumeMounts.mountPath: /usr/share/nginx/html</code> 表示需要挂载，挂载到<code>nvolumeMounts.name: html</code>，最终效果就是 <code>/usr/share/nginx/html</code> 目录与<code>/nfs/data/nginx-pv</code>目录操持同步</p><ul><li><p>创建目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir /nfs/data/nginx-pv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行资源清单</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f storage/nginx-pv-demo.yaml deployment.apps/nginx-pv-demo created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看部署</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deployNAME            READY   UP-TO-DATE   AVAILABLE   AGEnginx-pv-demo   2/2     2            2           8m43s[root@k8s-master ~]# kubectl get podsNAME                             READY   STATUS    RESTARTS   AGEnginx-pv-demo-6ff58db964-c7vqw   1/1     Running   0          8m48snginx-pv-demo-6ff58db964-ggzp7   1/1     Running   0          8m48s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改挂载目录后，测试Pod中的目录也同步修改</p><ul><li><p>查看挂载目录 </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# ll /nfs/data/nginx-pv/total 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改 nginx 默认首页</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# echo "success" &gt; /nfs/data/nginx-pv/index.html   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>进入 Pod 中查看</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 第一个 pod[root@k8s-master ~]# kubectl exec -it nginx-pv-demo-6ff58db964-c7vqw -- /bin/bashroot@nginx-pv-demo-6ff58db964-c7vqw:/# curl localhostsuccessroot@nginx-pv-demo-6ff58db964-c7vqw:/# cat /usr/share/nginx/html/index.html success# 第二个 pod[root@k8s-master ~]# kubectl exec -it nginx-pv-demo-6ff58db964-ggzp7 -- /bin/bashroot@nginx-pv-demo-6ff58db964-ggzp7:/# curl localhostsuccessroot@nginx-pv-demo-6ff58db964-ggzp7:/# cat /usr/share/nginx/html/index.html success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>原生方式数据挂载的方式有以下几个问题：</p><ol><li><p>要挂载的目录需要我们手动创建，比如上面的 <code>nfs/data/nginx-pv</code>目录 </p></li><li><p>我们把部署的Pod删除之后，我们挂载的文件还存在，不会跟着Pod一起删除，下面我们来验证这一点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 删除上面原生方式数据挂载产生的 Pod[root@k8s-master ~]# kubectl delete -f storage/nginx-pv-demo.yaml deployment.apps "nginx-pv-demo" deleted# 查看挂载目录[root@k8s-master ~]# cat  /nfs/data/nginx-pv/index.html   success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于 Pod 挂载的的目录没有存储容易的限制</p></li></ol><p>所以我们就有了 PV，PVC 挂载方式</p><h2 id="PV-与-PVC"><a href="#PV-与-PVC" class="headerlink" title="PV 与 PVC"></a>PV 与 PVC</h2><p>下面我们来使用 PV 和 PVC 了。PV 作为存储资源，主要包括存储能力、访问模式、存储类型、回收策略等关键信息，可以把上面<code>/nfs/data/nginx-pv</code> 目录比作持久卷。持久卷就是我们的数据要存在哪？数据存储的位置叫做持久卷，PVC 相当于申请，你的Pod想要申请多大的磁盘空间。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-storage-pv.png"></p><p>下面我们来测试下 PV 与PVC的使用</p><h3 id="创建-pv-池"><a href="#创建-pv-池" class="headerlink" title="创建 pv 池"></a>创建 pv 池</h3><p>我的场地先创建出来做准备好，你Pod如果要使用就写好申请书（PVC）来申请</p><ul><li><p>nfs 服务器上（master节点上）执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p /nfs/data/01mkdir -p /nfs/data/02mkdir -p /nfs/data/03<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>准备资源文件 nfs-pv.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume  <span class="token comment"># 持久化卷</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv01<span class="token punctuation">-</span>10m<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token comment">#限制存储容量</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 10M  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token comment">#可读可写</span>  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token comment">#取一个storageClassName名称</span>  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/01    <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.31.0.2 <span class="token comment">#nfs服务器的ip</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume  <span class="token comment"># 持久化卷</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>   <span class="token key atrule">name</span><span class="token punctuation">:</span> pv02<span class="token punctuation">-</span>1gi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/02    <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.31.0.2 <span class="token comment">#nfs服务器的ip</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv03<span class="token punctuation">-</span>3gi  <span class="token comment"># g要小写</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 3Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /nfs/data/03    <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.31.0.2  <span class="token comment">#nfs服务器的ip</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行上面的资源文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f storage/nfs-pv.yaml persistentvolume/pv01-10m createdpersistentvolume/pv02-1gi createdpersistentvolume/pv03-3gi created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看PV</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pvNAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGEpv01-10m   10M        RWX            Retain           Available           nfs                     22spv02-1gi   1Gi        RWX            Retain           Available           nfs                     22spv03-3gi   3Gi        RWX            Retain           Available           nfs                     22s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="创建-pvc"><a href="#创建-pvc" class="headerlink" title="创建 pvc"></a>创建 pvc</h3><p>pvc 相当于我们的申请书，可以类比学校里在操场上搞活动，场地（pv）已经有了，哪个班级需要使用多大的场地就写一份申请书来申请场地</p><ul><li><p>准备nfs-pvc.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc <span class="token comment">#申请书名称随便写</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteMany  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 200Mi <span class="token comment"># 我需要一个 200M的空间</span>  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs <span class="token comment">#这个值要和 nfs-pv.yaml中的 storageClassName 值一致</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行创建</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f storage/nfs-pvc.yaml persistentvolumeclaim/nginx-pvc created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看pvc，pv情况</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pvcNAME        STATUS   VOLUME     CAPACITY   ACCESS MODES   STORAGECLASS   AGEnginx-pvc   Bound    pv02-1gi   1Gi        RWX            nfs            2m11s[root@k8s-master ~]# kubectl get pvNAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM               STORAGECLASS   REASON   AGEpv01-10m   10M        RWX            Retain           Available                       nfs                     11mpv02-1gi   1Gi        RWX            Retain           Bound       default/nginx-pvc   nfs                     11mpv03-3gi   3Gi        RWX            Retain           Available                       nfs                     11m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="创建Pod绑定PVC"><a href="#创建Pod绑定PVC" class="headerlink" title="创建Pod绑定PVC"></a>创建Pod绑定PVC</h3><ul><li><p>准备 nginx-deploy-pvc.yaml </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deploy<span class="token punctuation">-</span>pvc    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> html          <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>            <span class="token key atrule">claimName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>pvc    <span class="token comment"># pvc名称（申请书名称）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>比原生方式数据挂载的比较 volumes 使用的是 persistentVolumeClaim</p><p>表示 <code>/usr/share/nginx/html</code>目录与申请书 <code>nginx-pvc</code>内容保持一致的</p><ul><li><p>执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f storage/nginx-deploy-pvc.yaml deployment.apps/nginx-deploy-pvc created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get podsNAME                                READY   STATUS    RESTARTS   AGEnginx-deploy-pvc-79fc8558c7-9vswp   1/1     Running   0          18snginx-deploy-pvc-79fc8558c7-pgtlb   1/1     Running   0          18s[root@k8s-master ~]# kubectl get pv,pvcNAME                        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM               STORAGECLASS   REASON   AGEpersistentvolume/pv01-10m   10M        RWX            Retain           Available                       nfs                     25mpersistentvolume/pv02-1gi   1Gi        RWX            Retain           Bound       default/nginx-pvc   nfs                     25mpersistentvolume/pv03-3gi   3Gi        RWX            Retain           Available                       nfs                     25mNAME                              STATUS   VOLUME     CAPACITY   ACCESS MODES   STORAGECLASS   AGEpersistentvolumeclaim/nginx-pvc   Bound    pv02-1gi   1Gi        RWX            nfs            15m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改内容，可以看到分配给 pv02-1gi ，所以修改 /nfs/data/02</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# ll /nfs/data/02/total 0[root@k8s-master ~]# echo "hello,pv,pvc" &gt; /nfs/data/02/index.html  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>进入 Pod 中验证有效</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl exec -it nginx-deploy-pvc-79fc8558c7-9vswp -- /bin/bashroot@nginx-deploy-pvc-79fc8558c7-9vswp:/# curl localhosthello,pv,pvcroot@nginx-deploy-pvc-79fc8558c7-9vswp:/# cat /usr/share/nginx/html/index.html hello,pv,pvc[root@k8s-master ~]# kubectl exec -it nginx-deploy-pvc-79fc8558c7-pgtlb -- /bin/bashroot@nginx-deploy-pvc-79fc8558c7-pgtlb:/# curl localhosthello,pv,pvcroot@nginx-deploy-pvc-79fc8558c7-pgtlb:/# cat /usr/share/nginx/html/index.html hello,pv,pvc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>需要注意的是，我们上面手动创建 PV 的方式，即静态的 PV 管理方式，在删除 PV 时需要按如下流程执行操作：</p><ul><li>删除使用这个 PV 的 Pod</li><li>从宿主机移除本地磁盘</li><li>删除 PVC</li><li>删除 PV</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Ingress实践练习</title>
      <link href="/2022/08/21/kubernetes-ingress-shi-jian-lian-xi/"/>
      <url>/2022/08/21/kubernetes-ingress-shi-jian-lian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Ingress-nginx-的使用"><a href="#Kubernetes-Ingress-nginx-的使用" class="headerlink" title="Kubernetes Ingress-nginx 的使用"></a>Kubernetes Ingress-nginx 的使用</h1><p>我们知道可以使用 <code>NodePort</code> 和 <code>LoadBlancer</code> 类型的 Service 可以把应用暴露给外部用户使用，除此之外，Kubernetes 还为我们提供了一个非常重要的资源对象可以用来暴露服务给外部用户，那就是 <code>Ingress</code>。对于小规模的应用我们使用 NodePort 或许能够满足我们的需求，但是当你的应用越来越多的时候，你就会发现对于 NodePort 的管理就非常麻烦了，这个时候使用 Ingress 就非常方便了，可以避免管理大量的端口。</p><p>Ingress 其实就是从 Kuberenets 集群外部访问集群的一个入口，将外部的请求转发到集群内不同的 Service 上，其实就相当于 nginx、haproxy 等负载均衡代理服务器，可能你会觉得我们直接使用 nginx 就实现了，但是只使用 nginx 这种方式有很大缺陷，每次有新服务加入的时候怎么改 Nginx 配置？不可能让我们去手动更改或者滚动更新前端的 Nginx Pod 吧？那我们再加上一个服务发现的工具比如 consul 如何？貌似是可以，对吧？Ingress 实际上就是这样实现的，只是服务发现的功能自己实现了，不需要使用第三方的服务了，然后再加上一个域名规则定义，路由信息的刷新依靠 Ingress Controller 来提供。</p><p>Ingress Controller 可以理解为一个监听器，通过不断地监听 kube-apiserver，实时的感知后端 Service、Pod 的变化，当得到这些信息变化后，Ingress Controller 再结合 Ingress 的配置，更新反向代理负载均衡器，达到服务发现的作用。其实这点和服务发现工具 consul、 consul-template 非常类似。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/nginx-ingress-controller.png"></p><p>现在可以供大家使用的 Ingress Controller 有很多，比如 traefik、nginx-controller、Kubernetes Ingress Controller for Kong、HAProxy Ingress controller，当然你也可以自己实现一个 Ingress Controller，现在普遍用得较多的是 traefik 和 nginx-controller，traefik 的性能较 nginx-controller 差，但是配置使用要简单许多，这里给大家介绍 nginx-controller 的使用。</p><h2 id="安装-Ingress-nginx"><a href="#安装-Ingress-nginx" class="headerlink" title="安装 Ingress-nginx"></a>安装 Ingress-nginx</h2><p>NGINX Ingress Controller 是使用 Kubernetes Ingress 资源对象构建的，用 ConfigMap 来存储 Nginx 配置的一种 Ingress Controller 实现。</p><p>要使用 Ingress 对外暴露服务，就需要提前安装一个 Ingress Controller，我们这里就先来安装 NGINX Ingress Controller。</p><p>我们主要目的是为了测试，就使用Bare metal clusters（裸机集群）的部署方式，裸机集群方式会使用 30000-32767 范围内的端口。</p><p>部署参考资料：</p><ul><li><a href="https://github.com/kubernetes/ingress-nginx/tree/main/deploy/static/provider">https://github.com/kubernetes/ingress-nginx/tree/main/deploy/static/provider</a></li><li><a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/index.md">https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/index.md</a></li><li><a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/baremetal.md">https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/baremetal.md</a></li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 下载资源清单文件wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml -O ingress.yaml#修改镜像vi ingress.yaml# 将 kind: Deployment 中的 spec.template.spec.containers[0].image 的值改为如下值：registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0# 执行资料清单[root@k8s-master ingress]# kubectl apply -f ingress.yaml namespace/ingress-nginx createdserviceaccount/ingress-nginx createdconfigmap/ingress-nginx-controller createdclusterrole.rbac.authorization.k8s.io/ingress-nginx createdclusterrolebinding.rbac.authorization.k8s.io/ingress-nginx createdrole.rbac.authorization.k8s.io/ingress-nginx createdrolebinding.rbac.authorization.k8s.io/ingress-nginx createdservice/ingress-nginx-controller-admission createdservice/ingress-nginx-controller createddeployment.apps/ingress-nginx-controller createdvalidatingwebhookconfiguration.admissionregistration.k8s.io/ingress-nginx-admission createdserviceaccount/ingress-nginx-admission createdclusterrole.rbac.authorization.k8s.io/ingress-nginx-admission createdclusterrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission createdrole.rbac.authorization.k8s.io/ingress-nginx-admission createdrolebinding.rbac.authorization.k8s.io/ingress-nginx-admission createdjob.batch/ingress-nginx-admission-create createdjob.batch/ingress-nginx-admission-patch created# 检查安装的结果[root@k8s-master ingress]#  kubectl get pod,svc -n ingress-nginxNAME                                            READY   STATUS      RESTARTS   AGEpod/ingress-nginx-admission-create-kv747        0/1     Completed   0          7m33spod/ingress-nginx-admission-patch-76tx4         0/1     Completed   0          7m33spod/ingress-nginx-controller-65bf56f7fc-p9jbs   1/1     Running     0          7m33sNAME                                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGEservice/ingress-nginx-controller             NodePort    10.96.197.163   &lt;none&gt;        80:31688/TCP,443:31390/TCP   7m33sservice/ingress-nginx-controller-admission   ClusterIP   10.96.169.165   &lt;none&gt;        443/TCP                      7m33s# 可以看到 ingress-nginx 通过 NodePort 方式帮我们暴露出来了一个http的端口31688，一个https的端口31390# 最后别忘记把svc暴露的端口 31688,31390要放行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-nginx-ingress-1.png"></p><p>出现了上面的信息证明 Ingress Controller 已经安装成功。</p><h2 id="Ingress-nginx使用"><a href="#Ingress-nginx使用" class="headerlink" title="Ingress-nginx使用"></a>Ingress-nginx使用</h2><h3 id="准备实验环境"><a href="#准备实验环境" class="headerlink" title="准备实验环境"></a>准备实验环境</h3><p>安装成功后，现在我们先准备好实验环境，如下所示：ingress-demo.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server        <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hangzhou.aliyuncs.com/lfy_k8s_images/hello<span class="token punctuation">-</span>server        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">9000</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接创建上面的资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ingress]# kubectl apply -f ingress-demo.yaml deployment.apps/hello-server createddeployment.apps/nginx-demo createdservice/nginx-demo createdservice/hello-server created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看创建的 deploy 和 servcie</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deployNAME           READY   UP-TO-DATE   AVAILABLE   AGEhello-server   2/2     2            2           5m11snginx-demo     2/2     2            2           5m11s[root@k8s-master ~]# kubectl get svcNAME           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGEhello-server   ClusterIP   10.96.252.210   &lt;none&gt;        8000/TCP   5m15skubernetes     ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    7d20hnginx-demo     ClusterIP   10.96.26.158    &lt;none&gt;        8000/TCP   5m15s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="域名访问"><a href="#域名访问" class="headerlink" title="域名访问"></a>域名访问</h3><p>假如我们的需求是：</p><p>请求 hello.zhangquan.me:31688把请求转发给 service-hello-server 进行处理</p><p>请求 demo.zhangquan.me:31688把请求转发给 service-nginx-demo 进行处理</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-nginx-ingress-domain-access.png"></p><p>资源文件如下： ingress-domain-access.yaml </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress  <span class="token comment"># 一个 ingress 相当一个转发规则</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>host<span class="token punctuation">-</span>bar <span class="token comment"># ingress名称</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"hello.zhangquan.me"</span>  <span class="token comment">#如果是改域名下的请求就应用下面的转发规则</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"demo.zhangquan.me"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>  <span class="token comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token comment">## java，比如使用路径重写，去掉前缀nginx</span>            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 hosts 文件让hello.zhangquan.me,demo.zhangquan.me这两个域名能够解析到我们的master节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># hosts 文件中加入这二行k8s-master-ip hello.zhangquan.mek8s-master-ip demo.zhangquan.me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建上面的资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f ingress/ingress-domain-access.yaml ingress.networking.k8s.io/ingress-host-bar created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看创建结果：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get ingressNAME               CLASS   HOSTS                                  ADDRESS   PORTS   AGEingress-host-bar   nginx   hello.zhangquan.me,demo.zhangquan.me             80      5s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到这个规则匹配了两个域名hello.zhangquan.me,demo.zhangquan.me，只要是这两个域名的请求就会按照 ingress-domain-access.yaml  文件中的规则进行处理。</p><p>访问 hello.zhangquan.me 转发到 hell-server 处理</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-nginx-ingress-2.png"></p><p>访问 demo.zhangquan.me 转发到 nginx-demo 处理</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-nginx-ingress-3.png"></p><h3 id="URL-Rewrite"><a href="#URL-Rewrite" class="headerlink" title="URL Rewrite"></a>URL Rewrite</h3><p>NGINX Ingress Controller 很多高级的用法可以通过 Ingress 对象的 <code>annotation</code> 进行配置，比如常用的 URL Rewrite 功能，现在我们需要对访问的 URL 路径做一个 Rewrite，比如在 PATH 中添加一个 nginx 的前缀，关于 Rewrite 的操作在 <a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/">ingress-nginx 官方文档</a>中也给出对应的说明，对应的 Ingress 资源对象如下所示：ingress-url-rewrite.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress  <span class="token comment"># 一个 ingress 相当一个转发规则</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /$2  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>url<span class="token punctuation">-</span>rewrite <span class="token comment"># ingress名称</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"hello.zhangquan.io"</span>  <span class="token comment">#如果是改域名下的请求就应用下面的转发规则</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>server            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"demo.zhangquan.io"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/nginx(/|$)(.*)"</span>  <span class="token comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo  <span class="token comment">## java，比如使用路径重写，去掉前缀nginx</span>            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 hosts 文件让hello.zhangquan.io,demo.zhangquan.io这两个域名能够解析到我们的master节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># hosts 文件中加入这二行k8s-master-ip hello.zhangquan.me.hello.zhangquan.iok8s-master-ip demo.zhangquan.me,demo.zhangquan.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f ingress/ingress-url-rewrite.yaml ingress.networking.k8s.io/ingress-url-rewrite created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看 ingress：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get ingNAME                  CLASS   HOSTS                                  ADDRESS      PORTS   AGEingress-host-bar      nginx   hello.zhangquan.me,demo.zhangquan.me   172.31.0.4   80      47mingress-url-rewrite   nginx   hello.zhangquan.io,demo.zhangquan.io   172.31.0.4   80      28s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们带上 <code>nginx</code> 的前缀去访问：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-nginx-ingress-url-rewrite.png"></p><p>我们可以看到已经可以访问到页面内容了，这是因为我们在 <code>path</code> 中通过正则表达式 <code>/nginx(/|$)(.*)</code>将匹配的路径设置成了 <code>rewrite-target</code> 的目标路径了，所以我们访问 <code>http://demo.zhangquan.io:31688/nginx</code> 的时候实际上相当于访问的就是后端服务的 <code>/</code> 路径</p><h3 id="Rate-Limiting"><a href="#Rate-Limiting" class="headerlink" title="Rate Limiting"></a>Rate Limiting</h3><p>我们测试下限流功能，对应的 Ingress 资源对象如下所示：ingress-limit-rate.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>limit<span class="token punctuation">-</span>rate  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/limit-rps</span><span class="token punctuation">:</span> <span class="token string">"1"</span> <span class="token comment">#每秒只能放一个请求进来</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ingressClassName</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"demo.zhangquan.limitrate"</span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Exact <span class="token comment">#精确模式，必须要访问 demo.zhangquan.limitrate 才行</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"/"</span>        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">service</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>demo            <span class="token key atrule">port</span><span class="token punctuation">:</span>              <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">8000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 hosts 文件让 haha.zhangquan.io 这个域名能够解析到我们的master节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">k8s-master-ip demo.zhangquan.limitrate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建资源对象：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f ingress/ingress-limit-rate.yamlingress.networking.k8s.io/ingress-limit-rate created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看ingress：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get ingNAME                  CLASS   HOSTS                                  ADDRESS      PORTS   AGEingress-host-bar      nginx   hello.zhangquan.me,demo.zhangquan.me   172.31.0.4   80      100mingress-limit-rate    nginx   demo.zhangquan.limitrate               172.31.0.4   80      24singress-url-rewrite   nginx   hello.zhangquan.io,demo.zhangquan.io   172.31.0.4   80      54m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问测试，快速刷新就会响应默认的 503  code</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-nginx-ingress-limit-rate.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://github.com/kubernetes/ingress-nginx/tree/main/deploy/static/provider">https://github.com/kubernetes/ingress-nginx/tree/main/deploy/static/provider</a></p></li><li><p><a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/index.md">https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/index.md</a></p></li><li><p><a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/baremetal.md">https://github.com/kubernetes/ingress-nginx/blob/main/docs/deploy/baremetal.md</a></p></li><li><p><a href="https://kubernetes.github.io/ingress-nginx/">https://kubernetes.github.io/ingress-nginx/</a></p></li><li><p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">https://kubernetes.io/docs/concepts/services-networking/ingress/</a></p></li><li><p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/</a></p></li><li><p><a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/">https://kubernetes.github.io/ingress-nginx/examples/rewrite/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解Kubernetes Ingress</title>
      <link href="/2022/08/21/tu-jie-kubernetes-ingress/"/>
      <url>/2022/08/21/tu-jie-kubernetes-ingress/</url>
      
        <content type="html"><![CDATA[<h1 id="图解Kubernetes-Ingress"><a href="#图解Kubernetes-Ingress" class="headerlink" title="图解Kubernetes Ingress"></a>图解Kubernetes Ingress</h1><p>Kubernetes Ingress 只是 Kubernetes 中的一个普通资源对象，需要一个对应的 Ingress Controller 来解析 Ingress 的规则，暴露服务到外部，比如 ingress-nginx，本质上来说它只是一个 Nginx Pod，然后将请求重定向到其他内部（ClusterIP）服务去，这个 Pod 本身也是通过 Kubernetes 服务暴露出去，最常见的方式是通过 LoadBalancer 来实现的。</p><p>同样本文希望用一个简单清晰的概述，让你来了解 Kubernetes Ingress 背后的东西，让你更容易理解使用的 Ingress。</p><h2 id="为什么要使用-Ingress？"><a href="#为什么要使用-Ingress？" class="headerlink" title="为什么要使用 Ingress？"></a>为什么要使用 Ingress？</h2><p>我们可以使用 Ingress 来使内部服务暴露到集群外部去，它为你节省了宝贵的静态 IP，因为你不需要声明多个 LoadBalancer 服务了，此次，它还可以进行更多的额外配置。下面我们通过一个简单的示例来对 Ingress 进行一些说明吧。</p><h2 id="简单-HTTP-server"><a href="#简单-HTTP-server" class="headerlink" title="简单 HTTP server"></a>简单 HTTP server</h2><p>首先，我们先回到容器、Kubernetes 之前的时代。</p><p>之前我们更多会使用一个（Nginx）HTTP server 来托管我们的服务，它可以通过 HTTP 协议接收到一个特定文件路径的请求，然后在文件系统中检查这个文件路径，如果存在则就返回即可。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-1.png"></p><p>例如，在 Nginx 中，我们可以通过下面的配置来实现这个功能。</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> /folder</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">root</span> /var/www/</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">index</span> index.html</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除了上面提到的功能之外，我们可以当 HTTP server 接收到请求后，将该请求重定向到另一个服务器（意味着它作为代理）去，然后将该服务器的响应重定向到客户端去。对于客户端来说，什么都没有改变，接收到的结果仍然还是请求的文件（如果存在的话）。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-2.png"></p><p>同样如果在 Nginx 中，重定向可以配置成下面的样子：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> /folder</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://second-nginx-server:8000</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这意味着 Nginx 可以从文件系统中提供文件，或者通过代理将响应重定向到其他服务器并返回它们的响应。</p><h2 id="简单的-Kubernetes-示例"><a href="#简单的-Kubernetes-示例" class="headerlink" title="简单的 Kubernetes 示例"></a>简单的 Kubernetes 示例</h2><h3 id="使用-ClusterIP-服务"><a href="#使用-ClusterIP-服务" class="headerlink" title="使用 ClusterIP 服务"></a>使用 ClusterIP 服务</h3><p>在 Kubernetes 中部署应用后，我们应该先去了解 Kubernetes Service 服务。比如我们有两个 worker 节点，有两个服务 <strong>service-nginx</strong> 和 <strong>service-python</strong>，它们指向不同的 pods。这两个服务没有被调度到任何特定的节点上，也就是在任何节点上都有可能，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-3.png"></p><p>在集群内部我们可以通过他们的 Service 服务来请求到 Nginx pods 和 Python pods 上去，现在我们想让这些服务也能从集群外部进行访问，按照前文提到的我们就需要将这些服务转换为 LoadBalancer 服务。</p><h3 id="使用-LoadBalancer-服务"><a href="#使用-LoadBalancer-服务" class="headerlink" title="使用 LoadBalancer 服务"></a>使用 LoadBalancer 服务</h3><p>当然使用 LoadBalancer 服务的前提是我们的 Kubernetes 集群的托管服务商要能支持才行，如果支持我们可以将上面的 ClusterIP 服务转换为 LoadBalancer 服务，可以创建两个外部负载均衡器，将请求重定向到我们的节点 IP，然后重定向到内部的 ClusterIP 服务。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-4.png"></p><p>我们可以看到两个 LoadBalancers 都有自己的 IP，如果我们向 LoadBalancer <code>22.33.44.55</code> 发送请求，它请被重定向到我们的内部的 <strong>service-nginx</strong> 服务去。如果发送请求到 77.66.55.44，它将被重定向到我们的内部的 <strong>service-python</strong> 服务。</p><p>这个确实很方便，但是要知道 IP 地址是比较稀有的，而且价格可不便宜。想象下我们 Kubernetes 集群中不只是两个服务，有很多的话，我们为这些服务创建 LoadBalancers 成本是不是就成倍增加了。</p><p>那么是否有另一种解决方案可以让我们只使用一个 LoadBalancer 就可以把请求转发给我们的内部服务呢？我们先通过手动（非 Kubernetes）的方式来探讨下这个问题。</p><h3 id="手动配置-Nginx-代理服务"><a href="#手动配置-Nginx-代理服务" class="headerlink" title="手动配置 Nginx 代理服务"></a>手动配置 Nginx 代理服务</h3><p>我们知道 Nginx 可以作为一个代理使用，所以我们可以很容易想到运行一个 Nginx 来代理我们的服务。如下图所示，我们新增了一个名为 <strong>service-nginx-proxy</strong> 的新服务，它实际上是我们唯一的一个 LoadBalancer 服务。service-nginx-proxy 仍然会指向一个或多个 <strong>Nginx-pod-endpoints</strong>（为了简单没有在图上标识），之前的另外两个服务转换为简单的 ClusterIP 服务了。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-5.png"></p><p>可以看到我们只分配了一个 IP 地址为 <code>11.22.33.44</code> 的负载均衡器，对于不同的 http 请求路径我们用黄色来进行标记，他们的目标是一致的，只是包含的不同的请求 URL。</p><p><strong>service-nginx-proxy</strong> 服务会根据请求的 URL 来决定他们应该将请求重定向到哪个服务去。</p><p>在上图中我们有两个背后的服务，分别用红色和蓝色进行了标记，红色会重定向到 <strong>service-nginx</strong> 服务，蓝色重定向到 <strong>service-python</strong> 服务。对应的 Nginx 代理配置如下所示：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> /folder</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://service-nginx:3001</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token directive"><span class="token keyword">location</span> /other</span> <span class="token punctuation">{</span>    <span class="token directive"><span class="token keyword">proxy_pass</span> http://service-python:3002</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只是目前我们需要去手动配置 <strong>service-nginx-proxy</strong> 服务，比如新增了一个请求路径需要路由到其他服务去，我们就需要去重新配置 Nginx 的配置让其生效，但是这个确实是一个可行的解决方案，只是有点麻烦而已。</p><p>而 Kubernetes Ingress 就是为了让我们的配置更加容易、更加智能、更容易管理出现的，所以在 Kubernetes 集群中我们会用 Ingress 来代替上面的手动配置的方式将服务暴露到集群外去。</p><h2 id="使用-Kubernetes-Ingress"><a href="#使用-Kubernetes-Ingress" class="headerlink" title="使用 Kubernetes Ingress"></a>使用 Kubernetes Ingress</h2><p>现在我们将上面手动配置代理的方式转换为 Kubernetes Ingress 的方式，如下图所示，我们只是使用了一个预先配置好的 Nginx（Ingress），它已经为我们做了所有的代理重定向工作，这为我们节省了大量的手动配置工作了。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-6.png"></p><p>这其实就已经说明了 Kubernetes Ingress 是什么，下面让我们来看看一些配置实例吧。</p><h2 id="安装-Ingress-控制器"><a href="#安装-Ingress-控制器" class="headerlink" title="安装 Ingress 控制器"></a>安装 Ingress 控制器</h2><p>Ingress 只是 Kubernetes 的一种资源对象而已，在这个资源中我们可以去配置我们的服务路由规则，但是要真正去实现识别这个 Ingress 并提供代理路由功能，还需要安装一个对应的控制器才能实现。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.24.1/deploy/mandatory.yamlkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.24.1/deploy/provider/cloud-generic.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用下面的命令，可以看到安装在命名空间 <strong>ingress-nginx</strong> 中的 k8s 资源。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-7.png"></p><p>我们可以看到一个正常的 LoadBalancer 服务，有一个外部 IP 和一个所属的 pod，我们可以使用命令 <code>kubectl exec</code> 进入该 pod，里面包含一个预配置的 Nginx 服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-8.png"></p><p>其中的 <code>nginx.conf</code> 文件就包含各种代理重定向设置和其他相关配置。</p><h2 id="Ingress-配置示例"><a href="#Ingress-配置示例" class="headerlink" title="Ingress 配置示例"></a>Ingress 配置示例</h2><p>我们所使用的 Ingress yaml 例子可以是这样的。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># just example, not tested</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">kubernetes.io/ingress.class</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>ingress<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /folder        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>nginx          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">3001</span>  <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /other        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>python          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">3002</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和其他资源对象一样，通过 <code>kubectl create -f ingress.yaml</code> 来创建这个资源对象即可，创建完成后这个 Ingress 对象会被上面安装的 Ingress 控制器转换为对应的 Nginx 配置。</p><p>如果你的一个内部服务，即 Ingress 应该重定向到的服务，是在不同的命名空间里，怎么办？因为我们定义的 Ingress 资源是命名空间级别的。在 Ingress 配置中，<strong>只能重定向到同一命名空间的服务</strong>。</p><p>如果你定义了多个 Ingress yaml 配置，那么这些配置会被一个单一的Ingress 控制器合并成一个 Nginx 配置。也就是说所有的人都在使用同一个 LoadBalancer IP。</p><h2 id="配置-Ingress-Nginx"><a href="#配置-Ingress-Nginx" class="headerlink" title="配置 Ingress Nginx"></a>配置 Ingress Nginx</h2><p>有时候我们需要对 Ingress Nginx 进行一些微调配置，我们可以通过 Ingress 资源对象中的 annotations 注解来实现，比如我们可以配置各种平时直接在 Nginx 中的配置选项。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">kubernetes.io/ingress.class</span><span class="token punctuation">:</span> nginx      <span class="token key atrule">nginx.ingress.kubernetes.io/proxy-connect-timeout</span><span class="token punctuation">:</span> <span class="token string">'30'</span>      <span class="token key atrule">nginx.ingress.kubernetes.io/proxy-send-timeout</span><span class="token punctuation">:</span> <span class="token string">'500'</span>      <span class="token key atrule">nginx.ingress.kubernetes.io/proxy-read-timeout</span><span class="token punctuation">:</span> <span class="token string">'500'</span>      <span class="token key atrule">nginx.ingress.kubernetes.io/send-timeout</span><span class="token punctuation">:</span> <span class="token string">"500"</span>      <span class="token key atrule">nginx.ingress.kubernetes.io/enable-cors</span><span class="token punctuation">:</span> <span class="token string">"true"</span>      <span class="token key atrule">nginx.ingress.kubernetes.io/cors-allow-methods</span><span class="token punctuation">:</span> <span class="token string">"*"</span>      <span class="token key atrule">nginx.ingress.kubernetes.io/cors-allow-origin</span><span class="token punctuation">:</span> <span class="token string">"*"</span><span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外也可以做更细粒度的规则配置，如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">nginx.ingress.kubernetes.io/configuration-snippet</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">  if ($host = 'www.qikqiak.com' ) {    rewrite ^ https://qikqiak.com$request_uri permanent;  }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这些注释都将被转换成 Nginx 配置，你可以通过手动连接(<code>kubectl exec</code>)到 nginx pod 中检查这些配置。</p><p>关于 ingress-nginx 更多的配置使用可以参考官方文档相关说明：</p><ul><li><a href="https://github.com/kubernetes/ingress-nginx/tree/master/docs/user-guide/nginx-configuration">https://github.com/kubernetes/ingress-nginx/tree/master/docs/user-guide/nginx-configuration</a></li><li><a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md#lua-resty-waf">https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md#lua-resty-waf</a></li></ul><h3 id="查看-ingress-nginx-日志"><a href="#查看-ingress-nginx-日志" class="headerlink" title="查看 ingress-nginx 日志"></a>查看 ingress-nginx 日志</h3><p>要排查问题，通过查看 Ingress 控制器的日志非常有帮助</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-ingress-9.png"></p><h3 id="使用-Curl-测试"><a href="#使用-Curl-测试" class="headerlink" title="使用 Curl 测试"></a>使用 Curl 测试</h3><p>如果我们想测试 Ingress 重定向规则，最好使用 <code>curl -v [yourhost.com](http://yourhost.com)</code> 来代替浏览器，可以避免缓存等带来的问题。</p><h3 id="重定向规则"><a href="#重定向规则" class="headerlink" title="重定向规则"></a>重定向规则</h3><p>在本文的示例中我们使用 <code>/folder</code> 和 <code>/other/directory</code> 等路径来重定向到不同的服务，此外我们也可以通过主机名来区分请求，比如将 <a href="http://api.myurl.com/">api.myurl.com</a> 和 <a href="http://site.myurl.com/">site.myurl.com</a> 重定向到不同的内部 ClusterIP 服务去。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> simple<span class="token punctuation">-</span>fanout<span class="token punctuation">-</span>example<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> api.myurl.com    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /foo        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> service1          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">4200</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /bar        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> service2          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">8080</span>  <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> website.myurl.com    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /        <span class="token key atrule">backend</span><span class="token punctuation">:</span>          <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> service3          <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">3333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SSL-HTTPS"><a href="#SSL-HTTPS" class="headerlink" title="SSL/HTTPS"></a>SSL/HTTPS</h3><p>可能我们想让网站使用安全的 HTTPS 服务，Kubernetes Ingress 也提供了简单的 TLS 校验，这意味着它会处理所有的 SSL 通信、解密/校验 SSL 请求，然后将这些解密后的请求发送到内部服务去。</p><p>如果你的多个内部服务使用相同（可能是通配符）的 SSL 证书，这样我们就只需要在 Ingress 上配置一次，而不需要在内部服务上去配置，Ingress 可以使用配置的 TLS Kubernetes Secret 来配置 SSL 证书。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> tls<span class="token punctuation">-</span>example<span class="token punctuation">-</span>ingress<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">tls</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> sslexample.foo.com    <span class="token key atrule">secretName</span><span class="token punctuation">:</span> testsecret<span class="token punctuation">-</span>tls  <span class="token key atrule">rules</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> sslexample.foo.com      <span class="token key atrule">http</span><span class="token punctuation">:</span>        <span class="token key atrule">paths</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /          <span class="token key atrule">backend</span><span class="token punctuation">:</span>            <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> service1            <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过需要注意的是如果你在不同的命名空间有多个 Ingress 资源，那么你的 TLS secret 也需要在你使用的 Ingress 资源的所有命名空间中可用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里我们简单介绍了 Kubernetes Ingress 的原理，简单来说：它不过是一种轻松配置 Nginx 服务器的方法，它可以将请求重定向到其他内部服务去。这为我们节省了宝贵的静态 IP 和 LoadBalancers 资源。</p><p>另外需要注意的是还有其他的 Kubernetes Ingress 类型，它们内部没有设置 Nginx 服务，但可能使用其他代理技术，一样也可以实现上面的所有功能。</p><blockquote><p>原文链接： <a href="https://codeburst.io/kubernetes-ingress-simply-visually-explained-d9cad44e4419">https://codeburst.io/kubernetes-ingress-simply-visually-explained-d9cad44e4419</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Service实践练习</title>
      <link href="/2022/08/21/kubernetes-service-shi-jian-lian-xi/"/>
      <url>/2022/08/21/kubernetes-service-shi-jian-lian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Service实践练习"><a href="#Kubernetes-Service实践练习" class="headerlink" title="Kubernetes  Service实践练习"></a>Kubernetes  Service实践练习</h1><p>本文主要介绍了 Service 的几种访问方式，包括ClusterIP、NodePort、LoadBalancer、ExternalName。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先，我们思考这样一个问题：</p><p>在k8s中，Pod是有生命周期的，如果Pod重启它的IP很有可能会发生变化。如果我们的服务都是将Pod的IP地址写死，Pod挂掉或者重启，和刚才重启的Pod相关联的其他服务将会找不到它所关联的Pod，所以客户端需要知道pod地址，若某一node上的pod故障，客户端需要感知，Service 的出现就是解决上述问题的</p><h2 id="什么是-Service"><a href="#什么是-Service" class="headerlink" title="什么是 Service"></a>什么是 Service</h2><p>所谓 Service，其实就是 Kubernetes 为 Pod 分配的、固定的、基于 iptables（或者 IPVS）的<strong>访问入口</strong>。而这些访问入口代理的 Pod 信息，则来自于 Etcd，由 kube-proxy 通过控制循环来维护。</p><p>Service是发现后端pod服务；</p><p>Service是为一组具有相同功能的容器应用提供一个统一的入口地址；</p><p>Service是将请求进行负载分发到后端的各个容器应用上的控制器。</p><h2 id="Service的访问方式"><a href="#Service的访问方式" class="headerlink" title="Service的访问方式"></a>Service的访问方式</h2><p>访问service的请求来源有两种：k8s集群内部的程序（Pod）和 k8s集群外部的程序。</p><p>采用微服务架构时，除了实现业务逻辑以外，还需要考虑如何把服务发布到k8s集群或者集群外部，使这些服务能够被k8s集群内的应用、其他k8s集群的应用以及外部应用使用。因此k8s提供了灵活的服务发布方式，用户可以通过ServiceType来指定如何来发布服务，类型有以下几种：</p><ul><li>ClusterIP：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。</li><li>NodePort：通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，你可以从集群的外部访问一个 <code>NodePort</code> 服务。</li><li>LoadBalancer：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上。</li><li>ExternalName：通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理。</li></ul><p>其中 ClusterIP 为默认方式，只能集群内部访问。NodePort、LoadBalancer 则是向外暴露服务的同时将流量路由到 ClusterIP服务。ExternalName 则是CNAME方式进行服务映射</p><h2 id="详解Service四种访问方式"><a href="#详解Service四种访问方式" class="headerlink" title="详解Service四种访问方式"></a>详解Service四种访问方式</h2><p>在测试这四种Service访问类型之前，我们先做些准备工作：</p><ol><li><p>准备  my-nginx-deployment.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建实例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f deployment/my-nginx-deployment.yaml <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看我们部署 3 个 Nginx Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pods NAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          21hmy-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          21hmy-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          21h[root@k8s-master ~]# kubectl get deploymentNAME                  READY   UP-TO-DATE   AVAILABLE   AGEmy-nginx-deployment   3/3     3            3           22h[root@k8s-master ~]# kubectl get pod -owideNAME                                   READY   STATUS    RESTARTS   AGE   IP                NODE        NOMINATED NODE   READINESS GATESmy-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          21h   192.168.36.84     k8s-node1   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          21h   192.168.36.82     k8s-node1   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          21h   192.168.169.144   k8s-node2   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>分别进入这3个Pod的Nginx容器中，并分别修改Nginx默认首页</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl exec -it my-nginx-deployment-69dfcd645b-2mjjt -c nginx -- /bin/bashx.htmly-nginx-deployment-69dfcd645b-2mjjt:/# echo 111 &gt; /usr/share/nginx/html/index.html[root@k8s-master ~]# kubectl exec -it my-nginx-deployment-69dfcd645b-n4pbs -c nginx -- /bin/bashroot@my-nginx-deployment-69dfcd645b-n4pbs:/# echo 222 &gt; /usr/share/nginx/html/index.html[root@k8s-master ~]# kubectl exec -it my-nginx-deployment-69dfcd645b-x2tgn  -c nginx -- /bin/bashroot@my-nginx-deployment-69dfcd645b-x2tgn:/# echo 333 &gt; /usr/share/nginx/html/index.html   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p> 在 Master 节点上验证都能正常访问</p></li></ol>   <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 验证能正常访问到[root@k8s-master ~]# kubectl get pod -owideNAME                                   READY   STATUS    RESTARTS   AGE   IP                NODE        NOMINATED NODE   READINESS GATESmy-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          21h   192.168.36.84     k8s-node1   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          21h   192.168.36.82     k8s-node1   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          21h   192.168.169.144   k8s-node2   &lt;none&gt;           &lt;none&gt;[root@k8s-master ~]# curl 192.168.36.84111[root@k8s-master ~]# curl 192.168.36.82222[root@k8s-master ~]# curl 192.168.169.144333<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li><p>打印下 Pod 的标签</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pod --show-labelsNAME                                   READY   STATUS    RESTARTS   AGE   LABELSmy-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          21h   app=my-nginx-deployment,pod-template-hash=69dfcd645bmy-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          21h   app=my-nginx-deployment,pod-template-hash=69dfcd645bmy-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          21h   app=my-nginx-deployment,pod-template-hash=69dfcd645b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="ClusterIP（集群内部使用）"><a href="#ClusterIP（集群内部使用）" class="headerlink" title="ClusterIP（集群内部使用）"></a>ClusterIP（集群内部使用）</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-clusterip.png"></p><p><code>ClusterIP</code>也是 Service 的默认访问方式。是集群内部访问的方式，外部是无法访问的。其主要用于为集群内 Pod 访 问时,提供的固定访问地址,默认是自动分配地址,可使用 ClusterIP 关键字指定固定 IP</p><p>下面我们测试下ClusterIP Service的访问方式</p><ul><li><p>准备配置文件 my-nginx-service-clusterip.yaml 文件</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>service <span class="token comment">#给该service定义标签</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>service <span class="token comment">#service名称</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment <span class="token comment">#哪些Pod，key是app，value是my-nginx-deployment的Pod</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>上述配置创建一个名称为 “my-nginx-service” 的 Service 对象，它会将请求代理到使用 TCP 端口 80，并且具有标签 <code>"app=my-nginx-deployment"</code> 的 Pod 上</p><ul><li><p>创建svc</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f service/my-nginx-service-clusterip.yaml service/my-nginx-service created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看svc</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get svc,podNAME                       TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGEservice/kubernetes         ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    46hservice/my-nginx-service   ClusterIP   10.96.111.244   &lt;none&gt;        8080/TCP   6sNAME                                       READY   STATUS    RESTARTS   AGEpod/my-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          21hpod/my-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          21hpod/my-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          21h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>访问测试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 使用内部ip访问测试[root@k8s-master ~]# curl 10.96.111.244:8080333[root@k8s-master ~]# curl 10.96.111.244:8080222[root@k8s-master ~]# curl 10.96.111.244:8080222[root@k8s-master ~]# curl 10.96.111.244:8080111# 外部访问# zhangquan @ MacBook-Pro in ~ [17:48:14] $ curl 10.96.111.244:8080curl: (7) Failed to connect to 10.96.111.244 port 8080: Network is unreachable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>可以看到访问是一个负载均衡的访问，而且在集群内任意一台机器上都可以访问</p><ul><li><p>在Pod内通过service域名（服务名.所在名称空间.svc）访问</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 首先部署一个 tomcat[root@k8s-master ~]# kubectl create deploy my-tomcat --image=tomcatdeployment.apps/my-tomcat created[root@k8s-master ~]# kubectl get pods NAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          22hmy-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          22hmy-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          22hmy-tomcat-b4c9b6565-wgb4f              1/1     Running   0          5m39s# 进入到 tomcat 内通过域名访问 nginx，访问的 ClusterIP[root@k8s-master ~]# kubectl exec -it my-tomcat-b4c9b6565-wgb4f -c tomcat -- /bin/bash         root@my-tomcat-b4c9b6565-wgb4f:/usr/local/tomcat# curl 10.96.111.244:8080333root@my-tomcat-b4c9b6565-wgb4f:/usr/local/tomcat# curl 10.96.111.244:8080333root@my-tomcat-b4c9b6565-wgb4f:/usr/local/tomcat# curl 10.96.111.244:8080111# 实验完删除 my-tomcat 的 deploy[root@k8s-master ~]# kubectl delete deploy my-tomcatdeployment.apps "my-tomcat" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="NodePort（对外暴露应用，集群外也能访问）"><a href="#NodePort（对外暴露应用，集群外也能访问）" class="headerlink" title="NodePort（对外暴露应用，集群外也能访问）"></a>NodePort（对外暴露应用，集群外也能访问）</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-nodeport.png"></p><p>NodePort 也叫节点端口访问方式。</p><p> k8s将会在每个Node上打开一个端口并且每个Node的端口都是一样的，通过<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>的方式Kubernetes集群外部的程序可以访问Service。</p><p>下面我们测试下NodePort Service的访问方式</p><ul><li><p>开始之前先删除 </p></li><li><p>准备配置文件 my-nginx-service-nodeport.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>service  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>service  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">name</span><span class="token punctuation">:</span> http    <span class="token comment">#nodePort: 31703</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment <span class="token comment">#哪些Pod，key是app，value是my-nginx-deployment的Pod</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个 Service 的定义里，我们声明它的类型是，type=NodePort。然后，在 ports 字段里声明了 Service 的 8080 端口代理 Pod 的 80 端口。</p><blockquote><p>如果不显式地声明 nodePort 字段，Kubernetes 就会为你分配随机的可用端口来设置代理。这个端口的范围默认是 30000-32767，你可以通过 kube-apiserver 的–service-node-port-range 参数来修改它。</p></blockquote></li><li><p>创建 svc</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f service/my-nginx-service-nodeport.yamlservice/my-nginx-service configured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看svc</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get svc,podNAME                       TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGEservice/kubernetes         ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          46hservice/my-nginx-service   NodePort    10.96.111.244   &lt;none&gt;        8080:31039/TCP   13mNAME                                       READY   STATUS    RESTARTS   AGEpod/my-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          22hpod/my-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          22hpod/my-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          22h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，虽然是 NodePort 类型，但还是默认创建了 ClusterIP。</p></li><li><p>访问测试</p><ul><li><p>可以通过 <code>&lt;ClusterIP&gt;:&lt;service.Port&gt;</code> 来访问</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# curl 10.96.111.244:8080333[root@k8s-master ~]# curl 10.96.111.244:8080333[root@k8s-master ~]# curl 10.96.111.244:8080111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>方式来访问，访问任意一台机器都可以，如果使用云服务器，要在安全组里放行 30000-32767端口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~ [17:48:35] C:7$ curl 139.198.183.73:31039222# zhangquan @ MacBook-Pro in ~ [18:06:33] $ curl 139.198.172.5:31039333# zhangquan @ MacBook-Pro in ~ [18:06:51] $ curl 139.198.170.70:31039111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="LoadBalancer（对外暴露应用，适用于公有云）"><a href="#LoadBalancer（对外暴露应用，适用于公有云）" class="headerlink" title="LoadBalancer（对外暴露应用，适用于公有云）"></a>LoadBalancer（对外暴露应用，适用于公有云）</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-load-balance.png"></p><p>LoadBalancer 类型的 service 是可以实现集群外部访问服务的另外一种解决方案。不过并不是所有的 k8s 集 群都会支持，大多是在公有云托管集群中会支持该类型。负载均衡器是异步创建的，关于被提供的负载均衡器的 信息将会通过 Service 的 status.loadBalancer 字段被发布出去</p><blockquote><p>在NodePort的基础上，借助Cloud Provider创建一个外部负载均衡器，并将请求转发到NodePort</p></blockquote><p>在公有云提供的 Kubernetes 服务里，都使用了一个叫作 CloudProvider 的转接层，来跟公有云本身的 API 进行对接。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> loadbalancer<span class="token punctuation">-</span>nginx  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，<strong>在上述 LoadBalancer 类型的 Service 被提交后，Kubernetes 就会调用 CloudProvider 在公有云上为你创建一个负载均衡服务，并且把被代理的 Pod 的 IP 地址配置给负载均衡服务做后端</strong>。</p><h3 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h3><p>ExternalName Service 是 Service 的一个特例，它没有选择器，也没有定义任何端口或 Endpoints。它的作用是 返回集群外 Service 的外部别名。它将外部地址经过集群内部的再一次封装(实际上就是集群 DNS 服务器将 CNAME 解析到了外部地址上)，实现了集群内部访问即可。例如你们公司的镜像仓库，最开始是用 ip 访问，等到后面域 名下来了再使用域名访问。你不可能去修改每处的引用。但是可以创建一个 ExternalName，首先指向到 ip，等后 面再指向到域名</p><p>下面我们测试下ExternalName Service的访问方式</p><ul><li><p>准备配置文件my-nginx-service-externalname.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>service<span class="token punctuation">-</span>externalname<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ExternalName  <span class="token key atrule">externalName</span><span class="token punctuation">:</span> www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述 Service 的 YAML 文件中，我指定了一个 externalName= <a href="http://www.baidu.com/">www.baidu.com</a> 的字段。而且你应该会注意到，这个 YAML 文件里不需要指定 selector。</p><p>这时候，当你通过 Service 的 DNS 名字访问它的时候，比如访问：my-service-externalname.default.svc.cluster.local。那么，Kubernetes 为你返回的就是<a href="http://www.baidu.com/">www.baidu.com</a></p><p>所以说，<strong>ExternalName 类型的 Service，其实是在 kube-dns 里为你添加了一条 CNAME 记录</strong>。</p><p>这时，访问 my-service-externalname.default.svc.cluster.local 就和访问 <a href="http://www.baidu.com/">www.baidu.com</a> 这个域名是一个效果了。</p></li><li><p>创建svc</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f service/my-nginx-service-externalname.yamlservice/my-service-externalname created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看svc</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get svc,podNAME                              TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)          AGEservice/kubernetes                ClusterIP      10.96.0.1       &lt;none&gt;          443/TCP          46hservice/my-nginx-service          NodePort       10.96.111.244   &lt;none&gt;          8080:31039/TCP   21mservice/my-service-externalname   ExternalName   &lt;none&gt;          www.baidu.com   &lt;none&gt;           8sNAME                                       READY   STATUS    RESTARTS   AGEpod/my-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          22hpod/my-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          22hpod/my-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          22h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>访问测试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get podsNAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-69dfcd645b-2mjjt   1/1     Running   1          22hmy-nginx-deployment-69dfcd645b-n4pbs   1/1     Running   1          22hmy-nginx-deployment-69dfcd645b-x2tgn   1/1     Running   1          22h# 进入 Pod 里[root@k8s-master ~]# kubectl exec -it my-nginx-deployment-69dfcd645b-2mjjt -- /bin/bash# 安装 nslookup 相关工具包root@my-nginx-deployment-69dfcd645b-2mjjt:/# apt-get update root@my-nginx-deployment-69dfcd645b-2mjjt:/# apt-get install dnsutils# 解析  www.baidu.com 域名root@my-nginx-deployment-69dfcd645b-2mjjt:/# nslookup www.baidu.comServer:         10.96.0.10Address:        10.96.0.10#53Non-authoritative answer:www.baidu.com   canonical name = www.a.shifen.com.Name:   www.a.shifen.comAddress: 180.101.49.12Name:   www.a.shifen.comAddress: 180.101.49.11# 解析 my-service-externalname.default.svc.cluster.local 域名root@my-nginx-deployment-69dfcd645b-2mjjt:/# nslookup my-service-externalname.default.svc.cluster.localServer:         10.96.0.10Address:        10.96.0.10#53my-service-externalname.default.svc.cluster.local       canonical name = www.baidu.com.www.baidu.com   canonical name = www.a.shifen.com.Name:   www.a.shifen.comAddress: 180.101.49.12Name:   www.a.shifen.comAddress: 180.101.49.11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到解析此my-service-externalname.default.svc.cluster.local域名和解析 <a href="http://www.baidu.com是一样的结果/">www.baidu.com是一样的结果</a></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>所谓 Service，其实就是 Kubernetes 为 Pod 分配的、固定的、基于 iptables（或者 IPVS）的访问入口</strong>。而这些访问入口代理的 Pod 信息，则来自于 Etcd，由 kube-proxy 通过控制循环来维护。</p><ul><li>ClusterIP：集群内部IP，也是默认方法方式。</li><li>NodePort：通过节点IP+静态端口访问，NodePort 服务会将流量路由到 ClusterIP 服务。</li><li>LoadBalancer：使用云厂商提供的负载均衡向外暴露服务，可以将流量路由到 NodePort 服务或者ClusterIP 服务。</li><li>ExternalName：通过返回 CNAME 值的方式将服务映射到指定的域名。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">https://kubernetes.io/docs/concepts/services-networking/service/</a></li><li><a href="https://draveness.me/kubernetes-service/">https://draveness.me/kubernetes-service/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解Kubernetes Service</title>
      <link href="/2022/08/21/tu-jie-kubernetes-service/"/>
      <url>/2022/08/21/tu-jie-kubernetes-service/</url>
      
        <content type="html"><![CDATA[<h1 id="图解Kubernetes-Service"><a href="#图解Kubernetes-Service" class="headerlink" title="图解Kubernetes Service"></a>图解Kubernetes Service</h1><p>在 Kubernetes 中 Service 主要有4种不同的类型，其中的 ClusterIP 是最基础的。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-0.png"></p><p>上图解释了 Kubernetes 的 Service 的基本关系，当我们创建一个 NodePort 的 Service 时，它也会创建一个 ClusterIP，而如果你创建一个 LoadBalancer，它就会创建一个 NodePort，然后创建一个 ClusterIP</p><p>此外我们还需要明白 <strong>Service 是指向 pods 的，Service 不是直接指向 Deployments 或 ReplicaSets，而是直接使用 labels 标签指向 Pod</strong>，这种方式就提供了极大的灵活性，因为通过什么方式创建的 Pod 其实并不重要。接下来我们通过一个简单的例子开始，我们用不同的 Service 类型来逐步扩展，看看这些 Service 是如何建立的。</p><h2 id="No-Services"><a href="#No-Services" class="headerlink" title="No Services"></a>No Services</h2><p>最开始我们没有任何的 Services。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-1.png"></p><p>我们有两个节点，一个 Pod，节点有外网（4.4.4.1、4.4.4.2）和内网（1.1.1.1、1.1.1.2）的 IP 地址，pod-python 这个 Pod 只有一个内部的 IP 地址。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-2.png"></p><p>现在我们添加第二个名为 pod-nginx 的 Pod，它被调度在 node-1 节点上。在 Kubernetes 中，所有的 Pod 之间都可以通过 Pod 的 IP 进行通信，不管它们运行在哪个节点上。这意味着 pod-nginx 可以使用其内部IP 1.1.1.3 来 ping 和连接 pod-python 这个 Pod。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-3.png"></p><p>现在如果 pod-python 挂掉了重新创建了一个新的 pod-python 出来（本文不涉及如何管理和控制 pods），重新分配了一个新的 1.1.1.5 的 Pod IP 地址，这个时候 pod-nginx 就无法再达到 1.1.1.3 这个之前的地址了，为了防止这种情况发生，我们就需要创建一个 Service 服务了！</p><h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-4.png"></p><p>和上面同样的场景，但是我们创建了一个名为 service-python 类型为 ClusterIP 的 Service 服务，一个 Service 并不像 Pod 那样运行在一个特定的节点上，这里我们可以假设一个 Service 只是在整个集群内部的内存中可用就可以了。</p><p>pod-nginx 可以安全地连接到 1.1.10.1 这个 ClusterIP 或直接通过 dns 名service-python 进行通信，并被重定向到后面一个可用的 Pod 上去。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-5.png"></p><p>现在我们来稍微扩展下这个示例，启动3个 python 实例，现在我们来显示所有 Pod 和 Service 内部 IP 地址的端口。</p><p>集群内部的所有 Pods 都可以通过 <code>http://1.1.10.1:3000</code> 或者 <code>http://service-python:3000</code> 来访问到后面的 python pods 的443端口。</p><p><strong>service-python</strong> 这个 Service 是随机或沦陷的方式来转发请求的，这个就是 ClusterIP Service 的作用，它通过一个名称和一个 IP 让集群内部的 Pods 可用。</p><p>上图中的 service-python 这个 Service 可以用下面的 yaml 文件来创建：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>python<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">443</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>python  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建后，可以用 <code>kubectl get svc</code> 命令来查看：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-6.png"></p><h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p>现在我们想让 ClusterIP Service 可以从集群外部进行访问，为此我们需要把它转换成 NodePort 类型的 Service，在我们的例子中，我们只需要简单修改上面的 <strong>service-python</strong> 这个 Service 服务即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>python<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">443</span>    <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30080</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>python  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新完成后，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-7.png"></p><p>​                                                                                                                <em>外部通过 node-2 节点进行请求</em></p><p>这意味着我们的内部的 <strong>service-python</strong> 这个 Service 现在也可以通过30080 端口从<strong>每个节点</strong>的内部和外部 IP 地址进行访问了。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-8.png"></p><p>​                                                                                                        <em>外部通过 node-1 节点进行请求</em></p><p>集群内部的 Pod 也可以通过内网节点 IP 连接到 30080 端口。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-9.png"></p><p>​                                                                                                    Pod 通过 node-1 节点内网 IP 进行请求</p><p>运行 <code>kubectl get svc</code> 命令来查看这个 NodePort 的 Service，可以看到同样有一个 ClusterIP，只是类型和额外的节点端口不同。在内部，NodePort 服务仍然像之前的 ClusterIP 服务一样。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-10.png"></p><h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p>如果我们希望有一个单独的 IP 地址，将请求分配给所有的外部节点IP（比如使用 round robin），我们就可以使用 LoadBalancer 服务，所以它是建立在 NodePort 服务之上的。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-11.png"></p><p>一个 LoadBalancer 服务创建了一个 NodePort 服务，NodePort 服务创建了一个 ClusterIP 服务。我们也只需要将服务类型更改为 LoadBalancer 即可。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>python<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">443</span>    <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30080</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>python  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LoadBalancer 服务所做的就是创建一个 NodePort 服务，此外，它还会向托管 Kubernetes 集群的提供商发送一条消息，要求设置一个指向所有外部节点 IP 和特定 nodePort 端口的负载均衡器，当然前提条件是要提供商支持。</p><p>现在运行 <code>kubectl get svc</code> 可以看到新增了 external-IP 和 LoadBalancer 的类型。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-12.png"></p><h2 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h2><p>最后是 ExternalName 服务，这个服务和前面的几种类型的服务有点分离。它创建一个内部服务，其端点指向一个 DNS 名。</p><p>我们假设 pod-nginx 运行在 Kubernetes 集群中，但是 python api 服务在集群外部。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-13.png"></p><p>这里 <strong>pod-nginx</strong> 这个 Pod 可以直接通过 <a href="http://remote.server.url.com/">http://remote.server.url.com</a> 连接到外部的 python api 服务上去，但是如果我们考虑到以后某个时间节点希望把这个 python api 服务集成到 Kubernetes 集群中去，还不希望去更改连接的地址，这个时候我们就可以创建一个 ExternalName 类型的 Service 服务了。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-14.png"></p><p>对应的 YAML 资源清单文件如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>python<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">443</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ExternalName  <span class="token key atrule">externalName</span><span class="token punctuation">:</span> remote.server.url.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在 <strong>pod-nginx</strong> 就可以很方便地通过 <code>http://service-python:3000</code> 进行通信了，就像使用 ClusterIP 服务一样，当我们决定将 python api 这个服务也迁移到我们 Kubernetes 集群中时，我们只需要将服务改为 ClusterIP 服务，并设置正确的标签即可，其他都不需要更改了。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-service-15.png"></p><p>​                                                                                                            <em>Python api 仍然可以通过 <a href="http://service-python/">http://service-python</a> 访问</em></p><p>到这里我们就用几张图将 Kubernetes 中的 Service 解释得明明白白清清楚楚真真切切了~~~</p><blockquote><p>原文链接：<a href="https://medium.com/swlh/kubernetes-services-simply-visually-explained-2d84e58d70e5">https://medium.com/swlh/kubernetes-services-simply-visually-explained-2d84e58d70e5</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Deployment 控制器</title>
      <link href="/2022/08/20/kubernetes-deployment-kong-zhi-qi/"/>
      <url>/2022/08/20/kubernetes-deployment-kong-zhi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Deployment控制器"><a href="#Kubernetes-Deployment控制器" class="headerlink" title="Kubernetes Deployment控制器"></a>Kubernetes Deployment控制器</h1><p>Deployment 是 Kubernetes 中最常见的控制器，实际上它是一个<strong>两层控制器</strong>。</p><ul><li>首先，它通过 <strong>ReplicaSet 的个数</strong>来描述应用的版本；</li><li>然后，它再通过 <strong>ReplicaSet 的属性</strong>（比如 replicas 的值），来保证 Pod 的副本数量。</li></ul><blockquote><p>注：Deployment 控制 ReplicaSet（版本），ReplicaSet 控制 Pod（副本数）。这个两层控制关系一定要牢记。</p></blockquote><p>Deployment 是 Kubernetes 编排能力的一种提现，通过 Deployment 我们可以让 Pod 稳定的维持在指定的数量，除此之外还有滚动更新、版本回滚等功能。</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h3 id="自愈能力"><a href="#自愈能力" class="headerlink" title="自愈能力"></a>自愈能力</h3><p>我们通过一个例子来演示来Deployment的自愈能力。</p><p>通过 kubectl run 来创建一个 mynginx Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl run mynginx --image=nginxpod/mynginx created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过 kubectl create deployment 来创建一个 mytomcat Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create deployment mytomcat --image=tomcat:8.5.68deployment.apps/mytomcat created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们比较下这两种方式分别创建的 Pod 有什么不同？</p><p>首先把 kubectl run 修建的 mynginx  Pod 删除了</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get podNAME                        READY   STATUS    RESTARTS   AGEmynginx                     1/1     Running   0          94smytomcat-6f5f895f4f-b5ckr   1/1     Running   0          83s[root@k8s-master ~]# kubectl delete pod mynginxpod "mynginx" deleted[root@k8s-master ~]# kubectl get pod           NAME                        READY   STATUS    RESTARTS   AGEmytomcat-6f5f895f4f-b5ckr   1/1     Running   0          100s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着再删除 mytomcat Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete pod mytomcat-6f5f895f4f-b5ckr pod "mytomcat-6f5f895f4f-b5ckr" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次查看 Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get podNAME                        READY   STATUS    RESTARTS   AGEmytomcat-6f5f895f4f-j7w22   1/1     Running   0          17s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>总结：通过 Deployment 创建的 Pod，不怕机器宕机或应用崩溃，Deployment创建的Pod它有<strong>自愈能力</strong></p><p>如果想要删除呢？那就是删除本次部署</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看 deployment[root@k8s-master ~]# kubectl get deployNAME       READY   UP-TO-DATE   AVAILABLE   AGEmytomcat   1/1     1     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 删除 deployment[root@k8s-master ~]# kubectl delete deploy mytomcatdeployment.apps "mytomcat" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deploy   No resources found in default namespace.[root@k8s-master ~]# kubectl get podNo resources found in default namespace.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多副本"><a href="#多副本" class="headerlink" title="多副本"></a>多副本</h3><ul><li><p>命令行方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create deployment my-nginx-deployment --image=nginx --replicas=3deployment.apps/my-nginx-deployment created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 <code>--replicas</code> 表示本次部署起多少个 Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deployNAME                  READY   UP-TO-DATE   AVAILABLE   AGEmy-nginx-deployment   3/3     3            3           17s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pod -owideNAME                                   READY   STATUS    RESTARTS   AGE     IP                NODE        NOMINATED NODE   READINESS GATESmy-nginx-deployment-799847ccc9-dx59g   1/1     Running   0          2m50s   192.168.36.70     k8s-node1   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-799847ccc9-mfhpz   1/1     Running   0          2m50s   192.168.169.133   k8s-node2   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-799847ccc9-xwlx4   1/1     Running   0          2m50s   192.168.36.71     k8s-node1   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为在我们有台node2机器，可以看到 my-nginx-deployment Pod 分散到两台机器上部署</p></li><li><p>配置文件方式</p><ol start="0"><li><p>先删除命令行方式创建的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete deploy my-nginx-deploymentdeployment.apps "my-nginx-deployment" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>准备  my-nginx-deployment.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建实例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f deployment/my-nginx-deployment.yaml deployment.apps/my-nginx-deployment created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deploymentNAME                  READY   UP-TO-DATE   AVAILABLE   AGEmy-nginx-deployment   3/3     3            3           34s[root@k8s-master ~]# kubectl get podNAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          37smy-nginx-deployment-799847ccc9-n2xtn   1/1     Running   0          37smy-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          37s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul><h3 id="扩缩容能力"><a href="#扩缩容能力" class="headerlink" title="扩缩容能力"></a>扩缩容能力</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-scale.png"></p><p>首先我们部署 3 个实例的 Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deploymentNAME                  READY   UP-TO-DATE   AVAILABLE   AGEmy-nginx-deployment   3/3     3            3           20m[root@k8s-master ~]# kubectl get podNAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          20mmy-nginx-deployment-799847ccc9-n2xtn   1/1     Running   0          20mmy-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          20m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>命令行方式扩缩容</p><p>进行扩容， –replicas=5 表示扩容到5个Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl scale --replicas=5 deployment/my-nginx-deploymentdeployment.apps/my-nginx-deployment scaled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看扩容后的Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get podNAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-799847ccc9-blrss   1/1     Running   0          56smy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          23mmy-nginx-deployment-799847ccc9-n2xtn   1/1     Running   0          23mmy-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          23mmy-nginx-deployment-799847ccc9-v96gh   1/1     Running   0          56s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行缩容</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl scale --replicas=3 deployment/my-nginx-deploymentdeployment.apps/my-nginx-deployment scaled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看缩容后的Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get podNAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          24mmy-nginx-deployment-799847ccc9-n2xtn   1/1     Running   0          24mmy-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          24m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置文件方式扩缩容</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deployNAME                  READY   UP-TO-DATE   AVAILABLE   AGEmy-nginx-deployment   3/3     3            3           27m# 修改 replicas: 4[root@k8s-master ~]# kubectl edit deployment my-nginx-deployment# 查看效果[root@k8s-master ~]# kubectl get podNAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          28mmy-nginx-deployment-799847ccc9-n2xtn   1/1     Running   0          28mmy-nginx-deployment-799847ccc9-nzm8x   1/1     Running   0          23smy-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          28m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="故障转移能力"><a href="#故障转移能力" class="headerlink" title="故障转移能力"></a>故障转移能力</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-deployment.png"></p><p>下面我们来演示下自愈&amp;故障转移能力</p><p>查看 pod </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pod -owideNAME                                   READY   STATUS    RESTARTS   AGE   IP                NODE        NOMINATED NODE   READINESS GATESmy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          40m   192.168.169.134   k8s-node2   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-799847ccc9-n2xtn   1/1     Running   0          40m   192.168.36.73     k8s-node1   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-799847ccc9-nzm8x   1/1     Running   0          11m   192.168.169.137   k8s-node2   &lt;none&gt;           &lt;none&gt;my-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          40m   192.168.36.72     k8s-node1   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>监控pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# watch -n 1 kubectl get podEvery 1.0s: kubectl get pod                                                                                                                                               Sun Aug 14 19:13:41 2022NAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          41mmy-nginx-deployment-799847ccc9-n2xtn   1/1     Running   0          41mmy-nginx-deployment-799847ccc9-nzm8x   1/1     Running   0          13mmy-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          41m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 k8s-node1 节点上停止容器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-node1 ~]# docker ps | grep my-nginx4da287650d27   nginx                                                        "/docker-entrypoint.…"   42 minutes ago   Up 42 minutes             k8s_nginx_my-nginx-deployment-799847ccc9-n2xtn_default_8feb6cd8-1c8e-41ba-8f85-d365fd1cb88c_016e18c7b9c0d   nginx                                                        "/docker-entrypoint.…"   43 minutes ago   Up 43 minutes             k8s_nginx_my-nginx-deployment-799847ccc9-tdtgx_default_79e17be3-4d3c-4534-a1e0-efb03af8c282_01f201df2a201   registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/pause:3.2   "/pause"                 43 minutes ago   Up 43 minutes             k8s_POD_my-nginx-deployment-799847ccc9-n2xtn_default_8feb6cd8-1c8e-41ba-8f85-d365fd1cb88c_016b0091c2ea6   registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/pause:3.2   "/pause"                 43 minutes ago   Up 43 minutes             k8s_POD_my-nginx-deployment-799847ccc9-tdtgx_default_79e17be3-4d3c-4534-a1e0-efb03af8c282_0[root@k8s-node1 ~]# docker stop 4da287650d274da287650d27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察 pod 的变化</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# watch -n 1 kubectl get podEvery 1.0s: kubectl get pod                                                                                                                                               Sun Aug 14 19:16:38 2022NAME                                   READY   STATUS    RESTARTS   AGE  my-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          44m  my-nginx-deployment-799847ccc9-n2xtn   1/1     Running   1          44m  my-nginx-deployment-799847ccc9-nzm8x   1/1     Running   0          15m  my-nginx-deployment-799847ccc9-tdtgx   1/1     Running   0          44m  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到  my-nginx-deployment-799847ccc9-n2xtn Pod 重启了一次</p><p>故障转移，我们可以对 k8s-node1 节点机器关机，关机后观察 pod 变化</p><h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/k8s-deployment-rollout.png"></p><p><strong>将一个集群中正在运行的多个 Pod 版本，交替地逐一升级的过程，就是“滚动更新”。</strong></p><p>先将新版本的V2从0个扩容到1个Pod，接着将旧版本的V1 从3个缩容到2个，这样慢慢的最后V1缩为0个，V2扩到3个。</p><blockquote><p>滚动更新好处就是，即使V2版本出现异常，此时也会有两个V1版本在运行，然后用户可以手动处理这种情况，比如停止更新或者回滚到V1版本</p></blockquote><p>下面我们测试滚动更新</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get deployNAME                  READY   UP-TO-DATE   AVAILABLE   AGEmy-nginx-deployment   3/3     3            3           56m[root@k8s-master ~]# kubectl get podNAME                                   READY   STATUS    RESTARTS   AGEmy-nginx-deployment-799847ccc9-fj85l   1/1     Running   0          56mmy-nginx-deployment-799847ccc9-n2xtn   1/1     Running   2          56mmy-nginx-deployment-799847ccc9-nzm8x   1/1     Running   0          28m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>命令行方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1 --recorddeployment.apps/my-nginx-deployment image updated# 观察变化[root@k8s-master ~]# watch -n 1 kubectl get podEvery 1.0s: kubectl get pod                                                                                                                                               Sun Aug 14 19:35:18 2022NAME                                   READY   STATUS              RESTARTS   AGEmy-nginx-deployment-69dfcd645b-vptn2   0/1     ContainerCreating   0          17smy-nginx-deployment-799847ccc9-fj85l   1/1     Running             0          63mmy-nginx-deployment-799847ccc9-n2xtn   1/1     Running             2          63mmy-nginx-deployment-799847ccc9-nzm8x   1/1     Running             0          34m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>set image 表示我们要改变镜像，改变哪个镜像？改变的是 deployment/my-nginx-deployment 这个deployment 中的 nginx 镜像，把它镜像变为 nginx:1.16.1版本，–record 表示记录下本次版本的更新</p></li><li><p>配置文件方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 修改 spec.template.spec.containers.image 值为 nginx:1.9.1kubectl edit deployment/my-nginx-deployment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>首先，我需要使用 <code>kubectl rollout history</code> 命令，查看每次 Deployment 变更对应的版本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看历史记录[root@k8s-master ~]#  kubectl rollout history deployment/my-nginx-deploymentdeployment.apps/my-nginx-deployment REVISION  CHANGE-CAUSE1         &lt;none&gt;2         kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1 --record=true3         kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1 --record=true4         kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1 --record=true#查看某个历史详情[root@k8s-master ~]# kubectl rollout history deployment/my-nginx-deployment --revision=2deployment.apps/my-nginx-deployment with revision #2Pod Template:  Labels:       app=my-nginx-deployment        pod-template-hash=69dfcd645b  Annotations:  kubernetes.io/change-cause: kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1 --record=true  Containers:   nginx:    Image:      nginx:1.16.1    Port:       &lt;none&gt;    Host Port:  &lt;none&gt;    Environment:        &lt;none&gt;    Mounts:     &lt;none&gt;  Volumes:      &lt;none&gt;[root@k8s-master ~]# kubectl rollout history deployment/my-nginx-deployment --revision=3deployment.apps/my-nginx-deployment with revision #3Pod Template:  Labels:       app=my-nginx-deployment        pod-template-hash=dc798486d  Annotations:  kubernetes.io/change-cause: kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1 --record=true  Containers:   nginx:    Image:      nginx:1.91    Port:       &lt;none&gt;    Host Port:  &lt;none&gt;    Environment:        &lt;none&gt;    Mounts:     &lt;none&gt;  Volumes:      &lt;none&gt;[root@k8s-master ~]# kubectl rollout history deployment/my-nginx-deployment --revision=4deployment.apps/my-nginx-deployment with revision #4Pod Template:  Labels:       app=my-nginx-deployment        pod-template-hash=64f546978b  Annotations:  kubernetes.io/change-cause: kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1 --record=true  Containers:   nginx:    Image:      nginx:1.9.1    Port:       &lt;none&gt;    Host Port:  &lt;none&gt;    Environment:        &lt;none&gt;    Mounts:     &lt;none&gt;  Volumes:      &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们就可以在 <code>kubectl rollout undo</code> 命令行最后，加上要回滚到的指定版本的版本号，就可以回滚到指定版本了。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#回滚(回到上次)kubectl rollout undo deployment/my-nginx-deployment#回滚(回到指定版本)[root@k8s-master ~]# kubectl rollout undo deployment/my-nginx-deployment --to-revision=2deployment.apps/my-nginx-deployment rolled back#验证回退到了 1.16.1 版本[root@k8s-master ~]# kubectl get deploy/my-nginx-deployment -oyaml | grep image      {"apiVersion":"apps/v1","kind":"Deployment","metadata":{"annotations":{},"labels":{"app":"my-nginx-deployment"},"name":"my-nginx-deployment","namespace":"default"},"spec":{"replicas":3,"selector":{"matchLabels":{"app":"my-nginx-deployment"}},"template":{"metadata":{"labels":{"app":"my-nginx-deployment"}},"spec":{"containers":[{"image":"nginx","name":"nginx"}]}}}}    kubernetes.io/change-cause: kubectl set image deployment/my-nginx-deployment nginx=nginx:1.16.1                f:imagePullPolicy: {}                f:image: {}      - image: nginx:1.16.1        imagePullPolicy: Always<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/">https://kubernetes.io/zh/docs/concepts/workloads/controllers/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 中资源对象的简单使用</title>
      <link href="/2022/08/18/kubernetes-zhong-zi-yuan-dui-xiang-de-jian-dan-shi-yong/"/>
      <url>/2022/08/18/kubernetes-zhong-zi-yuan-dui-xiang-de-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-中资源对象的简单使用"><a href="#Kubernetes-中资源对象的简单使用" class="headerlink" title="Kubernetes 中资源对象的简单使用"></a>Kubernetes 中资源对象的简单使用</h1><p>在本文中，记录了 Namespaces、Pod 资源对象的简单使用</p><h2 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h2><p>Kubernetes 中的所有内容都被抽象为“资源”，如 Pod、Service、Node 等都是资源。“对象”就是“资源”的实例，是持久化的实体。如某个具体的 Pod、某个具体的 Node。Kubernetes 使用这些实体去表示整个集群的状态。  </p><p>对象的创建、删除、修改都是通过 “Kubernetes API”，也就是 “Api Server” 组件提供的 API 接口，这些是 RESTful 风格的 Api，与 k8s 的“万物皆对象”理念相符。命令行工具 “kubectl”，实际上也是调用 kubernetes api。  </p><p>K8s 中的资源类别有很多种，kubectl 可以通过配置文件来创建这些 “对象”，配置文件更像是描述对象“属性”的文件，配置文件格式可以是 “JSON” 或 “YAML”，常用 “YAML”。</p><h2 id="资源创建方式"><a href="#资源创建方式" class="headerlink" title="资源创建方式"></a>资源创建方式</h2><p>在 K8s 中，创建资源有两种方式：</p><ul><li>直接使用命令行方式创建</li><li>使用 <code>kubectl create/apply</code>  命令从 YAML 文件创建</li></ul><h2 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h2><p>NameSpaces：名称空间，用来对集群中的资源进行隔离划分。默认只隔离资源，不隔离网络。同一名称空间内的资源名称要唯一，但跨名称空间时没有这个要求。 </p><h3 id="查看-namespaces"><a href="#查看-namespaces" class="headerlink" title="查看 namespaces"></a>查看 namespaces</h3><ul><li><p>列出集群中现有的名称空间</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get nsNAME                   STATUS   AGEdefault                Active   20hkube-node-lease        Active   20hkube-public            Active   20hkube-system            Active   20hkubernetes-dashboard   Active   46m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取某个名称空间的详细信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl describe namespaces default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="创建-namespace"><a href="#创建-namespace" class="headerlink" title="创建 namespace"></a>创建 namespace</h3><ul><li>命令行方式</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create namespace mynamespacenamespace/mynamespace created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>yaml 文件方式</p><ol><li><p>新建一个名为 <code>my-namespace.yaml</code> 的 YAML 文件，并写入下列内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mynamespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后运行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl create -f ./ns/my-namespace.yaml namespace/mynamespace created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol></li></ul><h3 id="删除-namespace"><a href="#删除-namespace" class="headerlink" title="删除 namespace"></a>删除 namespace</h3><ul><li><p>命令行方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete namespace mynamespacenamespace "mynamespace" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>yaml 文件方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete -f ./ns/my-namespace.yaml       namespace "mynamespace" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod：运行中的一组（一个或多个）容器；<strong>Pod</strong> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p><h3 id="创建-Pod"><a href="#创建-Pod" class="headerlink" title="创建 Pod"></a>创建 Pod</h3><ul><li><p>命令行方式</p><p>mynginx 表示给我们创建的Pod起一个名字，–image=nginx 是表示基于哪个镜像来创建一个Pod，Pod本身是对容器的封装，不写 namespace 就默认创建在 default 空间下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl run mynginx --image=nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>yaml 文件方式</p><ol><li><p>新建一个名为 <code>my-nginx.yaml</code> 的 YAML 文件，并写入下列内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> mynginx  <span class="token key atrule">name</span><span class="token punctuation">:</span> mynginx <span class="token comment">#Pod名称</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx <span class="token comment">#容器镜像名称</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> mynginx  <span class="token comment">#容器名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后运行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f pod/my-nginx.yaml pod/mynginx created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol></li></ul><h3 id="查看-Pod"><a href="#查看-Pod" class="headerlink" title="查看 Pod"></a>查看 Pod</h3><ul><li><p>查看某个名称空间的 Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pod -n defaultNAME      READY   STATUS    RESTARTS   AGEmynginx   1/1     Running   0          105s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>获取某个 Pod 的详细信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl describe pod mynginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看 Pod 运行日志</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl logs mynginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看 Pod详细信息，k8s会为每个Pod分配一个ip </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pod -owideNAME      READY   STATUS    RESTARTS   AGE     IP                NODE        NOMINATED NODE   READINESS GATESmynginx   1/1     Running   0          2m33s   192.168.169.132   k8s-node2   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>集群中的任意一个机器以及任意的应用都能通过Pod的ip来访问这个Pod</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# curl 192.168.169.132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html { color-scheme: light dark; }body { width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="删除-Pod"><a href="#删除-Pod" class="headerlink" title="删除 Pod"></a>删除 Pod</h3><ul><li><p>命令行方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete pod mynginx -n defaultpod "mynginx" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>yaml 文件方式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl delete -f pod/my-nginx.yaml  pod "mynginx" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="进入-Pod"><a href="#进入-Pod" class="headerlink" title="进入 Pod"></a>进入 Pod</h3><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@k8s-master ~]# kubectl exec -it mynginx -- /bin/bashroot@mynginx:/# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="一个Pod里面有两个容器"><a href="#一个Pod里面有两个容器" class="headerlink" title="一个Pod里面有两个容器"></a>一个Pod里面有两个容器</h3><ol><li><p>新建一个名为 <code>my-nginx-tomact.yaml</code> 的 YAML 文件，并写入下列内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> myapp  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp <span class="token comment">#Pod的名称</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default <span class="token comment">#在哪个名称空间下创建</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx  <span class="token comment">#第一个容器的镜像</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx <span class="token comment">#第一个容器的名称</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> tomcat<span class="token punctuation">:</span>8.5.68 <span class="token comment">#第二个容器的镜像</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> tomcat <span class="token comment">#第二个容器的名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后运行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl apply -f pod/my-nginx-tomact.yaml pod/myapp created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>验证创建成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get podNAME      READY   STATUS    RESTARTS   AGEmyapp     2/2     Running   0          5m21smynginx   1/1     Running   0          20m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>访问 myapp Pod 中的 nginx 容器</p><p>首先获取 Pod ip</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pod myapp -owideNAME    READY   STATUS    RESTARTS   AGE     IP              NODE        NOMINATED NODE   READINESS GATESmyapp   2/2     Running   0          8m11s   192.168.36.66   k8s-node1   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>访问默认的80端口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# curl 192.168.36.66<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>访问 myapp Pod 中的 tomcat 容器</p><p>首先获取 Pod ip，然后访问默认的8080端口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# curl 192.168.36.66:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>同一个 Pod 中的容器相互访问</p><p>因为同一个 Pod 中的容器他们<strong>共享存储、共享网络</strong>，所以直接使用 127.0.0.1 就可以访问</p><p>比如 myapp Pod 中 nginx 容器访问 tomcat 容器</p><p>进入某个Pod中的某个容器内</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl exec -it myapp -c tomcat -- /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">root@myapp:/usr/local/tomcat# curl 127.0.0.1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html { color-scheme: light dark; }body { width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/_print/">https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/_print/</a></p></li><li><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/namespaces/">https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/namespaces/</a></p></li><li><p><a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#using-pods">https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#using-pods</a></p></li><li><p><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/">https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 kubeadm 创建 Kubernetes 集群</title>
      <link href="/2022/08/14/shi-yong-kubeadm-chuang-jian-kubernetes-ji-qun/"/>
      <url>/2022/08/14/shi-yong-kubeadm-chuang-jian-kubernetes-ji-qun/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-kubeadm-创建-Kubernetes-集群"><a href="#使用-kubeadm-创建-Kubernetes-集群" class="headerlink" title="使用 kubeadm 创建 Kubernetes 集群"></a>使用 kubeadm 创建 Kubernetes 集群</h1><p>本文记录了使用 kubeadm 从头搭建一个使用 docker 作为容器运行时的 Kubernetes 集群的过程。</p><p>kubeadm 的源代码，直接就在 kubernetes/cmd/kubeadm 目录下，是kubernetes项目的一部分。</p><p>kubeadm几乎完全是一位高中生的作品。他叫Lucas Käldström，芬兰人，kubeadm 是他17岁时用业余时间完成的一个社区项目。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/lucas.png"></p><h2 id="Kubeadm是什么"><a href="#Kubeadm是什么" class="headerlink" title="Kubeadm是什么"></a>Kubeadm是什么</h2><p>Kubeadm 是一个命令行工具，它主要提供了 <code>kubeadm init</code> 以及 <code>kubeadm join</code>这两个命令来快速创建和初始化kubernetes 集群。</p><p>Kubeadm 通过执行必要的操作来启动和运行一个最小可用的集群。它被故意设计为只关心启动集群，而不是之前的节点准备工作。同样的，诸如安装各种各样的插件，例如 Kubernetes Dashboard、监控解决方案以及特定云提供商的插件，这些都不在它负责的范围。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/kubeadm-1.png"></p><h2 id="实践环境"><a href="#实践环境" class="headerlink" title="实践环境"></a>实践环境</h2><p>本次实验用到的机器如下：</p><table><thead><tr><th>主机名</th><th><strong>系统版本</strong></th><th>配置</th><th><strong>IP</strong></th><th>角色</th></tr></thead><tbody><tr><td>k8s-master</td><td>CentOS 7.9 64bit</td><td>2C4G</td><td>172.31.0.2</td><td>master</td></tr><tr><td>k8s-node1</td><td>CentOS 7.9 64bit</td><td>2C4G</td><td>172.31.0.3</td><td>worker</td></tr><tr><td>k8s-node2</td><td>CentOS 7.9 64bit</td><td>2C4G</td><td>172.31.0.4</td><td>worker</td></tr></tbody></table><p>软件版本：</p><ul><li><p>Docker：Docker-ce-20.10.7，Docker-ce-cli-20.10.7，Containerd.io-1.4.6</p></li><li><p>Kubernetes version：v1.20.9</p></li><li><p>Calico：3.21</p></li></ul><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><ul><li><p>每台机器 2 GB 或更多的 RAM（如果少于这个数字将会影响你应用的运行内存）</p></li><li><p>每台机器 CPU 2 核心及以上</p></li><li><p>集群中的所有机器的网络彼此均能相互连接（公网和内网都可以）</p></li><li><p>禁用交换分区。为了保证 kubelet 正常工作，你 <strong>必须</strong> 禁用交换分区</p></li></ul><p>相关环境的搭建和初始化笔者这里先行略过，可以选择阿里云、青云等</p><p>以下内容均使用root账户安装和配置。</p><h2 id="安装指导"><a href="#安装指导" class="headerlink" title="安装指导"></a>安装指导</h2><h3 id="安装Docker（所有节点）"><a href="#安装Docker（所有节点）" class="headerlink" title="安装Docker（所有节点）"></a>安装Docker（所有节点）</h3><ul><li><p>配置 yum 源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 安装 yum的工具包yum install -y yum-utils# 配置 docker 的 yum 源，告诉 Linux docker 去哪里下载yum-config-manager \--add-repo \http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装 docker</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动 docker 并设置开机自启动</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl enable docker --now<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证安装成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置镜像加速器地址</p><p>我们可以注册一个阿里云账号，然后使用阿里云容器镜像服务中的免费镜像</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/aliyun-mirror.png"></p><p>这里我们额外添加了docker的生产环境核心配置cgroup</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://txuroz75.mirror.aliyuncs.com"],  "exec-opts": ["native.cgroupdriver=systemd"],  "log-driver": "json-file",  "log-opts": {    "max-size": "100m"  },  "storage-driver": "overlay2"}EOFsystemctl daemon-reloadsystemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>验证配置生效</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="k8s-环境准备（所有节点）"><a href="#k8s-环境准备（所有节点）" class="headerlink" title="k8s 环境准备（所有节点）"></a>k8s 环境准备（所有节点）</h3><ul><li><p>设置主机名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#各个机器设置自己的域名hostnamectl set-hostname &lt;myhostname&gt;# 我自己的三台机器这样设置hostnamectl set-hostname k8s-masterhostnamectl set-hostname k8s-node1hostnamectl set-hostname k8s-node2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关闭交换分区</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 临时关闭swapoff -a  # 永久关闭sed -ri 's/.*swap.*/#&amp;/' /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>禁用 SELinux</p><p>将 SELinux 设置为 permissive 模式（相当于将其禁用）， 这是允许容器访问主机文件系统所必需的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 临时禁用setenforce 0# 永久禁用sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>允许 iptables 检查桥接流量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confbr_netfilterEOFcat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 让配置生效sudo sysctl --system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="安装-kubelet、kubectl、kubeadm（所有节点）"><a href="#安装-kubelet、kubectl、kubeadm（所有节点）" class="headerlink" title="安装 kubelet、kubectl、kubeadm（所有节点）"></a>安装 kubelet、kubectl、kubeadm（所有节点）</h3><ul><li><p>配置 yum 源</p><p>官网提供的 google 源一般用不了，这里直接换成阿里的源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kubelet kubeadm kubectlEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># --disableexcludes 禁掉除了kubernetes之外的别的仓库# 由于官网未开放同步方式, 替换成阿里源后可能会有索引 gpg 检查失败的情况, 这时请带上`--nogpgcheck`选项安装# 指定安装 1.20.9 版本sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes --nogpgcheck<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>kubelet 设置开机启动</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo systemctl enable kubelet --now <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="初始化-master-节点（k8s-master）"><a href="#初始化-master-节点（k8s-master）" class="headerlink" title="初始化 master 节点（k8s-master）"></a>初始化 master 节点（k8s-master）</h3><ul><li><p>生成 kubeadm.yaml 文件</p><p>首先导出 kubeadm 配置文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubeadm config print init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看所需镜像列表</p><pre class="line-numbers language-she" data-language="she"><code class="language-she">[root@k8s-master ~]# kubeadm config images list --config kubeadm.ymlk8s.gcr.io/kube-apiserver:v1.20.0k8s.gcr.io/kube-controller-manager:v1.20.0k8s.gcr.io/kube-scheduler:v1.20.0k8s.gcr.io/kube-proxy:v1.20.0k8s.gcr.io/pause:3.2k8s.gcr.io/etcd:3.4.13-0k8s.gcr.io/coredns:1.7.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用国内源拉取所需要的镜像</p><p>其它两个节点需要 kube-proxy ，我们为了方便就全部都安装，所以其它两个节点也执行下面的命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo tee ./images.sh &lt;&lt;-'EOF'#!/bin/bashimages=(kube-apiserver:v1.20.9kube-proxy:v1.20.9kube-controller-manager:v1.20.9kube-scheduler:v1.20.9coredns:1.7.0etcd:3.4.13-0pause:3.2)for imageName in ${images[@]} ; dodocker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageNamedoneEOF      chmod +x ./images.sh &amp;&amp; ./images.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行初始化</p><p>镜像拉取下来后就可以开始安装了，执行以下命令初始化主节点，只在主节点上执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#所有机器添加 master 域名映射，以下需要修改为自己的ip，master节点我们也叫做集群入口节点，让所有节点知道 master节点在哪echo "172.31.0.2  cluster-endpoint" &gt;&gt; /etc/hosts#主节点初始化# 注意：# --apiserver-advertise-address 修改成自己 master 节点机器的ip# --control-plane-endpoint 是上面 hosts 映射的值# --kubernetes-version 的版本号要对应# --service-cidr，--pod-network-cidr 值最好不要修改# 所有网络范围不能重叠： --service-cidr，--pod-network-cidr，三台机器ip都不能有重叠kubeadm init \--apiserver-advertise-address=172.31.0.2 \--control-plane-endpoint=cluster-endpoint \--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \--kubernetes-version v1.20.9 \--service-cidr=10.96.0.0/16 \--pod-network-cidr=192.168.0.0/16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​        输出如下恭喜你安装成功了</p><pre><code>   <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 出现这个就说明安装成功了Your Kubernetes control-plane has initialized successfully!# 执行下面的命令配置 kubeconfigTo start using your cluster, you need to run the following as a regular user:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/configAlternatively, if you are the root user, you can run:  export KUBECONFIG=/etc/kubernetes/admin.conf# 配置 pod 网络的命令You should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of control-plane nodes by copying certificate authoritiesand service account keys on each node and then running the following as root:# 哪个机器需要变成主节点执行该命令，这是为了多 master 集群  kubeadm join cluster-endpoint:6443 --token z9wjde.ewp0hefm2swxupn6 \    --discovery-token-ca-cert-hash sha256:336a976225818ce72ed9cf1b87bebda2b094f11732a0b622becc5a1b71b733be \    --control-plane Then you can join any number of worker nodes by running the following on each as root:# 哪个 node 节点想要加入集群需要执行如下指令kubeadm join cluster-endpoint:6443 --token z9wjde.ewp0hefm2swxupn6 \    --discovery-token-ca-cert-hash sha256:336a976225818ce72ed9cf1b87bebda2b094f11732a0b622becc5a1b71b733be<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre><p>​    按照提示配置 kubeconfig</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置好后查看一下 node 状态</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get nodeNAME         STATUS     ROLES                  AGE   VERSIONk8s-master   NotReady   control-plane,master   10m   v1.20.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>状态为 NotReady，因为此时还没有安装网络插件。</p><h3 id="部署Calico（k8s-master）"><a href="#部署Calico（k8s-master）" class="headerlink" title="部署Calico（k8s-master）"></a>部署Calico（k8s-master）</h3><p>注意 Calio 版本需要与 K8s 版本对应，具体要求看  <a href="https://projectcalico.docs.tigera.io/archive/v3.21/getting-started/kubernetes/requirements">requirements</a></p><p>安装参考官网：<a href="https://projectcalico.docs.tigera.io/archive/v3.21/getting-started/kubernetes/self-managed-onprem/onpremises">install calico</a></p><ul><li><p>下载配置文件并拉取镜像，只在 master 节点上执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl https://docs.projectcalico.org/archive/v3.21/manifests/calico.yaml -O<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>部署，只在 master 节点上执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f calico.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不错意外的话等一会 calico 就安装好了，可以通过以下命令查看：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get pods -ANAMESPACE     NAME                                       READY   STATUS    RESTARTS   AGEkube-system   calico-kube-controllers-5bb48c55fd-ghkdz   1/1     Running   0          8m10skube-system   calico-node-6vwgq                          1/1     Running   0          8m10skube-system   coredns-5897cd56c4-kqfn2                   1/1     Running   0          31mkube-system   coredns-5897cd56c4-wcgdh                   1/1     Running   0          31mkube-system   etcd-k8s-master                            1/1     Running   0          31mkube-system   kube-apiserver-k8s-master                  1/1     Running   0          31mkube-system   kube-controller-manager-k8s-master         1/1     Running   0          31mkube-system   kube-proxy-rnt4v                           1/1     Running   0          31mkube-system   kube-scheduler-k8s-master                  1/1     Running   0          31m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get nodeNAME         STATUS   ROLES                  AGE   VERSIONk8s-master   Ready    control-plane,master   32m   v1.20.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="Node节点加入集群（k8s-node1-k8s-node2）"><a href="#Node节点加入集群（k8s-node1-k8s-node2）" class="headerlink" title="Node节点加入集群（k8s-node1,k8s-node2）"></a>Node节点加入集群（k8s-node1,k8s-node2）</h3><ul><li>在k8s-node1,k8s-node2上执行该步骤，将节点加入到集群中</li></ul><p>先在  k8s-node1 、 k8s-node2节点执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubeadm join cluster-endpoint:6443 --token z9wjde.ewp0hefm2swxupn6 \    --discovery-token-ca-cert-hash sha256:336a976225818ce72ed9cf1b87bebda2b094f11732a0b622becc5a1b71b733be<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-node1 ~]# kubeadm join cluster-endpoint:6443 --token z9wjde.ewp0hefm2swxupn6 \&gt;     --discovery-token-ca-cert-hash sha256:336a976225818ce72ed9cf1b87bebda2b094f11732a0b622becc5a1b71b733be[preflight] Running pre-flight checks        [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 20.10.7. Latest validated version: 19.03        [WARNING Hostname]: hostname "k8s-node1" could not be reached        [WARNING Hostname]: hostname "k8s-node1": lookup k8s-node1 on 100.64.7.3:53: no such host[preflight] Reading configuration from the cluster...[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"[kubelet-start] Starting the kubelet[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...This node has joined the cluster:* Certificate signing request was sent to apiserver and a response was received.* The Kubelet was informed of the new secure connection details.Run 'kubectl get nodes' on the control-plane to see this node join the cluster.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>检查集群状态，在 k8s-master 上执行</p><ul><li><p>检查各组件运行状态</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]#  kubectl get csWarning: v1 ComponentStatus is deprecated in v1.19+NAME                 STATUS      MESSAGE                                                                                       ERRORscheduler            Unhealthy   Get "http://127.0.0.1:10251/healthz": dial tcp 127.0.0.1:10251: connect: connection refused   controller-manager   Unhealthy   Get "http://127.0.0.1:10252/healthz": dial tcp 127.0.0.1:10252: connect: connection refused   etcd-0               Healthy     {"health":"true"}   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考解决办法 ：<a href="https://stackoverflow.com/questions/54608441/kubectl-connectivity-issue">https://stackoverflow.com/questions/54608441/kubectl-connectivity-issue</a></p><p>出现这个问题的原因是 /etc/kubernetes/manifests/下的kube-controller-manager.yaml和kube-scheduler.yaml中启动参数设置的默认端口是0。<br>解决方法：将相应的<code>--port 0</code>参数注释掉，然后重启kubelet服务即可</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master manifests]#  kubectl get csWarning: v1 ComponentStatus is deprecated in v1.19+NAME                 STATUS    MESSAGE             ERRORscheduler            Healthy   ok                  controller-manager   Healthy   ok                  etcd-0               Healthy   {"health":"true"}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看集群信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl cluster-infoKubernetes control plane is running at https://cluster-endpoint:6443KubeDNS is running at https://cluster-endpoint:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxyTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看节点状态</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@k8s-master ~]# kubectl get nodesNAME         STATUS   ROLES                  AGE     VERSIONk8s-master   Ready    control-plane,master   42m     v1.20.9k8s-node1    Ready    &lt;none&gt;                 5m15s   v1.20.9k8s-node2    Ready    &lt;none&gt;                 5m10s   v1.20.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="kubeadm-token"><a href="#kubeadm-token" class="headerlink" title="kubeadm token"></a>kubeadm token</h3><p><code>kubeadm init</code> 创建了一个有效期为 24 小时的令牌，过期之后要需要生成新的令牌。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#  --print-join-command  不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。kubeadm token create --print-join-command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="kubernetes-dashboard"><a href="#kubernetes-dashboard" class="headerlink" title="kubernetes dashboard"></a>kubernetes dashboard</h3><blockquote><p>该步骤只在 master 节点上执行</p></blockquote><p>Dashboard 是基于网页的 Kubernetes 用户界面。您可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群本身及其附属资源。您可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源（如 Deployment，Job，DaemonSet 等等）。例如，您可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p><ul><li><p>下载配置文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml -O  dashboard.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>部署</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f dashboard.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置访问端口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>type: ClusterIP 改为 type: NodePort</strong></p></li><li><p>找到端口，在云服务器上的安全组放行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl get svc -A |grep kubernetes-dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p> 创建访问账号</p></li><li><p>创建访问账号，准备一个yaml文件； vi  dash-user.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>部署</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl apply -f dash-user.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取访问令牌</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath="{.secrets[0].name}") -o go-template="{{.data.token | base64decode}}"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>三个节点中任何一个节点都可以使用令牌登录</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/dashboard.png"></p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.docker.com/engine/install/centos/">install-docker</a></p><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm">install-kubeadm</a></p><p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">create-cluster-kubeadm</a></p><p><a href="https://projectcalico.docs.tigera.io/archive/v3.22/getting-started/kubernetes/self-managed-onprem/onpremises">Install Calico</a></p><p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm-token</a></p><p><a href="https://github.com/kubernetes/dashboard">kubernetes dashboard</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo 添加自定义环境并使用 docker-compose 部署</title>
      <link href="/2022/08/07/apollo-tian-jia-zi-ding-yi-huan-jing-bing-shi-yong-docker-compose-bu-shu/"/>
      <url>/2022/08/07/apollo-tian-jia-zi-ding-yi-huan-jing-bing-shi-yong-docker-compose-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/apollo.png"></p><p>Apollo（阿波罗）是一款可靠的分布式配置管理中心，诞生于携程框架研发部，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p><p>关于 Apollo 的详细介绍请阅读官网 <a href="https://www.apolloconfig.com/#/zh/">Apollo</a></p><p>本篇文章主要介绍如何添加自定义环境并使用 docker-compose 部署，把搭建使用过程中遇到的各种问题在此记录一下。</p><h2 id="二、为什么要添加自定义环境"><a href="#二、为什么要添加自定义环境" class="headerlink" title="二、为什么要添加自定义环境"></a>二、为什么要添加自定义环境</h2><p>官方的 Apollo 内置已经支持了以下几个环境：</p><ul><li>DEV（Development environment）开发环境</li><li>FAT（Feature Acceptance Test environment）功能验收测试环境，也就做测试环境，相当于alpha环境 (功能测试)</li><li>UAT（User Acceptance Test environment）用户验收测试环境，也叫做集成环境，相当于beta环境（回归测试）</li><li>PRO（Production environment）生产环境</li></ul><p>但某些时候我们应用中使用的环境在 Apollo 中是没有的或者使用的环境名称与 Aploo 内置环境名称不一样 ，比如一种情况是：我们应用部署时用 SIT（System Integration Test）来当做系统集成测试但在Apollo中是叫 UAT，这时如果去批量修改应用及调整 CI/CD 流程来兼容内置UAT环境，那成本是很高的，另一种情况是：我们需要额外添加一种环境，比如PRE（Pre-production environment）灰度环境。这两种情况下我们都需要添加自定义环境来适配我们已有的应用</p><h2 id="三、如何添加自定义环境"><a href="#三、如何添加自定义环境" class="headerlink" title="三、如何添加自定义环境"></a>三、如何添加自定义环境</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>GitHub下载： <a href="https://github.com/ctripcorp/apollo">https://github.com/ctripcorp/apollo</a> 源码，这里以 V1.1.0 版本为例</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 下载源码git clone git@github.com:apolloconfig/apollo.git # 找到自己想要的版本git tag# 取得 tag 对应的代码git checkout v1.1.0# 从 tag 创建一个分支就可以修改代码了git checkout -b apollo-1.1.0 v1.1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h3><ol><li><p>假设需要添加的环境名称叫 docker</p></li><li><p>修改 <code>com.ctrip.framework.apollo.core.enums.Env</code> 类，在其中加入<code>DOCKER</code>枚举：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Env</span><span class="token punctuation">{</span>  LOCAL<span class="token punctuation">,</span> DEV<span class="token punctuation">,</span> FWS<span class="token punctuation">,</span> FAT<span class="token punctuation">,</span> UAT<span class="token punctuation">,</span> LPT<span class="token punctuation">,</span> PRO<span class="token punctuation">,</span> TOOLS<span class="token punctuation">,</span> UNKNOWN<span class="token punctuation">,</span> DOCKER<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改<code>com.ctrip.framework.apollo.core.enums.EnvUtils</code>类，在其中加入<code>DOCKER</code>枚举的转换逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">EnvUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Env</span> <span class="token function">transformEnv</span><span class="token punctuation">(</span><span class="token class-name">String</span> envName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>envName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>UNKNOWN<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>envName<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> <span class="token string">"LPT"</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>LPT<span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"FAT"</span><span class="token operator">:</span>      <span class="token keyword">case</span> <span class="token string">"FWS"</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>FAT<span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"UAT"</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>UAT<span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"PRO"</span><span class="token operator">:</span>      <span class="token keyword">case</span> <span class="token string">"PROD"</span><span class="token operator">:</span> <span class="token comment">//just in case</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>PRO<span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"DEV"</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>DEV<span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"LOCAL"</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>LOCAL<span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"TOOLS"</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>TOOLS<span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"DOCKER"</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>DOCKER<span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token keyword">return</span> <span class="token class-name">Env</span><span class="token punctuation">.</span>UNKNOWN<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改<code>apollo-portal/src/main/resources/apollo-env.properties</code>，增加<code>docker.meta</code>占位符：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">local.meta</span><span class="token punctuation">=</span><span class="token attr-value">http://localhost:8080</span><span class="token attr-name">dev.meta</span><span class="token punctuation">=</span><span class="token attr-value">${dev_meta}</span><span class="token attr-name">fat.meta</span><span class="token punctuation">=</span><span class="token attr-value">${fat_meta}</span><span class="token attr-name">uat.meta</span><span class="token punctuation">=</span><span class="token attr-value">${uat_meta}</span><span class="token attr-name">lpt.meta</span><span class="token punctuation">=</span><span class="token attr-value">${lpt_meta}</span><span class="token attr-name">pro.meta</span><span class="token punctuation">=</span><span class="token attr-value">${pro_meta}</span><span class="token attr-name">docker.meta</span><span class="token punctuation">=</span><span class="token attr-value">${docker_meta}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改<code>com.ctrip.framework.apollo.core.internals.LegacyMetaServerProvider</code>类，增加读取<code>DOCKER</code>环境的meta server地址逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LegacyMetaServerProvider</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> domains<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Env</span><span class="token punctuation">.</span>DOCKER<span class="token punctuation">,</span>            env<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"docker_meta"</span><span class="token punctuation">,</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"docker.meta"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查安装 Java  JDK 和 Maven，进入源码文件夹 scripts 下 执行 build 脚本，编译打包 apollo</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 源码文件夹 scripts 下cd /path/to/apollo/scripts# 编译打包 apollo./build.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="创建自定义环境的数据库"><a href="#创建自定义环境的数据库" class="headerlink" title="创建自定义环境的数据库"></a>创建自定义环境的数据库</h3><ol><li>创建自定义环境需要的 ApolloConfigDB 库</li></ol><p>一套Portal可以管理多个环境，但是每个环境都需要独立部署一套Config Service、Admin Service和ApolloConfigDB</p><p>在源码的 scripts 文件夹下面找到 sql 的部署脚本，复制一份 apolloconfigdb.sql 并命名为 <code>apolloconfigdb_docker.sql</code></p><ul><li><p>修改建库语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Create Database</span><span class="token comment"># ------------------------------------------------------------</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> ApolloConfigDBDocker <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4<span class="token punctuation">;</span><span class="token keyword">Use</span> ApolloConfigDBDocker<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调整自定义环境的 Eureka 地址</p></li></ul><p>因为我们给自定义 docker 环境分配的 config service 端口为：8084，所以修改<code>apolloconfigdb_docker.sql</code> 文件中 <code>ServiceConfig</code>表<code>eureka.service.url</code> 字段值指向自己的 Eureka 地址，如下所示：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Config</span><span class="token comment"># ------------------------------------------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>ServerConfig<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span><span class="token keyword">Key</span><span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>Cluster<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span><span class="token keyword">Value</span><span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span><span class="token keyword">Comment</span><span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token string">'eureka.service.url'</span><span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:8084/eureka/'</span><span class="token punctuation">,</span> <span class="token string">'Eureka服务Url，多个service以英文逗号分隔'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'namespace.lock.switch'</span><span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token string">'false'</span><span class="token punctuation">,</span> <span class="token string">'一次发布只能有一个人修改开关'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'item.value.length.limit'</span><span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token string">'20000'</span><span class="token punctuation">,</span> <span class="token string">'item value最大长度限制'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'config-service.cache.enabled'</span><span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token string">'false'</span><span class="token punctuation">,</span> <span class="token string">'ConfigService是否开启缓存，开启后能提高性能，但是会增大内存消耗！'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'item.key.length.limit'</span><span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token string">'128'</span><span class="token punctuation">,</span> <span class="token string">'item key 最大长度限制'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>添加自定义环境</li></ul><p>在 <code>apolloportaldb.sql</code> 文件中 <code>ServerConfig</code>表<code>apollo.portal.envs</code>字段中添加我们自定义的 docker 环境，如下所示：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Config</span><span class="token comment"># ------------------------------------------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>ServerConfig<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span><span class="token keyword">Key</span><span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span><span class="token keyword">Value</span><span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span><span class="token keyword">Comment</span><span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token string">'apollo.portal.envs'</span><span class="token punctuation">,</span> <span class="token string">'dev,uat,fat,pro,docker'</span><span class="token punctuation">,</span> <span class="token string">'可支持的环境列表'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'organizations'</span><span class="token punctuation">,</span> <span class="token string">'[{\"orgId\":\"TEST1\",\"orgName\":\"样例部门1\"},{\"orgId\":\"TEST2\",\"orgName\":\"样例部门2\"}]'</span><span class="token punctuation">,</span> <span class="token string">'部门列表'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'superAdmin'</span><span class="token punctuation">,</span> <span class="token string">'apollo'</span><span class="token punctuation">,</span> <span class="token string">'Portal超级管理员'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'api.readTimeout'</span><span class="token punctuation">,</span> <span class="token string">'10000'</span><span class="token punctuation">,</span> <span class="token string">'http接口read timeout'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'consumer.token.salt'</span><span class="token punctuation">,</span> <span class="token string">'someSalt'</span><span class="token punctuation">,</span> <span class="token string">'consumer token salt'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token string">'admin.createPrivateNamespace.switch'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">,</span> <span class="token string">'是否允许项目管理员创建私有namespace'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2 . 进入MySql 中导入数据库脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source /sql/apolloportaldb.sqlsource /sql/apolloconfigdb.sqlsource /sql/apolloconfigdb_docker.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="三、使用-docker-compose-部署添加自定义环境后的-Apollo"><a href="#三、使用-docker-compose-部署添加自定义环境后的-Apollo" class="headerlink" title="三、使用 docker-compose 部署添加自定义环境后的 Apollo"></a>三、使用 docker-compose 部署添加自定义环境后的 Apollo</h2><p>本 docker 是针对 <a href="https://github.com/foxiswho/docker-apollo">https://github.com/foxiswho/docker-apollo</a> 的改动</p><ol><li><p>修改源码编译打包后复制 apollo-configservice/target/apollo-configservice-1.1.0-github.zip ，apollo-adminservice/target/apollo-adminservice-1.1.0-github.zip ，apollo-portal/target/apollo-portal-1.1.0-github.zip  这三个 zip 文件到指定的文件夹下，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/docker-apollo_1.png"></p></li><li><p>建立 Dockerfile 文件，添加 docker 环境，完整内容如下：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM maven:alpine# 改动自  https://github.com/foxiswho/docker-apolloMAINTAINER quanzhang875 &lt;quanzhang875@gmail.com&gt;# 添加自定义 docker 环境的 admin端口：8094，config端口：8084ENV VERSION=1.1.0 \    PORTAL_PORT=8070 \    ADMIN_DEV_PORT=8090 \    ADMIN_FAT_PORT=8091 \    ADMIN_UAT_PORT=8092 \    ADMIN_PRO_PORT=8093 \    ADMIN_DOCKER_PORT=8094 \    CONFIG_DEV_PORT=8080 \    CONFIG_FAT_PORT=8081 \    CONFIG_UAT_PORT=8082 \    CONFIG_PRO_PORT=8083 \    CONFIG_DOCKER_PORT=8084ARG APOLLO_URL=https://github.com/ctripcorp/apollo/archive/v${VERSION}.tar.gzCOPY docker-entrypoint /usr/local/bin/docker-entrypoint# 下面的包是修改过的源码，加入了自定义环境dockerADD apollo-portal-${VERSION}-github.zip /ADD apollo-adminservice-${VERSION}-github.zip /ADD apollo-configservice-${VERSION}-github.zip /# 建立 docker 环境需要的admin和config目录RUN cd / &amp;&amp; \    mkdir /apollo-admin/dev /apollo-admin/fat /apollo-admin/uat /apollo-admin/pro /apollo-admin/docker -p &amp;&amp; \    mkdir /apollo-config/dev /apollo-config/fat /apollo-config/uat /apollo-config/pro /apollo-config/docker -p &amp;&amp; \    mkdir /apollo-portal -p &amp;&amp; \    unzip -o /apollo-adminservice-${VERSION}-github.zip -d /apollo-admin/dev &amp;&amp; \    unzip -o /apollo-configservice-${VERSION}-github.zip -d /apollo-config/dev &amp;&amp; \    unzip -o /apollo-portal-${VERSION}-github.zip -d /apollo-portal &amp;&amp; \    sed -e "s/db_password=/db_password=root/g"  \            -e "s/^local\.meta.*/local.meta=http:\/\/localhost:${PORTAL_PORT}/" \            -e "s/^dev\.meta.*/dev.meta=http:\/\/localhost:${CONFIG_DEV_PORT}/" \            -e "s/^fat\.meta.*/fat.meta=http:\/\/localhost:${CONFIG_FAT_PORT}/" \            -e "s/^uat\.meta.*/uat.meta=http:\/\/localhost:${CONFIG_UAT_PORT}/" \            -e "s/^pro\.meta.*/pro.meta=http:\/\/localhost:${CONFIG_PRO_PORT}/" \            -e "s/^docker\.meta.*/docker.meta=http:\/\/localhost:${CONFIG_DOCKER_PORT}/" -i /apollo-portal/config/apollo-env.properties &amp;&amp; \    cp -rf /apollo-admin/dev/scripts /apollo-admin/dev/scripts-default  &amp;&amp; \    cp -rf /apollo-config/dev/scripts /apollo-config/dev/scripts-default  &amp;&amp; \    cp -rf /apollo-admin/dev/*  /apollo-admin/docker/  &amp;&amp; \    cp -rf /apollo-config/dev/* /apollo-config/docker/  &amp;&amp; \    cp -rf /apollo-admin/dev/* /apollo-admin/uat/  &amp;&amp; \    cp -rf /apollo-admin/dev/* /apollo-admin/pro/  &amp;&amp; \    cp -rf /apollo-config/dev/* /apollo-config/uat/  &amp;&amp; \    cp -rf /apollo-config/dev/* /apollo-config/pro/ &amp;&amp; \     rm -rf *zip &amp;&amp; \    chmod +x  /usr/local/bin/docker-entrypointEXPOSE 8070 8080 8081 8082 8083 8084 8090 8091 8092 8093 8094# EXPOSE 80-60000ENTRYPOINT ["docker-entrypoint"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>建立 docker-entrypoint 脚本，添加 docker 环境</p></li><li><p>构建镜像并把镜像推送到远程仓库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 构建镜像./build.sh # 给镜像打个标记docker tag apollo-test:&lt;TAG&gt; dendi875/docker-apollo:1.1.0# 登录docker hubdocker login# 把镜像推送到远程仓库docker push  dendi875/docker-apollo:1.1.0 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用 Docker Compose 启动，看到如下界面就代表启动成功</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/apollo_2.png"></p></li><li><p>使用账号密码：apollo/admin 访问 Apollo 前台，效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/apollo_3.png"></p></li></ol><p><strong>完整的Dockerfile、docker-entrypoint、构建 docker-apollo 的源代码仓库地址：<a href="https://github.com/dendi875/docker-apollo">https://github.com/dendi875/docker-apollo</a></strong></p><h2 id="四、如何在应用中使用添加自定义环境后的-Apollo"><a href="#四、如何在应用中使用添加自定义环境后的-Apollo" class="headerlink" title="四、如何在应用中使用添加自定义环境后的 Apollo"></a>四、如何在应用中使用添加自定义环境后的 Apollo</h2><h3 id="把修改过的-Apollo-Clien-jar-包上传到-nexus-私有仓库"><a href="#把修改过的-Apollo-Clien-jar-包上传到-nexus-私有仓库" class="headerlink" title="把修改过的 Apollo Clien jar 包上传到 nexus 私有仓库"></a>把修改过的 Apollo Clien jar 包上传到 nexus 私有仓库</h3><p>因为我们应用中要使用添加自定义环境后的 Apollo Client jar 包，所以首先得把修改后的 jar 包上传到私有仓库</p><ol><li><p>修改 Maven【settings.xml】文件在【servers】标签下加入分配给自己的用户名密码，注意id要唯一，下面会用到</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>server</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>releases<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。--&gt;</span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">&gt;</span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>server</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>server</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>snapshots<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">&gt;</span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>server</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改 apollo 父 POM 的distributionManagement来指定Maven分发构件的位置，id是之前设置的【server】的id，url是对应的仓库地址</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>distributionManagement</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与配置文件中server元素的id相匹配--&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>releases<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">&gt;</span></span>http://localhost:8018/repository/testRelease/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>snapshotRepository</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>snapshots<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与配置文件中server元素的id相匹配--&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">&gt;</span></span>http://localhost:8018/repository/testSnapshot/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>snapshotRepository</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>distributionManagement</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用 mvn deploy 将项目生成的 jar 包上传到远程 nexus 仓库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入 apollo-core module 目录下cd /path/to/apollo/apollo-core # 执行命令 mvn deploymvn deploy# 进入 apollo-client module 目录下cd /path/to/apollo/apollo-client# 执行命令 mvn deploymvn deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>远程nexus仓库查看，可以发现已上传成功</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/apollo_nexus.png"></p></li></ol><h3 id="从-nexus-私有仓库下载修改过的-Apollo-Clien-jar-包"><a href="#从-nexus-私有仓库下载修改过的-Apollo-Clien-jar-包" class="headerlink" title="从 nexus 私有仓库下载修改过的 Apollo Clien jar 包"></a>从 nexus 私有仓库下载修改过的 Apollo Clien jar 包</h3><ol><li><p>新建一个测试的Spring Boot 应用，在应用的 POM 中配置仓库，例如：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repositories</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- zhangquan 的 nexus 私有仓库，主要为了引用修改过的Apollo包，增加 docker 自定义环境 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>releases<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>zhangquan的nexus Repository<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">&gt;</span></span>http://localhost:8018/repository/testRelease/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>snapshots</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">&gt;</span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>snapshots</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>releases</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>releases</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span><span class="token punctuation">&gt;</span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repositories</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>引入修改过的 Apollo Clien jar 包</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.ctrip.framework.apollo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>apollo-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加注解来告诉程序开启apollo配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableApolloConfig</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"application"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>src/main/resources/application-docker.yml 配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> apollo<span class="token punctuation">-</span>extended<span class="token punctuation">-</span>env  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>apollo 监听并动态刷新</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApolloChangeListener</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span>            <span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">ApolloChangeListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApolloConfigChangeListener</span>    <span class="token keyword">public</span> <span class="token keyword">void</span>  <span class="token function">onChange</span><span class="token punctuation">(</span><span class="token class-name">ConfigChangeEvent</span> changeEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"ApolloChangeListener onChange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> changeEvent<span class="token punctuation">.</span><span class="token function">changedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ConfigChange</span> cc <span class="token operator">=</span> changeEvent<span class="token punctuation">.</span><span class="token function">getChange</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"\t {}.{} from '{}' to '{}'"</span><span class="token punctuation">,</span> cc<span class="token punctuation">.</span><span class="token function">getNamespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    cc<span class="token punctuation">.</span><span class="token function">getPropertyName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cc<span class="token punctuation">.</span><span class="token function">getOldValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cc<span class="token punctuation">.</span><span class="token function">getNewValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 apollo 上创建项目，并在项目里的 DOCKER 环境中添加相应配置</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/apollo-extended-env.png"></p></li><li><p>启动时加上vm options参数：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-Denv=docker -Dapp.id=apollo-extended-env -Ddocker_meta=http://apollo:8084 -Dspring.profiles.active=docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>完整代码示例：<a href="https://github.com/dendi875/apollo-extended-env">https://github.com/dendi875/apollo-extended-env</a></strong></p><h3 id="把-apollo-与Spring-Boot应用整合，并使用-docker-compose-部署测试配置项的变化"><a href="#把-apollo-与Spring-Boot应用整合，并使用-docker-compose-部署测试配置项的变化" class="headerlink" title="把 apollo 与Spring Boot应用整合，并使用 docker-compose 部署测试配置项的变化"></a>把 apollo 与Spring Boot应用整合，并使用 docker-compose 部署测试配置项的变化</h3><ol><li><p>docker-compose.yaml 文件中添加Spring Boot 测试应用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">version: '3'services:  #测试应用中使用添加自定义环境后的 Apollo 功能  apollo-extended-env:    image: dendi875/apollo-extended-env:1.0.0    container_name: apollo-extended-env    restart: always    ports:      - 8051:8051    environment:      - 'TZ="Asia/Shanghai"'    networks: #要加入的网络（同一网络上的服务可以使用它们的名称相互通信）      zq:        aliases:          - apollo-extended-env    depends_on:      - apollo # 创建网络以使容器之间通信networks:  zq:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd /path/to/docker-apollodocker-compose up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在 Apollo 上添加配置项</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/apollo-extended-env-1.png"></p></li><li><p>修改配置项，观察应用中的配置项变化情况</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/apollo-extended-env-2.png"></p></li></ol><p><strong>完整的Dockerfile、docker-entrypoint、构建 docker-apollo 的源代码仓库地址：<a href="https://github.com/dendi875/docker-apollo">https://github.com/dendi875/docker-apollo</a></strong></p><h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul><li><a href="https://www.apolloconfig.com/#/zh/README">https://www.apolloconfig.com/#/zh/README</a></li><li><a href="https://github.com/foxiswho/docker-apollo">https://github.com/foxiswho/docker-apollo</a></li><li><a href="https://github.com/foxiswho/docker-consul-fabio-apollo-rocketmq-rabbitmq">https://github.com/foxiswho/docker-consul-fabio-apollo-rocketmq-rabbitmq</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apollo、Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 Streams API 详解</title>
      <link href="/2022/07/17/java-8-streams-api-xiang-jie/"/>
      <url>/2022/07/17/java-8-streams-api-xiang-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出处：<a href="http://dengchengchao.com/">邓承超的个人日志</a></p></blockquote><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/java8-stream.png"></p><p>流式编程作为Java 8的亮点之一，是继<code>Java 5</code>之后对集合的再一次升级，可以说<code>Java 8</code>几大特性中，<code>Streams API</code> 是作为Java 函数式的主角来设计的,夸张的说，有了<code>Streams API</code>之后，万物皆可一行代码。</p><h2 id="二、什么是-Stream"><a href="#二、什么是-Stream" class="headerlink" title="二、什么是 Stream"></a>二、什么是 Stream</h2><p>Stream被翻译为流，它的工作过程像将一瓶水导入有很多过滤阀的管道一样，水每经过一个过滤阀，便被操作一次，比如过滤，转换等，最后管道的另外一头有一个容器负责接收剩下的水。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/java8-stream2.png"></p><p>首先通过<code>source</code>产生流，然后依次通过一些中间操作，比如过滤，转换，限制等，最后结束对流的操作。</p><p>Stream`</p><h2 id="三、为什么需要Stream"><a href="#三、为什么需要Stream" class="headerlink" title="三、为什么需要Stream"></a>三、为什么需要Stream</h2><p>Stream作为Java 8的一大亮点，它专门针对集合的各种操作提供各种非常便利，简单，高效的API，<code>Stream API</code>主要是通过<code>Lambda</code>表达式完成，极大的提高了程序的效率和可读性，同时<code>Stram API</code>中自带的并行流使得并发处理集合的门槛再次降低，使用<code>Stream API</code>编程无需多写一行多线程的大门就可以非常方便的写出高性能的并发程序。使用<code>Stream API</code>能够使你的代码更加优雅。</p><p>流的另一特点是可无限性，使用<code>Stream</code>，你的数据源可以是无限大的。</p><p>在没有<code>Stream</code>之前，我们想提取出所有年龄大于18的学生，我们需要这样做：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Student</span> student <span class="token operator">:</span> students<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Stream,我们可以参照上面的流程示意图来做，首先产生Stream,然后filter过滤，最后归并到容器中。</p><p>转换为代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> student<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>首先<code>stream()</code>获得流 </li><li>然后<code>filter((student) -&gt; student.getAge() &gt; 18)</code>过滤</li><li>最后<code>collect(Collectors.toList())</code>归并到容器中</li></ul><p>是不是很像在写sql?</p><h2 id="四、如何使用Stream"><a href="#四、如何使用Stream" class="headerlink" title="四、如何使用Stream"></a>四、如何使用Stream</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/java8-stream3.png"></p><p>我们可以发现，当我们使用一个流的时候，主要包括三个步骤：</p><ul><li>获取流</li><li>对流进行操作</li><li>结束对流的操作</li></ul><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取</p><p>例如：</p><ul><li><code>Collection.stream()</code></li><li><code>Collection.parallelStream()</code></li><li><code>Arrays.stream(T array) or Stream.of()</code></li></ul><p>对于 <code>I/O</code>，我们也可以通过 <code>lines()</code> 方法获取流：</p><ul><li><code>java.nio.file.Files.walk()</code></li><li><code>java.io.BufferedReader.lines()</code></li></ul><p>最后，我们还可以从无限大的数据源中产生流：</p><ul><li><code>Random.ints()</code></li></ul><p>值得注意的是，JDK中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p><ul><li><code>IntStream</code></li><li><code>LongStream</code></li><li><code>DoubleStream</code></li></ul><p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Intstream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Intstream</span><span class="token punctuation">.</span><span class="token function">rang</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="对流进行操作"><a href="#对流进行操作" class="headerlink" title="对流进行操作"></a>对流进行操作</h3><p>这是本章的重点，产生流比较容易，但是不同的业务系统的需求会涉及到很多不同的要求，明白我们能对流做什么，怎么做，才能更好的利用Stream API的特点。</p><p><strong>流的操作类型分为两种:</strong></p><ul><li><strong>Intermediate</strong>：中间操作，一个流可以后面跟随零个或多个<code>intermediate</code>操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后会返回一个新的流，交给下一个操作使用。这类操作都是<strong>惰性化的（lazy）</strong>，就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li></ul><p><code>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</code></p><ul><li><strong>Terminal</strong>：终结操作，一个流只能有一个<code>terminal</code>操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。<code>Terminal</code>操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li></ul><p><code>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</code></p><p><code>Intermediate</code>和<code>Terminal</code>完全可以按照上图的流程图理解，<code>Intermediate</code>表示在管道中间的过滤器，水会流入过滤器，然后再流出去，而<code>Terminal</code>操作便是最后一个过滤器，它在管道的最后面，流入<code>Terminal</code>的水，最后便会流出管道。</p><p>下面依次详细的解读下每一个操作所能产生的效果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zq1"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zq2"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zq3"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zq4"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zq5"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>对于中间操作，所有的<code>API</code>的返回值基本都是<code>Stream&lt;T&gt;</code>,因此以后看见一个陌生的<code>API</code>也能通过返回值判断它的所属类型。</p><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map顾名思义，就是映射，map操作能够将流中的每一个元素映射为另外的元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> mapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到map接受的是一个Function,也就是接收参数，并返回一个值。</p><p>比如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 提取 List&lt;Student&gt;  所有student 的名字 </span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的代码等同于以前的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Student</span> student <span class="token operator">:</span> students<span class="token punctuation">)</span> <span class="token punctuation">{</span>    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再比如：将List中所有字母转换为大写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> wards <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> upperWords <span class="token operator">=</span> wards<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><p><code>flatMap</code>顾名思义就是扁平化映射，它具体的操作是将多个<code>stream</code>连接成一个<code>stream</code>，这个操作是针对类似多维数组的，比如容器里面包含容器等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> ints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> flatInts <span class="token operator">=</span> ints<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token operator">::</span><span class="token function">stream</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，相当于降维。</p><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter顾名思义，就是过滤，通过测试的元素会被留下来并生成一个新的Stream</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，我们可以<code>filter</code>接收的参数是<code>Predicate</code>，也就是推断型函数式接口，接收参数，并返回<code>boolean</code>值。</p><p>比如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取所有年龄大于18岁的学生</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> student<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><p><code>distinct</code>是去重操作,它没有参数</p><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p><code>sorted</code>排序操作，默认是从小到大排列，<code>sorted</code>方法包含一个重载，使用<code>sorted</code>方法，如果没有传递参数，那么流中的元素就需要实现<code>Comparable&lt;T&gt;</code>方法，也可以在使用<code>sorted</code>方法的时候传入一个<code>Comparator&lt;T&gt;</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得一说的是这个<code>Comparator</code>在<code>Java 8</code>之后被打上了<code>@FunctionalInterface</code>,其他方法都提供了<code>default</code>实现，因此我们可以在<code>sort</code>中使用<code>Lambda</code>表达式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 以年龄倒序</span>students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然而还有更方便的，<code>Comparator</code>默认也提供了实现好的方法引用，使得我们更加方便的使用：</p><p>例如上面的代码可以改成如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 以年龄倒序</span>students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 以姓名倒序</span>students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: </span><span class="token class-name">Student</span><span class="token punctuation">(</span>name<span class="token operator">=</span>zq4<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">38</span><span class="token punctuation">)</span><span class="token class-name">Student</span><span class="token punctuation">(</span>name<span class="token operator">=</span>zq3<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token class-name">Student</span><span class="token punctuation">(</span>name<span class="token operator">=</span>zq2<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token class-name">Student</span><span class="token punctuation">(</span>name<span class="token operator">=</span>zq1<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h5><p><code>peek</code>有遍历的意思，和<code>forEach</code>一样，但是它是一个中间操作。</p><p><code>peek</code>接受一个消费型的函数式接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 去重以后打印出来，然后再归并为List</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">limit</span><span class="token punctuation">(</span><span class="token keyword">long</span> maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>limit</code>裁剪操作，和<code>String::subString(0,x)</code>有点类似，<code>limit</code>接受一个<code>long</code>类型参数，通过<code>limit</code>之后的元素只会剩下<code>min(n,size)</code>个元素，<code>n</code>表示参数，<code>size</code>表示流中元素个数</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//只留下前3个元素并打印</span>students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h5><p><code>skip</code>表示跳过多少个元素，和<code>limit</code>比较像，不过<code>limit</code>是保留前面的元素，<code>skip</code>是保留后面的元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">skip</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//跳过前3个元素并打印 </span>students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h4><p>一个流处理中，有且只能有一个终结操作，通过终结操作之后，流才真正被处理，终结操作一般都返回其他的类型而不再是一个流,一般来说，终结操作都是将其转换为一个容器。</p><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p><code>forEach</code>是终结操作的遍历，操作和<code>peek</code>一样，但是<code>forEach</code>之后就不会再返回流</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//遍历打印</span>students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的代码和一下代码效果相同：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Student</span> student <span class="token operator">:</span> students<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h5><p><code>toArray</code>和<code>List##toArray()</code>用法差不多，包含一个重载。</p><p>默认的<code>toArray()</code>返回一个<code>Object[]</code>，</p><p>也可以传入一个<code>IntFunction&lt;A[]&gt; generator</code>指定数据类型</p><p>一般建议第二种方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">A</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">IntFunction</span><span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> generator<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="max-min"><a href="#max-min" class="headerlink" title="max/min"></a>max/min</h5><p><code>max/min</code>即使找出最大或者最小的元素。<code>max/min</code>必须传入一个<code>Comparator</code>。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 找到年龄最小的学生</span> <span class="token class-name">Student</span> student <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p><code>count</code>返回流中的元素数量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> count <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p><code>reduce</code>为归纳操作，主要是将流中各个元素结合起来，它需要提供一个起始值，然后按一定规则进行运算，比如相加等，它接收一个二元操作 <code>BinaryOperator</code>函数式接口。从某种意义上来说，<code>sum,min,max,average</code>都是特殊的<code>reduce</code></p><p><code>reduce</code>包含三个重载：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">T</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">T</span> identity<span class="token punctuation">,</span> <span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">U</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">U</span> identity<span class="token punctuation">,</span>             <span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> accumulator<span class="token punctuation">,</span>             <span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> combiner<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> sum <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>reduce</code>两个参数和一个参数的区别在于有没有提供一个起始值，</p><p>如果提供了起始值，则可以返回一个确定的值，如果没有提供起始值，则返回<code>Opeational</code>防止流中没有足够的元素。</p><h5 id="anyMatch-allMatch-noneMatch"><a href="#anyMatch-allMatch-noneMatch" class="headerlink" title="anyMatch\ allMatch\ noneMatch"></a>anyMatch\ allMatch\ noneMatch</h5><p>测试是否有任意元素\所有元素\没有元素匹配表达式</p><p>他们都接收一个推断类型的函数式接口：<code>Predicate</code></p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> test <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="findFirst、-findAny"><a href="#findFirst、-findAny" class="headerlink" title="findFirst、 findAny"></a>findFirst、 findAny</h5><p>获取元素，这两个API都不接受任何参数，<code>findFirt</code>返回流中第一个元素，<code>findAny</code>返回流中任意一个元素。</p><p>也有有人会问<code>findAny()</code>这么奇怪的操作谁会用？这个API主要是为了在并行条件下想要获取任意元素，以最大性能获取任意元素</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> integer <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><p><code>collect</code>收集操作，这个<code>API</code>放在后面将是因为它太重要了，基本上所有的流操作最后都会使用它。</p><p>我们先看<code>collect</code>的定义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">,</span>              <span class="token class-name">BiConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> accumulator<span class="token punctuation">,</span>              <span class="token class-name">BiConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> combiner<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">R</span> <span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> collector<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>collect</code>包含两个重载：</p><p>一个参数和三个参数，</p><p>三个参数我们很少使用，因为<code>JDK</code>提供了足够我们使用的<code>Collector</code>供我们直接使用,我们可以简单了解下这三个参数什么意思：</p><ul><li><code>Supplier</code>:用于产生最后存放元素的容器的生产者</li><li><code>accumulator</code>:将元素添加到容器中的方法</li><li><code>combiner</code>：将分段元素全部添加到容器中的方法</li></ul><p>前两个元素我们都很好理解，第三个元素是干嘛的呢？因为流提供了并行操作，因此有可能一个流被多个线程分别添加，然后再将各个子列表依次添加到最终的容器中。</p><p>↓ – – – – – – – – –</p><p>↓ — — —</p><p>↓ ———</p><p>如上图，分而治之。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token operator">::</span><span class="token function">addAll</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来看只有一个参数的<code>collect</code></p><p>一般来说，只有一个参数的<code>collect</code>，我们都直接传入<code>Collectors</code>中的方法引用即可</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>Collectors</code>中包含很多常用的转换器。<code>toList()</code>,<code>toSet()</code>等。</p><p><code>Collectors</code>中还包括一个<code>groupBy()</code>，他和<code>Sql</code>中的<code>groupBy</code>一样都是分组，返回一个<code>Map</code></p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 按年龄分组</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>groupingBy</code>可以接受3个参数，分别是</p><ul><li>第一个参数：分组按照什么分</li><li>第二个参数：分组最后用什么容器保存返回（当只有两个参数是，此参数默认为<code>HashMap</code>）</li><li>第三个参数：按照第一个参数分后，对应的分类的结果如何收集</li></ul><p>有时候单参数的<code>groupingBy</code>不满足我们需求的时候，我们可以使用多个参数的<code>groupingBy</code></p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//将学生以年龄分组，每组中只存学生的名字而不是对象</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>        <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>            <span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span>            <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">mapping</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>toList</code>默认生成的是<code>ArrayList</code>,<code>toSet</code>默认生成的是<code>HashSet</code>，如果想要指定其他容器，可以如下操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>        <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span><span class="token class-name">TreeSet</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>Collectors</code>还包含一个<code>toMap</code>，利用这个API我们可以将<code>List</code>转换<code>为Map</code></p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>        <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">,</span> s <span class="token operator">-&gt;</span> s<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Collectors.toMap，最后一个参数表示元素有重复时保留哪一个元素</p><p>值得注意的一点是，<code>IntStream</code>，<code>LongStream</code>,<code>DoubleStream</code>是没有<code>collect()</code>方法的，因为对于基本数据类型，要进行装箱，拆箱操作，SDK并没有将它放入流中，对于基本数据类型流，我们只能将其<code>toArray()</code></p><h2 id="五、优雅的使用Stream"><a href="#五、优雅的使用Stream" class="headerlink" title="五、优雅的使用Stream"></a>五、优雅的使用Stream</h2><p>了解了<code>Stream API</code>，下面详细介绍一下如果优雅的使用<code>Steam</code></p><ul><li>了解流的惰性操作</li></ul><p>前面说到，流的中间操作是惰性的，如果一个流操作流程中只有中间操作，没有终结操作，那么这个流什么都不会做，整个流程中会一直等到遇到终结操作操作才会真正的开始执行。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的流操作只有中间操作，没有终结操作，那么不管流里面包含多少元素，他都不会执行任何操作。</p><ul><li>明白流操作的顺序的重要性</li></ul><p>在<code>Stream API</code>中，还包括一类<code>Short-circuiting</code>,它能够改变流中元素的数量，一般这类<code>API</code>如果是中间操作，最好写在靠前位置：</p><p>考虑下面两行代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> result1 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> result2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两段代码所使用的<code>API</code>都是相同的，但是由于顺序不同，带来的结果都非常不一样的，</p><p>第一段代码会先排序所有的元素，再依次打印一遍，最后获取前三个最小的放入<code>list</code>中,</p><p>第二段代码会先截取前3个元素，在对这三个元素排序，然后遍历打印，最后放<code>list</code>中。</p><ul><li>明白<code>Lambda</code>的局限性</li></ul><p>由于<code>Java</code>目前只能<code>Pass-by-value</code>，因此对于<code>Lambda</code>也和有匿名类一样的<code>final</code>的局限性。</p><p>因此我们无法再<code>lambda</code>表达式中修改外部元素的值。</p><p>同时，在<code>Stream</code>中，我们无法使用<code>break</code>提前返回。</p><ul><li>合理编排<code>Stream</code>的代码格式</li></ul><p>由于可能在使用流式编程的时候会处理很多的业务逻辑，导致API非常长，此时最后使用换行将各个操作分离开来，使得代码更加易读。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> result1 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时由于<code>Lambda</code>表达式省略了参数类型，因此对于变量，尽量使用完成的名词，比如<code>student</code>而不是<code>s</code>，增加代码的可读性。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>总之<code>，Stream</code>是Java 8 提供的简化代码的神器，合理使用它，能让你的代码更加优雅。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Streams </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不停服不修改代码条件下重建 Elasticsearch 索引</title>
      <link href="/2022/07/10/bu-ting-fu-bu-xiu-gai-dai-ma-tiao-jian-xia-chong-jian-elasticsearch-suo-yin/"/>
      <url>/2022/07/10/bu-ting-fu-bu-xiu-gai-dai-ma-tiao-jian-xia-chong-jian-elasticsearch-suo-yin/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/es.png"></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在某些情况下，重建索引不可避免。例如，如果我们需要更改任何现有的字段映射（mapping）或分析器（analyzer）。ES 是不允许直接更改的，因些需要重建一个与现有索引分开的新索引。</p><p>我们来分析下如何才能做到 <strong>不停服不修改代码</strong> 情况下重建索引？</p><h3 id="不停服"><a href="#不停服" class="headerlink" title="不停服"></a>不停服</h3><p>不能停服，那就要求新老索引在系统中能平稳过渡，需要在重建新索引时保持旧索引还在使用状态。因此，当旧索引仍然在使用的时候，我们不能将现有老索引名称用于新索引，必须得创建一个新的索引名称。</p><h3 id="不修改代码"><a href="#不修改代码" class="headerlink" title="不修改代码"></a>不修改代码</h3><p>要做到每次重建时不更新代码而使用新的索引名称，那就要求我们代码中不能直接使用索引名称进行搜索和索引文档。我们应该为索引创建一个别名，并在我们的搜索/索引代码中使用别名。然后在重建时更新ES中的别名以指向新索引。这样，我们访问索引的代码就不需要在每次重建索引时都更新发版。</p><h2 id="二、借助工具"><a href="#二、借助工具" class="headerlink" title="二、借助工具"></a>二、借助工具</h2><ul><li>cerebro</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cerebro.png"></p><ul><li>kibana</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/kibana.png"></p><p>cerebro 和 kinaba 都有控制台来输入执行命令，十分方便</p><h2 id="三、重建索引步骤"><a href="#三、重建索引步骤" class="headerlink" title="三、重建索引步骤"></a>三、重建索引步骤</h2><h3 id="在搜索和索引的代码中使用别名"><a href="#在搜索和索引的代码中使用别名" class="headerlink" title="在搜索和索引的代码中使用别名"></a>在搜索和索引的代码中使用别名</h3><ol><li>最终要使用重建的索引，原始的索引将被删除。如果你的代码中正在直接使用索引名，在重建前创建别名，更新代码。如果已经使用的是别名那可以跳过这一步。</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">POST /_aliases{  "actions": [    {      "add": {        "index": "current_index", // 原有索引        "alias": "alias1" // 服务的别名      }    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/es-alias.jpeg"></p><ol start="2"><li>记得查看 Elasticsearch 的 Disk Usage，如果不够，请先申请好足够的空间。<h3 id="创建新索引"><a href="#创建新索引" class="headerlink" title="创建新索引"></a>创建新索引</h3></li></ol><p>和创建普通索引一样创建新索引。这里值得一提的时，当数据量很大的时候，需要设置刷新时间间隔，在此期间写入的数据不能搜到，从而提高重建速度：<code>refresh_intervals = -1, number_of_replicas = 0</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">PUT /new_index{    "settings": {        "index": {            "number_of_replicas": "0",            "number_of_shards": "18"        }    },    "mappings": {        "properties": {}    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭自动刷新"><a href="#关闭自动刷新" class="headerlink" title="关闭自动刷新"></a>关闭自动刷新</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">PUT new_index/_settings{    "index" : {        "refresh_interval" : "-1"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ES 中刷新索引和写入磁盘是两个不同的过程。</p><p><strong>刷新索引</strong>：当一个文档被索引时，它被添加到内存缓冲区并附加到 translog 文件中。当刷新发生时，缓冲区中的文档被写入一个新的 segment，没有发生 fsync，该 segment 被打开以使其对搜索可见并清除缓冲区。 translog 尚未清除，实际上没有任何东西保存到磁盘（因为没有发生 fsync）。没有索引刷新，你不能搜索你的文档，段不是在缓存中创建的</p><p><strong>写入磁盘</strong>：默认情况下，当 translog 大小达到 512mb 或 30 分钟后。这实际上是将数据保存在磁盘上，其他所有内容都在文件系统缓存中（如果节点死亡或机器重新启动，缓存将丢失，translog 是唯一的救赎）</p><p>此处的refresh_interval指的是刷新（写入磁盘）的时间。</p><p>默认情况下 refresh_interval 设置为 1s。 实际上，这在 ES 中可以称为昂贵的操作，尤其是在索引时。通过将 refresh_interval 设置为 -1 意味着您正在禁用它，并且在索引 ES 时可以为您带来显著的性能提升。 您只需要禁用 refresh_interval （完成索引数据后再次启用它）</p><h3 id="数据迁移，把老索引数据迁移到新索引中"><a href="#数据迁移，把老索引数据迁移到新索引中" class="headerlink" title="数据迁移，把老索引数据迁移到新索引中"></a>数据迁移，把老索引数据迁移到新索引中</h3><p>使用 <code>reindex API</code> 就可以将数据 copy 到新索引中。这里几条路可以选：</p><ol><li><p>当只是改变 mapping 数据结构时，可以仅仅使用 reindex api 即可。例如：删除字段，更新字段分词方式等。</p></li><li><p>当需要写入新的字段，新的字段是由老的字段计算得到时，可以使用 script 参数。例如，计算某条数据某字段的总和。script 有很多坑，当 script 出错时，reindex 跑了很久之后失败，即使将数据恢复，也需要重新跑 reindex。</p></li><li><p>当含有很复杂的逻辑时，还是自己写程序吧。</p></li></ol><p>调用 reindex 接口，接口将会在 reindex 结束后返回，而接口返回超时只有30秒，如果 reindex 时间过长，建议加上wait_for_completion=false的参数条件，这样 reindex 将直接返回taskId</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">POST _reindex?wait_for_completion=false{  "source": {    "index": "current_index",    "size":5000  },  "dest": {    "index": "new_index"  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重建索引中"><a href="#重建索引中" class="headerlink" title="重建索引中"></a>重建索引中</h3><p>重建索引非常耗时，可以使用 <code>task API</code> 以看到重建进程，其中包含耗时，剩余doc数量等信息。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">GET _tasks/{taskID}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/es-task2.png"></p><p>如果发现错误，可以使用<code>PUT _tasks/{taskID}/cancel</code>接口放弃任务，从头再来。</p><h3 id="恢复自动刷新，恢复副本数"><a href="#恢复自动刷新，恢复副本数" class="headerlink" title="恢复自动刷新，恢复副本数"></a>恢复自动刷新，恢复副本数</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">PUT new_index/_settings{    "index" : {        "refresh_interval" : "1s",        "number_of_replicas" : "1"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="给新索引设置别名，它的名称为程序中使用的，解除老索引与别名的绑定"><a href="#给新索引设置别名，它的名称为程序中使用的，解除老索引与别名的绑定" class="headerlink" title="给新索引设置别名，它的名称为程序中使用的，解除老索引与别名的绑定"></a>给新索引设置别名，它的名称为程序中使用的，解除老索引与别名的绑定</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">POST /_aliases{    "actions": [        {            "add": {                "index": "new_index",                "alias": "alias1"            },            "remove": {                "index": "current_index",                "alias": "alias1"            }        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/es-new_index.jpeg"></p><h3 id="删除旧索引"><a href="#删除旧索引" class="headerlink" title="删除旧索引"></a>删除旧索引</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">DELETE current_index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除旧的 index，释放磁盘空间</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li><p>修改索引是一件费时费力的工作，特别是如果发生了错误，整个人都不好了。所以还是在创建索引的时候尽量想好能否满足需求</p></li><li><p>我们使用Kafka把Mysql中的数据同步到Elasticsearch中的，如果没有kafka，也要记录同步数据的时间，方便后面重新同步数据。无论使用哪种同步数据的方式，都需要记录同步数据的offset或时间。重建索引可能非常耗时，在这段时间内，同步进程仍然在向旧索引更新数据，此时重建索引是无法更新这些新数据的。</p></li></ul><h2 id="五-参考资料"><a href="#五-参考资料" class="headerlink" title="五. 参考资料"></a>五. 参考资料</h2><ul><li><a href="https://medium.com/craftsmenltd/rebuild-elasticsearch-index-without-downtime-168363829ea4">https://medium.com/craftsmenltd/rebuild-elasticsearch-index-without-downtime-168363829ea4</a></li><li><a href="https://stackoverflow.com/questions/36449506/what-exactly-does-1-refresh-interval-in-elasticsearch-mean">https://stackoverflow.com/questions/36449506/what-exactly-does-1-refresh-interval-in-elasticsearch-mean</a></li><li><a href="https://sematext.com/blog/elasticsearch-refresh-interval-vs-indexing-performance/">Elasticsearch 刷新间隔与索引性能</a></li><li><a href="https://juejin.cn/post/6844903605967781902">教你如何在 elasticsearch 中重建索引</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Lambda 表达式</title>
      <link href="/2022/06/26/java8-lambda-biao-da-shi/"/>
      <url>/2022/06/26/java8-lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/lambda.png"></p><p>Java 8 Lambda 表达式是一个匿名函数。匿名函数是指没有名字且不与任何类绑定的函数。</p><h2 id="二、为什么要使用-Lambda-表达式？"><a href="#二、为什么要使用-Lambda-表达式？" class="headerlink" title="二、为什么要使用 Lambda 表达式？"></a>二、为什么要使用 Lambda 表达式？</h2><p>使用 Lambda 表达式可以实现使用简洁的代码来创建函数式接口的实例，这样就避免了使用匿名内部类繁琐的写法。</p><p>下面我们将学习下Java 8 Lambda 表达式实现示例。</p><h2 id="三、Java-Lambda-表达式语法"><a href="#三、Java-Lambda-表达式语法" class="headerlink" title="三、Java Lambda 表达式语法"></a>三、Java Lambda 表达式语法</h2><p>Lambda 表达式非常简单，包含三个部分。形参列表、箭头运算符（-&gt;）和表达式（方法体）。</p><p><strong>语法 ：</strong> <code>(parameters) -&gt; { statements; }</code></p><p>与任何 java 函数一样，我们可以有任意数量的参数。我们还可以在方法体中包含任意数量的行或表达式。</p><p>例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 普通函数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 等效的Java Lambda表达式示例</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了更好地理解，让我们看一下 Runnable 类的真实示例。</p><p>在 java 8 之前，对于函数式接口的实现，我们要么使用实现类，要么使用匿名内部类。 但是在 lambda 之后，我们可以有另外的做法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在 java 8 之前，使用实现类来实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunnableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Runnable implementation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// usage：Runnable runnableObj = new RunnableImpl();</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在 java 8 之前，使用匿名类内部类来实现</span><span class="token class-name">Runnable</span> runnableObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Anonymous implementation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换成等效的 lambda 表达式的实现是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> runnableObj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Lambda implementation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于 Java lambda 表达式要知道的知识点：</p><ul><li>Java 8 lambda 表达式可以有零个、一个或<strong>多个参数</strong>。eg: <code>() -&gt; 10; a -&gt; a * a; (a, b) -&gt; a + b;</code></li><li>对于零个或多个参数，小括号是<strong>必须的</strong>。eg：<code>() -&gt; 10; (a, b) -&gt; a + b;</code></li><li>对于一个参数，小括号是<strong>可选的</strong>。eg：<code>a -&gt; a * a;</code></li><li>参数类型可以声明或由程序<strong>自动检测</strong>。eg：<code>(int a, int b) -&gt; a + b; OR (a, b) -&gt; a + b;</code></li><li>如果我们要声明参数类型，小括号是<strong>必须的</strong>。eg：<code>(int a) -&gt; a * a;</code></li><li>如果方法体只有一条语句，大括号是<strong>可选的</strong>。eg：<code>a -&gt; a * a; OR a -&gt; {return a * a;};</code></li><li>如果方法体只有一条语句，return关键字是<strong>可选的</strong>，Lambda表达式会自动返回这条语句的值。eg：<code>a -&gt; a * a; OR a -&gt; {return a * a;};</code></li><li>如果有返回值，我们添加了大括号，那么return关键字是<strong>必须的</strong>。eg：<code>a -&gt; {return a * a}</code></li><li>可以在 Lambda 表达式中使用<strong>方法级别或类级别的变量</strong>。</li><li>lambda 表达式中使用的局部变量必须是<strong>有效的最终变量</strong>。</li></ul><h2 id="四、Lambda-表达式与函数式接口"><a href="#四、Lambda-表达式与函数式接口" class="headerlink" title="四、Lambda 表达式与函数式接口"></a>四、Lambda 表达式与函数式接口</h2><p>Lambda 表达式的类型，也被称为“目标类型（target type）”，Lambda 表达式的目标类型必须是“函数式接口（funcitonal interface）”。函数式接口代表只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但只能声明一个抽象方法。</p><p>由于 Lambda 表达式的结果就是被当成对象，因此可以使用 Lambda 表达式进行赋值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Runnable 接口中只包含一个无参的方法</span><span class="token comment">// Lambda 表达式的匿名函数实现了Runnable接口中唯一的方法</span><span class="token comment">// 下面的 Lambda 表达式创建了一个 Runnable 对象</span><span class="token class-name">Runnable</span> runnableObj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lambda"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lambda 表达式有两个使用限制：</p><ul><li>Lambda 表达式的目标类型必须是<strong>明确的函数式接口</strong>。</li><li>Lambda 表达式只能为<strong>函数式接口创建对象</strong>。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译上面的代码会报 <code>Object 不是函数接口</code>的错误，这表明 Lambda 表达式的类型必须是明确的函数式接口，上面的代码将 Lambda 表达式赋值给 Object 变量，编译器只能确定该该 Lambda 表达式的类型为 Object，而 Object 并不是函数式接口，因此会报错。</p><p>通常有 3 种方式来保证Lambda表达式的目标类型是一个函数式接口</p><ul><li>赋值：将 Lambda 表达式赋值给函数式接口类型的变量。 </li><li>传参：将 Lambda 表达式作为函数式接口类型的参数传给某个方法。 </li><li>强制类型转换：使用函数式接口对 Lambda 表达式进行强制类型转换。</li></ul><h2 id="五、Lambda-表达式的方法引用与构造器引用及数组引用"><a href="#五、Lambda-表达式的方法引用与构造器引用及数组引用" class="headerlink" title="五、Lambda 表达式的方法引用与构造器引用及数组引用"></a>五、Lambda 表达式的方法引用与构造器引用及数组引用</h2><p>方法引用和构造器引用可以让 Lambda 表达式的代码块更加简洁。<code>方法引用和构造器引用都需要使用两个英文冒号</code>。</p><p>Lambda 表达式支持的方法引用和构造器引用如下：</p><table><thead><tr><th>引用方式</th><th>示例</th><th>说明</th><th>对应的Lambda表达式</th></tr></thead><tbody><tr><td>类方法引用</td><td>类名::静态方法名</td><td>调用时全部参数将传给该类方法作为参数</td><td>(a, b, c) -&gt; 类名.类方法(a, b, c)</td></tr><tr><td>实例方法引用</td><td>类名::实例方法名</td><td>第一个参数将作为调用者，剩下全部参数将传给该实例方法作为参数</td><td>(a, b, c) -&gt; a.实例方法(b, c)</td></tr><tr><td>引用特定对象的实例方法</td><td>对象::实例方法名</td><td>调用时全部参数将传给该实例方法作为参数</td><td>(a, b, c) -&gt; 特定对象.实例方法(a, b, c)</td></tr><tr><td>引用构造器</td><td>类名::new</td><td>调用时全部参数将传给该构造器作为参数</td><td>(a, b, c) -&gt; new 类名(a, b, c)</td></tr></tbody></table><h3 id="5-1-方法引用"><a href="#5-1-方法引用" class="headerlink" title="5.1 方法引用"></a>5.1 方法引用</h3><ul><li><p>使用场景：当 Lambda 体中的具体实现，已经有其他方法帮我们实现过了，那这时候我们就可以使用方法引用。</p></li><li><p>要求：需要保证引用方法的参数列表、返回值类型与我们当前所要实现的函数式接口方法的参数列表、返回值类型保持一致。</p></li><li><p>为什么要使用：方法引用是Lambda表达式的另外一种表现形式，是一个语法糖，使用方法引用可以少写一些代码，提高工作效率。</p></li></ul><h4 id="5-1-1-类名-静态方法名"><a href="#5-1-1-类名-静态方法名" class="headerlink" title="5.1.1 类名::静态方法名"></a>5.1.1 类名::静态方法名</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">interface</span> <span class="token class-name">Converter</span> <span class="token punctuation">{</span>    <span class="token class-name">Integer</span> <span class="token function">convert</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用Lambda表达式来创建一个Converter对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Converter</span> converter <span class="token operator">=</span> s <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面我们将使用<code>类方法引用</code>来代替上面的写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Converter</span> converter <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当调用 <code>converter.convert("10")</code> 时，调用参数会传给 Integer 类的 valueOf 类方法</p><h4 id="5-1-2-类名-实例方法名"><a href="#5-1-2-类名-实例方法名" class="headerlink" title="5.1.2 类名::实例方法名"></a>5.1.2 类名::实例方法名</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">interface</span> <span class="token class-name">MyStr</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用Lambda表达式来创建一个MyLambda对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">MyStr</span> ms <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token string">"lambda"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output：mb</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面我们将使用<code>实例方法引用</code>来代替上面的写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">MyStr</span> ms <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">substring</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token string">"lambda"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output：mb</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当调用<code>ms.substr("lambda", 2, 4))</code> substr 方法时，第一个调用参数(lambda)将作为实例方法 substring() 方法的调用者，剩下的全部调用参数(2,4)将作为 substring() 实例方法的实参。</p><p><strong>注意</strong>：这种方法引用的方式就不需要满足<code>保证引用方法的参数列表、返回值类型与我们当前所要实现的函数式接口方法的参数列表、返回值类型保持一致</code>这一规则</p><h4 id="5-1-3-对象-实例方法名"><a href="#5-1-3-对象-实例方法名" class="headerlink" title="5.1.3 对象::实例方法名"></a>5.1.3 对象::实例方法名</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用lambda表达式</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> con <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>con<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"zhang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: zhang</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们将使用<code>引用特定对象的实例方法</code>来代替上面的写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用方法引用</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> con2 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">;</span>con2<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"quan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: quan</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>，<code>这样写的前提: accept()方法和println()方法的参数列表和返回类型要完全一致</code>（有参无返回值）。 </p><p>当调用 out 对象的 println() 方法时，调用参数会全部传给 <strong>“out”对象的println()实例方法</strong></p><p>再举一个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用lambda表达式</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> sup <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sup<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: 0.7947699240208332</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用方法引用</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> sup1 <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token operator">::</span><span class="token function">random</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sup1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: 0.1991189968346606</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>，<code>这样写的前提: get()方法和random()方法的参数列表和返回类型要完全一致</code>（无参有返回值）。</p><h3 id="5-2-引用构造器"><a href="#5-2-引用构造器" class="headerlink" title="5.2 引用构造器"></a>5.2 引用构造器</h3><p>语法格式：<code>类::new</code>，调用哪个构造器取决于函数式接口中的方法形参的定义，Lambda 会自动根据接口方法推断出你要调用的构造器，也就是说需要调用的构造器的参数列表要与函数式接口中的抽象方法的参数列表保持一致</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span>                <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", age='"</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token class-name">String</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-1-无参构造器获取对象（Supplier）"><a href="#5-2-1-无参构造器获取对象（Supplier）" class="headerlink" title="5.2.1 无参构造器获取对象（Supplier）"></a>5.2.1 无参构造器获取对象（Supplier）</h4><p>使用Lambda表达式实现通过 User 的无参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> supplier1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user: "</span> <span class="token operator">+</span> supplier1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: user: User{id=null, name='null', age='null'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用Lambda构造器引用实现通过 User 的无参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> supplier2 <span class="token operator">=</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user: "</span> <span class="token operator">+</span> supplier2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: user: User{id=null, name='null', age='null'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-2-2-一个有参构造器获取对象（Function）"><a href="#5-2-2-一个有参构造器获取对象（Function）" class="headerlink" title="5.2.2  一个有参构造器获取对象（Function）"></a>5.2.2  一个有参构造器获取对象（Function）</h4><p>使用Lambda表达式实现通过 User 的 1 个有参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> function1 <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>function1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: User{id=1, name='null', age='null'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用Lambda构造器引用实现通过 User 的 1 个有参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> function2 <span class="token operator">=</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>function1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: User{id=1, name='null', age='null'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-2-3-二个有参构造器获取对象（BiFunction）"><a href="#5-2-3-二个有参构造器获取对象（BiFunction）" class="headerlink" title="5.2.3 二个有参构造器获取对象（BiFunction）"></a>5.2.3 二个有参构造器获取对象（BiFunction）</h4><p>使用Lambda表达式实现通过 User 的 2 个有参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> biFun1 <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>biFun1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: User{id=1, name='zhangquan', age='null'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用Lambda构造器引用实现通过 User 的 2 个有参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> biFun2 <span class="token operator">=</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>biFun2<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: User{id=1, name='zhangquan', age='null'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-2-4-三及以上个有参构造器获取对象（自定义函数式接口）"><a href="#5-2-4-三及以上个有参构造器获取对象（自定义函数式接口）" class="headerlink" title="5.2.4  三及以上个有参构造器获取对象（自定义函数式接口）"></a>5.2.4  三及以上个有参构造器获取对象（自定义函数式接口）</h4><p>首先自定义函数式接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyFun</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token class-name">S</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">R</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">F</span> f<span class="token punctuation">,</span> <span class="token class-name">S</span> s<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用Lambda表达式实现通过 User 的 3 个有参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">MyFun</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> myFun1 <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myFun1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"zhangquan"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: User{id=1, name='zhangquan', age='30'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用Lambda构造器引用实现通过 User 的 3 个有参构造器获取 User 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">MyFun</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> myFun2 <span class="token operator">=</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myFun2<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"zhangquan"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: User{id=1, name='zhangquan', age='30'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-3-数组引用"><a href="#5-3-数组引用" class="headerlink" title="5.3 数组引用"></a>5.3 数组引用</h3><p>可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p><blockquote><p>语法格式为：Type[]::new</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token operator">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> fun1 <span class="token operator">=</span>  <span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> fun1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Function</span><span class="token operator">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> fun2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> fun1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、Lambda-表达式-VS-匿名内部类"><a href="#六、Lambda-表达式-VS-匿名内部类" class="headerlink" title="六、Lambda 表达式 VS 匿名内部类"></a>六、Lambda 表达式 VS 匿名内部类</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>都可以直接访问 “effectively final”的局部变量（不需要加final关键字，但实际上是final，编译器编译时会自动加上），以及外部类的成员变量（包括实例变量和类变量）。</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li><p>匿名内部类可以为任意接口创建实例，不管接口包含多少个抽象方法，只要匿名内部类实现所有的抽象方法即可。但Lambda表达式只能为函数式接口创建实例。</p></li><li><p>匿名内部类可以为抽象类、甚至普通类创建实例。但Lambda表达式只能为函数式接口创建实例。</p></li><li><p>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法。但Lambda表达式的代码块不允许调用接口中定义的默认方法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中 Optional 类详解</title>
      <link href="/2022/06/19/java-zhong-optional-lei-xiang-jie/"/>
      <url>/2022/06/19/java-zhong-optional-lei-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/optional.png"></p><p>在 java.util 包下的 Java 8 版本中添加了 Optional类。它用作实际值的容器或包装器，实际值可能为空，也可能不为空。使用 Optional将有助于我们以更简洁的方式避免和处理空指针异常</p><h2 id="二、为什么要使用-Optional-？"><a href="#二、为什么要使用-Optional-？" class="headerlink" title="二、为什么要使用 Optional ？"></a>二、为什么要使用 Optional ？</h2><p>我们在开发时为了避免出现空指针，需要添加空检查，这可能会导致嵌套 if 语句，结果就是造成很丑陋的代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 处理 null 的传统方式</span><span class="token class-name">Double</span> balance <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>person <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Account</span> account <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>account <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        balance <span class="token operator">=</span> account<span class="token punctuation">.</span><span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用 Optional 来处理 null</span><span class="token class-name">Double</span> balance <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getAccount</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Account</span><span class="token operator">::</span><span class="token function">getBalance</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在某些场景下使用 Optional 能使我们的代码更加优雅简洁</p><h2 id="三、Java-8-中-Optional-类中的方法"><a href="#三、Java-8-中-Optional-类中的方法" class="headerlink" title="三、Java 8 中 Optional 类中的方法"></a>三、Java 8 中 Optional 类中的方法</h2><table><thead><tr><th>创建实例的方法</th><th>检查值的方法</th><th>获取值的方法</th><th>操作的方法</th></tr></thead><tbody><tr><td><code>empty()</code></td><td><code>isPresent()</code></td><td><code>get()</code></td><td><code>ifPresent(Consumer consumer)</code></td></tr><tr><td><code>of(T value)</code></td><td><code>filter(Predicate predicate)</code></td><td><code>orElse(T other)</code></td><td><code>map(Function mapper)</code></td></tr><tr><td><code>ofNullable(T value)</code></td><td></td><td><code>orElseGet(Supplier other)</code></td><td><code>flatMap(Function mapper)</code></td></tr><tr><td></td><td></td><td><code>orElseThrow(Supplier exception)</code></td><td></td></tr></tbody></table><h3 id="3-1-创建-Optional-对象的方法"><a href="#3-1-创建-Optional-对象的方法" class="headerlink" title="3.1 创建 Optional 对象的方法"></a>3.1 创建 Optional 对象的方法</h3><p>Optional 类具有私有构造函数，因此我们不能使用 new 关键字创建对象。此外，一旦创建我们就无法更改 Optional 中的值，因此我们需要在创建对象时提供值。</p><p>有 3 种方法可以创建 Optional 对象。 使用 Optional 类中提供的 3 种不同的静态方法</p><ul><li><code>empty()</code></li></ul><p>返回一个没有 <code>null</code> 值的 Optional 对象，该方法创建的对象始终为空</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> emptyOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>空的 Optional 对象用于表示空值。 在这个对象上我们可以执行一些操作而不会出现空指针异常</p><ul><li><code>of(T value) </code></li></ul><p>每当我们需要创建某个值的 Optional 时，我们可以使用 <code>Optional.of(value)</code> 来创建所需值的 Optional。<br>在此方法中，不允许使用 null 值。<br>如果我们尝试创建具有 null 值的对象，则会抛出 NullPointerException。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"zhangquan"</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// OK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在某些情况下，我们不确定该值是否存在。 在这种情况下，我们应该使用 <code>ofNullable(value)</code> 而不是 <code>of(value)</code> 来避免NullPoiterException</p><ul><li><code>ofNullable(T value) </code></li></ul><p>当我们需要创建某个值的 Optional 并且 value 可以为 null 时，我们应该使用 <code>Optional.ofNullabe(value)</code>。 这将创建所需值的 Optional，如果为 null，则为空。在此方法中，允许使用 null 值。如果我们尝试创建具有 null 值的对象，它将返回空 Optional。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"zhangquan"</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullabe</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// OK        </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullabe</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// OK        </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>创建实例的方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>empty()</code></td><td>-</td><td>创建一个空的Optional</td></tr><tr><td><code>of(T value)</code></td><td>要设置的值 - 不能为null</td><td>为非null的值创建一个Optional</td></tr><tr><td><code>ofNullable(T value)</code></td><td>要设置的值 - 可以为 null</td><td>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional</td></tr></tbody></table><h3 id="3-2-检查-Optional-对象中值的方法"><a href="#3-2-检查-Optional-对象中值的方法" class="headerlink" title="3.2 检查 Optional 对象中值的方法"></a>3.2 检查 Optional 对象中值的方法</h3><p>有时我们需要检查 Optional 是否包含期望值，我们可以通过 2 种方式检查 Optional 对象是否包含值</p><ul><li><code>isPresent()</code></li></ul><p>根据值是否存在返回 true 或 false</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> emptyOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>emptyOptional<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output : false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nameOptional<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output : true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></li></ul><p>此方法将<code>predicate</code>作为输入参数。 这里的<code>predicate</code>是针对 optional 对象检查的条件， 如果条件匹配，则返回带有值的 optional 对象，否则返回空的 optional 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span> output <span class="token operator">=</span> nameOptional<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>value <span class="token operator">-&gt;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output：Optional[zhangquan]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，我们尝试检查 optional 是否包含“zhangquan”。 因为它是匹配的，所以输出以“zhangquan”作为值的optional对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span> output <span class="token operator">=</span> nameOptional<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>value <span class="token operator">-&gt;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output：Optional.empty</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，我们尝试检查 optional 是否包含“java”值。 因为它是不匹配的，所以输出空的optional对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nameOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Optional</span> output <span class="token operator">=</span> nameOptional<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>value <span class="token operator">-&gt;</span> value<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output：Optional[zhangquan]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>检查值的方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>isPresent()</code></td><td>-</td><td>根据值是否存在返回true或false</td></tr><tr><td><code>filter(Predicate predicate)</code></td><td>Predicate接口</td><td>如果条件匹配，则返回带有值的 optional 对象，否则返回空的 optional 对象</td></tr></tbody></table><h3 id="3-3-获取-Optional-对象中值的方法"><a href="#3-3-获取-Optional-对象中值的方法" class="headerlink" title="3.3 获取 Optional 对象中值的方法"></a>3.3 获取 Optional 对象中值的方法</h3><p>根据需求和场景不同有 4 种方法可以访问 Optional 对象中的值</p><ul><li><code>get()</code></li></ul><p>如果值存在则返回值，如果为空则抛出 NoSuchElementException 异常，只有当我们确定该值存在并且它不是空的 optional 时，我们才应该在此 optional 对象上使用此方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Exception in thread "main" java.util.NoSuchElementException: No value present</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Output: Optional[zhangquan]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 optional 中的值可以为 null，那么我们可以使用其他方法，如 <code>orElse(...)</code> 来访问该值</p><ul><li><code>orElse(T other)</code> </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  Output: zhangquan</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与 get() 方法不同，如果为空 Optional，我们可以指定要返回的值，因此它不会抛出 NoSuchElementException。 这是从 optional 对象中访问值的最常见和最常用的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  Output: default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  Output: default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>orElseGet( Supplier&lt;? extends T&gt; other)</code></li></ul><p>如果值存在则返回该值，否则返回其它值，这个其它值是个函数式接口。</p><p>该方法与 <code>orElse(...)</code> 方法差别不大，只不过 optional 为空时执行函数式接口，返回该函数式接口返回的值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>  <span class="token class-name">String</span> <span class="token function">getDefaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"default"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> optional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">getDefaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Output</span> <span class="token operator">:</span> <span class="token keyword">default</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>orElseThrow(Supplier exceptionSupplier)</code></li></ul><p>如果值存在则返回该值，否则则抛出异常。我们可以使用这个方法来抛出自定义异常。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// before java 8</span><span class="token class-name">Data</span> date <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 我们需要检查的变量</span><span class="token keyword">if</span> <span class="token punctuation">(</span>date <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Date not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// if null throw exception</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> date<span class="token punctuation">;</span> <span class="token comment">// else return value from variable</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// using java 8</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Date</span><span class="token punctuation">&gt;</span></span> date <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">//  optional variable</span><span class="token keyword">return</span> date<span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Date not found"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-4-操作-Optional-对象中值的方法"><a href="#3-4-操作-Optional-对象中值的方法" class="headerlink" title="3.4 操作 Optional 对象中值的方法"></a>3.4 操作 Optional 对象中值的方法</h3><p>有 3 种方法可以对 Optional 对象中的值进行一些操作或者将值从一种形式转换为另一个形式</p><ul><li><code>ifPresent( Consumer&lt;? super T&gt; consumer)</code></li></ul><p>仅当值存在时才执行逻辑。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>向上面这种代码使用 Optional 我们可以非常简洁的处理这个问题</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span> optional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>optional<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>name <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Optional</span> optional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>optional<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>id <span class="token operator">-&gt;</span> userService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>map( Function&lt;? super  T,? extends U&gt; mapper)</code></li></ul><p>使用 <code>mapper</code> 函数中的指定逻辑将值从一个形式转换为另一种形式，如果值存在，则返回新值的 optional，如果值不存在，则返回空的 optional。需要注意的一点是<code>map()</code>将返回新的值并且不会修改原始的值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> person <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>person <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    name <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// using optional</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span>  person <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> name <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>OR<span class="token class-name">Optional</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> name <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>flatMap( Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</code></li></ul><p>与map() 几乎类似，不同之处在于map 将值转换为Optional 对象，而 flatMap 转换嵌套的Optional 对象<code>Optional&lt;Optional&gt;</code>。</p><p>Optional 值也可能是 Optional，因此这可能导致 <code>Optional&lt;Optional&gt;</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> optional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"zhangquan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Optional[com.zhangquan.java8.optional.User@5caf905d]</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getIdOptional</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Optional[Optional[1]]</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getIdOptional</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Optional[1]</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getIdOptional</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> idOptional<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>idOptional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">getIdOptional</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> idOptional<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIdOptional</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> idOptional<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>idOptional <span class="token operator">=</span> idOptional<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最需要注意的是 flat方法的 mapper 函数必须返回一个 Optional 对象。</p><h2 id="四、orElse-vs-orElseGet"><a href="#四、orElse-vs-orElseGet" class="headerlink" title="四、orElse vs orElseGet"></a>四、orElse vs orElseGet</h2><p>我们将讨论下 Optional 中的 orElse 与 orElseGet 它们的区别以及在什么时候应该使用哪种方法？</p><p><code>orElse</code> 方法需要一个值，而 <code>orElseGet </code>方法需要函数式接口，我们可以使用 <code>orElse(functionCall())</code> 代替 <code>orElseGet(Class::functionDef())</code>，它会得到相同的结果，那为什么还要创建两种不同的方法呢？</p><p>答案就是在某些情况下它们在性能方面有很大差异。</p><p>orElse 与 orElseGet  的区别</p><ul><li>如果 optional 为 null，我们将使用以下函数获取值</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElseVSorElseGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">orElseVSorElseGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> optional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> orElseGetResult <span class="token operator">=</span> optional<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">getFunctionForTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value in orElseGetResult "</span> <span class="token operator">+</span> orElseGetResult<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> orElseResult <span class="token operator">=</span> optional<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getFunctionForTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value in orElseResult "</span> <span class="token operator">+</span> orElseResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFunctionForTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n ===== function called ===== "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"default value"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Output: </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> ===== function called ===== value in orElseGetResult default value ===== function called ===== value in orElseResult default value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果 optional 中有值，我们将使用以下函数获取值</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElseVSorElseGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">orElseVSorElseGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> optional <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token string">"value found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> orElseGetResult <span class="token operator">=</span> optional<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">getFunctionForTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value in orElseGetResult "</span> <span class="token operator">+</span> orElseGetResult<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> orElseResult <span class="token operator">=</span> optional<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getFunctionForTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value in orElseResult "</span> <span class="token operator">+</span> orElseResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFunctionForTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n ===== function called ===== "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">"default value"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Output: </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">value in orElseGetResult value found ===== function called ===== value in orElseResult value found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们明确的知道 optional 对象中是有值的，所以我们期望 <code>orElse</code> 部分不应该被执行，然而它执行了。</p><p>因为上面 <code>getFunctionForTest</code> 方法很简单，没有多少性能的差异，但是当我们有复杂的逻辑来获取默认值时，它会影响性能，特别是需要查询数据库或者通过网络调用来获取默认值时，即使 optional 已经明确有值程序也会变慢。</p><blockquote><p>在 orElse 的情况下，即使 optional 有值，也会执行 else 部分，如果我们有默认的静态值，那么 orElse 是不错的选择。但如果默认值需要通过复杂的计算逻辑来获得，那么我们应该使用 orElseGet</p></blockquote><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li>5.1 在 java.util 包下的 Java 8 版本中添加。</li><li>5.2 Optional 类具有私有构造函数，因此我们不能使用 new 关键字创建对象。</li><li>5.3 Optional 表示具体某个值的 Optional 对象或空值，而不是 null 引用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中确定理想线程池的大小和Linux 查看CPU核数</title>
      <link href="/2022/06/15/java-zhong-que-ding-li-xiang-xian-cheng-chi-de-da-xiao-he-linux-cha-kan-cpu-he-shu/"/>
      <url>/2022/06/15/java-zhong-que-ding-li-xiang-xian-cheng-chi-de-da-xiao-he-linux-cha-kan-cpu-he-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在进行 java 编程时经常会遇到这样的问题：我的线程池应该设置为多少？</p><p>如果线程池设置的过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能会耗尽资源。如果线程池设置的过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐率。</p><p>下面我们就来聊一聊如果正确的设置线程池大小。</p><h2 id="二、Linux-查看CPU核数"><a href="#二、Linux-查看CPU核数" class="headerlink" title="二、Linux 查看CPU核数"></a>二、Linux 查看CPU核数</h2><p>我们知道 Linux/UNIX 中一切皆文档，硬件信息也记录在文件中。可以通过<code>cat /proc/cpuinfo</code> 查看CPU详细信息。</p><p>下面是cpuinfo的信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">processor       : 0vendor_id       : GenuineIntelcpu family      : 6model           : 85model name      : Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHzstepping        : 4microcode       : 0x1cpu MHz         : 2499.992cache size      : 33792 KBphysical id     : 0siblings        : 2core id         : 0cpu cores       : 1apicid          : 0initial apicid  : 0fpu             : yesfpu_exception   : yescpuid level     : 13wp              : yesflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 spec_ctrl intel_stibpbogomips        : 4999.98clflush size    : 64cache_alignment : 64address sizes   : 46 bits physical, 48 bits virtualpower management:processor       : 1vendor_id       : GenuineIntelcpu family      : 6model           : 85model name      : Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHzstepping        : 4microcode       : 0x1cpu MHz         : 2499.992cache size      : 33792 KBphysical id     : 0siblings        : 2core id         : 0cpu cores       : 1apicid          : 1initial apicid  : 1fpu             : yesfpu_exception   : yescpuid level     : 13wp              : yesflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 spec_ctrl intel_stibpbogomips        : 4999.98clflush size    : 64cache_alignment : 64address sizes   : 46 bits physical, 48 bits virtualpower management:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要字段含义如下：</p><ul><li>vendor_id：供应商ID，如果处理器是Intel处理器，会包含Intel字符串</li><li>processor：逻辑CPU的唯一标识符</li><li>core id：每个内核的唯一标识符</li><li>physical id：物理CPU的唯一标识符</li><li>cpu cores：同一个物理CPU的核心的个数</li><li>siblings：表示此物理CPU上可能支持或不支持超线程（HT）技术的逻辑CPU的数量（一个物理CPU有几个逻辑CPU）</li></ul><p>需要注意：</p><ol><li>如果多个逻辑处理器具有相同的核心ID （core id）和物理ID（physical id），则系统支持超线程（HT）技术</li><li>如果两个或多个逻辑CPU具有相同的物理id（physical id），但核心id（core id）不同，则这是一个多核处理器</li></ol><h3 id="2-1-查看物理CPU个数"><a href="#2-1-查看物理CPU个数" class="headerlink" title="2.1 查看物理CPU个数"></a>2.1 查看物理CPU个数</h3><p>物理计算机插槽上的CPU数量，也就是物理CPU的数量，可以统计非重复物理ID的数量，</p><p>查看方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">grep "physical id" /proc/cpuinfo | sort | uniq | wc -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-查看每个物理CPU中核心数"><a href="#2-2-查看每个物理CPU中核心数" class="headerlink" title="2.2 查看每个物理CPU中核心数"></a>2.2 查看每个物理CPU中核心数</h3><p>单个CPU可处理数据的芯片组数是CPU核心数，如双核、四核等。</p><p>查看方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat /proc/cpuinfo | grep "cpu cores" | uniq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-查看逻辑CPU的个数"><a href="#2-3-查看逻辑CPU的个数" class="headerlink" title="2.3 查看逻辑CPU的个数"></a>2.3 查看逻辑CPU的个数</h3><p>这个是我们的机器总的CPU的个数，也是<code>设置线程池大小的时候需要使用到的CPU的个数</code>。</p><p>注意　/proc/cpuinfo　文件中　<code>processor 0 – n</code> 并不一定是逻辑CPU的实际数量。</p><p>通常，一个CPU会有多个核心。英特尔公司的超线程技术（Hyper-Threading）在逻辑上可以将CPU核心的数量增加一倍，所以逻辑CPU个数应该这样算：</p><p>CPU不支持超线程：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">逻辑CPU个数 = 物理CPU个数 * 每个物理CPU中核心数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CPU支持超线程：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">逻辑CPU个数 = 物理CPU个数 * 每个物理CPU中核心数 * 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果多个逻辑CPU具有相同的核心ID（core id）和物理（physical id），则系统支持超线程（HT）技术。</p><p>查看方法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat /proc/cpuinfo | grep "processor" | wc -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、设置线程池大小"><a href="#三、设置线程池大小" class="headerlink" title="三、设置线程池大小"></a>三、设置线程池大小</h2><p>线程池称为工作线程池。工作线程是一个接受任务、完成任务并再次返回线程池以接受另一个任务的线程。</p><p>线程池的大小主要取决于以下两个因素：</p><h3 id="3-1-CPU核数（逻辑CPU的个数）"><a href="#3-1-CPU核数（逻辑CPU的个数）" class="headerlink" title="3.1 CPU核数（逻辑CPU的个数）"></a>3.1 CPU核数（逻辑CPU的个数）</h3><p>单核CPU将一次运行一个线程。如果是四核的，这意味着CPU中有四个核，而云或服务器的CPU中可能有多达个内核。</p><p>如果我们考虑超线程，那么单核CPU可以有多个处理器。</p><p>可以使用下面的 java 代码找到处理器的数量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> poolSize <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-任务类型"><a href="#3-2-任务类型" class="headerlink" title="3.2 任务类型"></a>3.2 任务类型</h3><p>有两种类型的任务：</p><ul><li>CPU密集型：涉及数学计算的任务</li><li>I/O密集型：通过网络调用（如数据库、web服务）与其他应用程序通信的阻塞任务</li></ul><h4 id="3-2-1-CPU密集型"><a href="#3-2-1-CPU密集型" class="headerlink" title="3.2.1 CPU密集型"></a>3.2.1 CPU密集型</h4><p>如果有一个CPU核心和一个线程正在运行，其中提交了两个任务。然后将一个任务提交给线程一，一旦完成，则提交另一个任务。提交两个任务之间不应有任何时间间隔，以实现CPU的最大利用率</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cpu-bound.png"></p><h4 id="3-2-2-I-O密集型"><a href="#3-2-2-I-O密集型" class="headerlink" title="3.2.2 I/O密集型"></a>3.2.2 I/O密集型</h4><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/io-bound.png"></p><p>通过网络调用与其他应用程序进行通信的任务，如web服务、数据库、外部缓存、微服务等。</p><p>在上图中，有1个线程，向其提交了1个任务。当此任务等待IO操作完成时，CPU将变为空闲状态。当IO调用返回响应时，它会再次开始工作，直到任务未完成。</p><p>在空闲时间内，我们可以再启动一个线程并使其运行，以实现CPU的最大利用率，并且线程1可以处于等待状态，直到从IO调用接收到输出。</p><p>因此，对于具有一个核心CPU的IO绑定任务，可以增加线程数，并获得CPU的最大利用率。</p><h2 id="四、计算线程数以实现CPU利用率最优的公式"><a href="#四、计算线程数以实现CPU利用率最优的公式" class="headerlink" title="四、计算线程数以实现CPU利用率最优的公式"></a>四、计算线程数以实现CPU利用率最优的公式</h2><p>在设置线程池大小时，需要设置为：</p><ul><li>CPU密集型：逻辑CPU的个数 + 1 </li></ul><p>$$<br>N_{cpu} + 1<br>$$</p><ul><li>I/O密集型：2 * 逻辑CPU的个数 + 1</li></ul><p>$$<br>2 * N_{cpu} + 1<br>$$</p><p>这里 <code>+1</code> 的意义何在？</p><p>《Java并发编程实践》这么说：</p><blockquote><p>计算密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p></blockquote><p>所以 <code>+1</code> 其实是一个经验值。</p><h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul><li><a href="https://zh.wikipedia.org/zh-cn/%E8%B6%85%E5%9F%B7%E8%A1%8C%E7%B7%92">超线程（HT, Hyper-Threading)</a></li><li><a href="https://book.douban.com/subject/10484692/">《Java并发编程实践》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，并发，线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能压测工具 wrk 使用指南</title>
      <link href="/2022/03/24/xing-neng-ya-ce-gong-ju-wrk-shi-yong-zhi-nan/"/>
      <url>/2022/03/24/xing-neng-ya-ce-gong-ju-wrk-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/wrk-0.png"></p><h2 id="一、什么是-wrk"><a href="#一、什么是-wrk" class="headerlink" title="一、什么是 wrk"></a>一、什么是 wrk</h2><p>wrk 是一个开源的、热门的、现代的单机 HTTP 基准测试工具，目前 GitHub 开源平台累计了 31.8k 的 star 数目，足以可见 wrk 在 HTTP 基准测试领域的热门程度。它结合了多线程设计和可扩展的事件通知系统，如 <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> 和 <a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a> ，可以在有限的资源下对目标机器产生大量的负载。并且内置了一个可选的 <a href="https://en.wikipedia.org/wiki/LuaJIT">LuaJIT</a> 脚本执行引擎，可以处理复杂的 HTTP 请求生成、响应处理以及自定义压测报告。</p><p>wrk项目地址：<a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a></p><h2 id="二、wrk-的优缺点"><a href="#二、wrk-的优缺点" class="headerlink" title="二、wrk 的优缺点"></a>二、wrk 的优缺点</h2><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><ul><li>轻量级性能测试工具</li><li>安装简单（相对 Apache ab 来说）</li><li>学习曲线基本为零，几分钟就能学会如何使用了</li><li>基于系统自带的高性能 I/O 机制，如 epoll, kqueue, 利用异步的事件驱动框架，通过很少的线程就可以压出很大的并发量</li></ul><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>wrk 目前仅支持单机压测，后续也不太可能支持多机器对目标机压测，因为它本身的定位，并不是用来取代 JMeter, LoadRunner 等专业的测试工具，wrk 提供的功能，对我们后端开发人员来说，应付日常接口性能验证还是比较友好的。</p><h2 id="三、安装-wrk"><a href="#三、安装-wrk" class="headerlink" title="三、安装 wrk"></a>三、安装 wrk</h2><h3 id="3-1-Linux-安装"><a href="#3-1-Linux-安装" class="headerlink" title="3.1 Linux 安装"></a>3.1 Linux 安装</h3><h4 id="3-1-1-Ubuntu-Debian"><a href="#3-1-1-Ubuntu-Debian" class="headerlink" title="3.1.1 Ubuntu/Debian"></a>3.1.1 Ubuntu/Debian</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ sudo apt-get install build-essential libssl-dev git -y$ git clone https://github.com/wg/wrk.git wrk$ cd wrk$ make# 将可执行文件移动到 /usr/local/bin 位置$ sudo cp wrk /usr/local/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-2-CentOS-RedHat-Fedora"><a href="#3-1-2-CentOS-RedHat-Fedora" class="headerlink" title="3.1.2 CentOS/RedHat/Fedora"></a>3.1.2 CentOS/RedHat/Fedora</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ sudo yum groupinstall 'Development Tools'$ sudo yum install -y openssl-devel git $ git clone https://github.com/wg/wrk.git wrk$ cd wrk$ make# 将可执行文件移动到 /usr/local/bin 位置$ sudo cp wrk /usr/local/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-MacOS-安装"><a href="#3-2-MacOS-安装" class="headerlink" title="3.2 MacOS 安装"></a>3.2 MacOS 安装</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew install wrk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="四、如何使用"><a href="#四、如何使用" class="headerlink" title="四、如何使用"></a>四、如何使用</h2><h3 id="4-1-基础使用"><a href="#4-1-基础使用" class="headerlink" title="4.1 基础使用"></a>4.1 基础使用</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ wrk -t12 -c400 -d30s http://www.zhangquan.me<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示，利用 wrk 对 <a href="http://www.zhangquan.me/">www.zhangquan.me</a> 发起压力测试，线程数为 12，模拟 400 个并发请求，持续 30 秒。</p><h3 id="4-2-wrk-参数说明"><a href="#4-2-wrk-参数说明" class="headerlink" title="4.2 wrk 参数说明"></a>4.2 wrk 参数说明</h3><p>除了上面简单示例中使用到的子命令参数，wrk 还有其他更丰富的功能，命令行中输入 wrk –help, 可以看到支持以下子命令：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/wrk-2.png"></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                              Options:                                                -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量      -d, --duration    &lt;T&gt;  压测时间               -t, --threads     &lt;N&gt;  使用多少个线程进行压测                                                             -s, --script      &lt;S&gt;  指定Lua脚本路径           -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头              --latency          在压测结束后，打印延迟直方图信息           --timeout     &lt;T&gt;  如果在此时间内没有收到响应，则记录超时        -v, --version          打印正在使用的wrk的详细版本信息                                                        &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-</code>开头的指令为简写的，后面两个打印延迟直方图和超时设置没有简写的，只能<code>--</code>开头指定</p><blockquote><p>PS: 关于线程数，并不是设置的越大，压测效果越好，线程设置过大，反而会导致线程切换过于频繁，效果降低，一般来说，推荐设置成压测机器 CPU 核心数的 2 倍到 4 倍就行了。</p></blockquote><p>MAC 查看 CPU 物理处理器数量和逻辑处理器数量</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">$ sysctl hw.physicalcpu hw.logicalcpuhw.physicalcpu: 8hw.logicalcpu: 16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-3-压测报告"><a href="#4-3-压测报告" class="headerlink" title="4.3 压测报告"></a>4.3 压测报告</h3><p>执行压测命令:</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">$ wrk -t12 -c400 -d30s --latency http://www.zhangquan.me  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成如下压测报告：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">Running 30s test @ http://www.zhangquan.me （运行30s测试）  12 threads and 400 connections （共12个测试线程，400个连接）                  Thread Stats   Avg（平均值）      Stdev（标准差）     Max (最大值)    +/- Stdev（正负一个标准差所占比例）    Latency (延迟）    79.18ms   24.43ms 737.24ms   97.75%    Req/Sec (每秒请求数)     423.57     38.26   530.00     87.14%  Latency Distribution (延迟直方图)     50%   76.95ms (50%请求延迟在76.95ms内)     75%   89.43ms (75%请求延迟在89.43ms内)     90%   95.05ms (90%请求延迟在95.05ms内)     99%  143.00ms (99%请求延迟在143.00ms内)  152148 requests in 30.09s, 94.74MB read (30.09s内处理了152148个请求，耗费流量94.74MB)Requests/sec:   5056.18 (QPS 5056.18,即平均每秒处理请求数为5056.18)Transfer/sec:      3.15MB (平均每秒流量3.15MB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>标准差啥意思？标准差如果太大说明样本本身离散程度比较高，有可能系统性能波动较大。</p></blockquote><h3 id="4-4-使用-Lua-脚本进行复杂测试"><a href="#4-4-使用-Lua-脚本进行复杂测试" class="headerlink" title="4.4 使用 Lua 脚本进行复杂测试"></a>4.4 使用 Lua 脚本进行复杂测试</h3><p>您可能有疑问了，你这种进行 GET 请求还凑合，我想进行 POST 请求咋办？而且我想每次的请求参数都不一样，用来模拟用户使用的实际场景，又要怎么弄呢？</p><p>对于这种需求，我们可以通过编写 Lua 脚本的方式，在运行压测命令时，通过参数 –script 来指定 Lua 脚本，来满足个性化需求。</p><h4 id="4-4-1-wrk-对-Lua-脚本的支持"><a href="#4-4-1-wrk-对-Lua-脚本的支持" class="headerlink" title="4.4.1 wrk 对 Lua 脚本的支持"></a>4.4.1 wrk 对 Lua 脚本的支持</h4><p>wrk 支持在三个阶段对压测进行个性化，分别是启动阶段、运行阶段和结束阶段。每个测试线程，都拥有独立的Lua 运行环境。</p><h5 id="启动阶段："><a href="#启动阶段：" class="headerlink" title="启动阶段："></a>启动阶段：</h5><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span>    thread<span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token string">"http://www.zhangquan.me"</span>            thread<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>          thread<span class="token punctuation">:</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"zq"</span><span class="token punctuation">)</span>     thread<span class="token punctuation">:</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在脚本文件中实现 setup 方法，wrk 就会在测试线程已经初始化，但还没有启动的时候调用该方法。wrk会为每一个测试线程调用一次 setup 方法，并传入代表测试线程的对象 thread 作为参数。setup 方法中可操作该 thread 对象，获取信息、存储信息、甚至关闭该线程。</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">thread<span class="token punctuation">.</span>addr             <span class="token operator">-</span> get <span class="token keyword">or</span> set the thread's server address <span class="token operator">#</span> 获取或设置请求的地址thread<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token operator">-</span> get the value of a global <span class="token keyword">in</span> the thread's env <span class="token operator">#</span> 获取全局变量的值thread<span class="token punctuation">:</span><span class="token function">set</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-</span> set the value of a global <span class="token keyword">in</span> the thread's  env <span class="token operator">#</span> 在线程的环境中设置全局变量的值thread<span class="token punctuation">:</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token operator">-</span> stop the thread <span class="token operator">#</span> 停止线程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="运行阶段："><a href="#运行阶段：" class="headerlink" title="运行阶段："></a>运行阶段：</h5><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>     <span class="token function">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token keyword">end</span><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> <span class="token number">10</span><span class="token keyword">end</span><span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    requests <span class="token operator">=</span> requests <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> wrk<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">end</span><span class="token keyword">function</span> <span class="token function">response</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> headers<span class="token punctuation">,</span> body<span class="token punctuation">)</span>    responses <span class="token operator">=</span> responses <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>init(args): <strong>初始化。</strong> 由测试线程调用，只会在进入运行阶段时，调用一次。支持从启动 wrk 的命令中，获取命令行参数；args为从命令行传过来的额外参数。</li><li>delay()： <strong>每次请求前设置延迟。</strong> 在每次发送请求之前调用，如果需要定制延迟时间，可以在这个方法中设置。</li><li>request():  <strong>发起请求。</strong>         每次请求执行一次，返回包含HTTP请求的字符串。每次构建新请求的开销都很大，在测试高性能服务器时，一种解决方案是在init()中预先生成所有请求，并在request()中进行快速查找。</li><li>response(status, headers, body): <strong>响应处理。</strong> 在每次收到一个响应时被调用，为提升性能，如果没有定义该方法，那么wrk不会解析 headers 和 body。</li></ul><h5 id="结束阶段："><a href="#结束阶段：" class="headerlink" title="结束阶段："></a>结束阶段：</h5><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">done</span><span class="token punctuation">(</span>summary<span class="token punctuation">,</span> latency<span class="token punctuation">,</span> requests<span class="token punctuation">)</span>    <span class="token keyword">for</span> index<span class="token punctuation">,</span> thread <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span> <span class="token keyword">do</span>        <span class="token keyword">local</span> id <span class="token operator">=</span> thread<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> requests <span class="token operator">=</span> thread<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"requests"</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> responses <span class="token operator">=</span> thread<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"responses"</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> msg <span class="token operator">=</span> <span class="token string">"thread %d made %d requests and got %d responses"</span>        <span class="token function">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">:</span><span class="token function">format</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> requests<span class="token punctuation">,</span> responses<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>请求完成。</strong> done() 方法在整个测试过程中只会被调用一次，我们可以从给定的参数中，获取压测结果，生成定制化的测试报告。done()函数接收一个包含结果数据的表和两个统计数据对象，分别表示每个请求延迟和每个线程请求速率。<br>持续时间和延迟是微秒值，速率是以每秒请求数来度量的。</p><h5 id="自定义-Lua-脚本中可访问的变量以及方法："><a href="#自定义-Lua-脚本中可访问的变量以及方法：" class="headerlink" title="自定义 Lua 脚本中可访问的变量以及方法："></a>自定义 Lua 脚本中可访问的变量以及方法：</h5><p>变量：wrk</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">wrk <span class="token operator">=</span> <span class="token punctuation">{</span>    scheme  <span class="token operator">=</span> <span class="token string">"http"</span><span class="token punctuation">,</span>    host    <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>    port    <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">,</span>    method  <span class="token operator">=</span> <span class="token string">"GET"</span><span class="token punctuation">,</span>    path    <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">,</span>    headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    body    <span class="token operator">=</span> <span class="token keyword">nil</span><span class="token punctuation">,</span>    thread  <span class="token operator">=</span> <span class="token operator">&lt;</span>userdata<span class="token operator">&gt;</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上定义了一个 table 类型的全局变量，修改该 wrk 变量，会影响所有请求。</p><p>方法：</p><ul><li>wrk.fomat</li><li>wrk.lookup</li><li>wrk.connect</li></ul><p>上面三个方法解释如下：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> path<span class="token punctuation">,</span> headers<span class="token punctuation">,</span> body<span class="token punctuation">)</span>    wrk<span class="token punctuation">.</span>format returns a HTTP request string containing the passed parameters    merged with values from the wrk table<span class="token punctuation">.</span>    <span class="token operator">#</span> 根据参数和全局变量 wrk，生成一个 HTTP rquest 字符串。获取域名的IP和端口，返回table，例如：返回 `<span class="token punctuation">{</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">80</span><span class="token punctuation">}</span>`<span class="token keyword">function</span> wrk<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> service<span class="token punctuation">)</span>    wrk<span class="token punctuation">.</span>lookup returns a table containing all known addresses <span class="token keyword">for</span> the host    <span class="token keyword">and</span> service pair<span class="token punctuation">.</span> This corresponds to the POSIX <span class="token function">getaddrinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">function</span><span class="token punctuation">.</span>    <span class="token operator">#</span> 给定 host 和 service（port<span class="token operator">/</span>well known service name），返回所有可用的服务器地址信息。<span class="token keyword">function</span> wrk<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span>    wrk<span class="token punctuation">.</span>connect returns <span class="token keyword">true</span> <span class="token keyword">if</span> the address can be connected to<span class="token punctuation">,</span> otherwise    it returns <span class="token keyword">false</span><span class="token punctuation">.</span> The address must be one returned from wrk<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>    <span class="token operator">#</span> 测试给定的服务器地址信息是否可以成功创建连接，例如：`<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">80</span>`，返回 <span class="token keyword">true</span> 或 <span class="token keyword">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-2-通过-Lua-脚本压测示例"><a href="#4-4-2-通过-Lua-脚本压测示例" class="headerlink" title="4.4.2 通过 Lua 脚本压测示例"></a>4.4.2 通过 Lua 脚本压测示例</h4><h5 id="调用-POST-接口："><a href="#调用-POST-接口：" class="headerlink" title="调用 POST 接口："></a>调用 POST 接口：</h5><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">wrk.method = "POST"wrk.body   = "id=1&amp;name=zq"wrk.headers["Content-Type"] = "application/x-www-form-urlencoded"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意: wrk 是个全局变量，这里对其做了修改，使得所有请求都使用 POST 的方式，并指定了 body 和 Content-Type头。</p><h5 id="自定义每次请求的参数："><a href="#自定义每次请求的参数：" class="headerlink" title="自定义每次请求的参数："></a>自定义每次请求的参数：</h5><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">request <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   uid <span class="token operator">=</span> math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span>   path <span class="token operator">=</span> <span class="token string">"/test?uid="</span> <span class="token operator">..</span> uid   <span class="token keyword">return</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 request 方法中，随机生成 1~10000000 之间的 uid，并动态生成请求 URL.</p><h5 id="每次请求前，延迟-10ms"><a href="#每次请求前，延迟-10ms" class="headerlink" title="每次请求前，延迟 10ms:"></a>每次请求前，延迟 10ms:</h5><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> <span class="token number">10</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="请求的接口需要先进行认证，获取-token-后，才能发起请求，咋办？"><a href="#请求的接口需要先进行认证，获取-token-后，才能发起请求，咋办？" class="headerlink" title="请求的接口需要先进行认证，获取 token 后，才能发起请求，咋办？"></a>请求的接口需要先进行认证，获取 token 后，才能发起请求，咋办？</h5><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">token <span class="token operator">=</span> <span class="token keyword">nil</span>path  <span class="token operator">=</span> <span class="token string">"/auth"</span>request <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token keyword">end</span>response <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> headers<span class="token punctuation">,</span> body<span class="token punctuation">)</span>   <span class="token keyword">if</span> <span class="token keyword">not</span> token <span class="token keyword">and</span> status <span class="token operator">==</span> <span class="token number">200</span> <span class="token keyword">then</span>      token <span class="token operator">=</span> headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span>      path  <span class="token operator">=</span> <span class="token string">"/test"</span>      wrk<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span> <span class="token operator">=</span> token   <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的脚本表示，在 token 为空的情况下，先请求 /auth 接口来认证，获取 token, 拿到 token 以后，将 token 放置到请求头中，再请求真正需要压测的 /test 接口。</p><h5 id="压测支持-HTTP-pipeline-的服务："><a href="#压测支持-HTTP-pipeline-的服务：" class="headerlink" title="压测支持 HTTP pipeline 的服务："></a>压测支持 HTTP pipeline 的服务：</h5><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">init <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>   <span class="token keyword">local</span> r <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">,</span> <span class="token string">"/?foo"</span><span class="token punctuation">)</span>   r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">,</span> <span class="token string">"/?bar"</span><span class="token punctuation">)</span>   r<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">,</span> <span class="token string">"/?baz"</span><span class="token punctuation">)</span>   req <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token keyword">end</span>request <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> req<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过在 init 方法中将三个 HTTP请求拼接在一起，实现每次发送三个请求，以使用 HTTP pipeline。</p><h4 id="4-4-3-通过-Lua-测试脚本案例分析"><a href="#4-4-3-通过-Lua-测试脚本案例分析" class="headerlink" title="4.4.3 通过 Lua 测试脚本案例分析"></a>4.4.3 通过 Lua 测试脚本案例分析</h4><p>案例：我们线上有一个带缓存场景的接口服务，根据 uid 的值的查询结果缓存，所以，如果单纯对指定的 uid 压测，就变成了测试缓存系统的负载了，测试不出实际的服务性能，这个场景就需要测试工具发起每次请求的测试参数都是动态的。根据这个场景我们定制了如下的 lua 测试脚本：</p><p>测试指令：</p><pre class="line-numbers language-none"><code class="language-none">wrk -t16 -c100 -d5s -sreview_digress_list.lua --latency htt://127.0.0.1:8081<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Lua 脚本：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">wrk<span class="token punctuation">.</span>method <span class="token operator">=</span><span class="token string">"GET"</span>wrk<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token string">"/app/{uid}/review_digress_list"</span><span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">-- 动态生成每个请求的url</span>    <span class="token keyword">local</span> requestPath <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">gsub</span><span class="token punctuation">(</span>wrk<span class="token punctuation">.</span>path<span class="token punctuation">,</span><span class="token string">"{uid}"</span><span class="token punctuation">,</span>math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">-- 返回请求的完整字符串：http://127.0.0.1/app/666/review_digress_list</span>    <span class="token keyword">return</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">,</span> requestPath<span class="token punctuation">)</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux，分布式，架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MacOS系统上编译OpenJDK12并使用CLion调试</title>
      <link href="/2022/03/01/zai-macos-xi-tong-shang-bian-yi-openjdk12-bing-shi-yong-clion-diao-shi/"/>
      <url>/2022/03/01/zai-macos-xi-tong-shang-bian-yi-openjdk12-bing-shi-yong-clion-diao-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MAC-环境"><a href="#1-MAC-环境" class="headerlink" title="1. MAC 环境"></a>1. MAC 环境</h2><p>macOS Catalina 版本 10.15.6</p><h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h2><h3 id="2-1-获取源码"><a href="#2-1-获取源码" class="headerlink" title="2.1 获取源码"></a>2.1 获取源码</h3><p>直接通过页面下载 <a href="https://hg.openjdk.java.net/jdk/jdk12/">OpenJdk12源码压缩包</a> ，然后点击左边菜单中的 “Browse”，将显示如图的源码根目录页面。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/openjdk-12-source-code.png" alt="openjdk12-source-code.png"></p><p>此时点击左边的 “zip” 链接即可下载打包好的源码。</p><h3 id="2-2-Bootstrap-JDK"><a href="#2-2-Bootstrap-JDK" class="headerlink" title="2.2 Bootstrap JDK"></a>2.2 Bootstrap JDK</h3><p>因为OpenJDK的各个组成部分有的是使用C++编写的,有的是使用Java编写的，因此编译这些Java代码需要使用到一个可用的JDK，官方称这个JDK为“Bootstrap JDK”，一般来说只需要比编译的JDK低一个版本，这里采用OpenJDK11，可以通过这个网址 jdk.java.net/archive/ 下载<br>记住一定要下载一个适合Mac平台的OpenJDK11。</p><p>1）<a href="https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_osx-x64_bin.tar.gz">下载 JDK 11</a></p><p>2）解压安装包</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ sudo tar -zxf /Users/zhangquan/Downloads/openjdk-11.0.2_osx-x64_bin.tar.gz -C /Library/Java/JavaVirtualMachines/ <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3）使用 jenv add 命令将 JDK 11 加入  jenv 中</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ jenv add /Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我使用的Bootstrap JDK版本如下</p><pre class="line-numbers language-none"><code class="language-none">$ java -versionopenjdk version "11.0.2" 2019-01-15OpenJDK Runtime Environment 18.9 (build 11.0.2+9)OpenJDK 64-Bit Server VM 18.9 (build 11.0.2+9, mixed mode)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3. 安装依赖"></a>3. 安装依赖</h2><p>用于生成shell脚本的工具,可以使软件包在不同的系统下都可以编译</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ brew install autoconf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字体引擎</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ brew install freetype<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-1-XCode-和-Command-Line-Tools-for-Xcode"><a href="#3-1-XCode-和-Command-Line-Tools-for-Xcode" class="headerlink" title="3.1 XCode 和 Command Line Tools for Xcode"></a>3.1 XCode 和 Command Line Tools for Xcode</h3><p>这两个SDK提供了OpenJDK所需的编译器以及Makefile中用到的外部命令。一般电脑上都自带安装了。</p><p>验证 Xcode Command Line Tools 安装成功</p><pre class="line-numbers language-none"><code class="language-none">$ xcode-select -p /Library/Developer/CommandLineTools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Xcode 各版本下载地址<br><a href="https://xcodereleases.com/">https://xcodereleases.com/</a></p><p> Catalina 上运行的最新版本的 Xcode 是 Xcode 12.4 和命令行工具 12.4。</p><h2 id="4-编译jdk"><a href="#4-编译jdk" class="headerlink" title="4. 编译jdk"></a>4. 编译jdk</h2><p>源码下载好之后，我解压放到了 <code> /Users/zhangquan/jvm/jdk12-06222165c35f</code> 这个目录下，下面的命令均是在这个目录下执行的。</p><p>使用以下命令来查看编译参数帮助说明</p><pre class="line-numbers language-none"><code class="language-none">$ bash configure --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令进行编译检查</p><pre class="line-numbers language-none"><code class="language-none">bash configure \--with-boot-jdk='/Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home' \--with-debug-level=slowdebug \--with-target-bits=64 \--disable-warnings-as-errors \--enable-dtrace \--with-jvm-variants=server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>–with-boot-jdk：指定Bootstrap JDK路径</li><li>–with-debug-level：编译级别,可选值为release、fastdebug、slowdebug和optimized,默认值为release,如果我们要调试的话,需要设定为fastdebug或者slowdebug,建议设置为slowdebug</li><li>–with-target-bits：指定编译32位还是64位的虚拟机</li><li>–disable-warnings-as-errors：避免因为警告而导致编译过程中断</li><li>–enable-dtrace：开启一个性能工具</li><li>–with-jvm-variants：编译特定模式下的虚拟机,一般这里编译server模式</li><li>–with-conf-name：指定编译配置的名称,如果没有指定,则会生成默认的配置名称macosx-x86_64-server-slowdebug,我这里采用默认生成配置</li></ul><p>报错</p><pre class="line-numbers language-none"><code class="language-none">configure: error: No xcodebuild tool and no system framework headers found, use --with-sysroot or --with-sdk-name to provide a path to a valid SDK<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行</p><pre class="line-numbers language-none"><code class="language-none">$ sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继续执行 bash configure 得到如下配置成功的提示，并且输出调试级别，Java 虚拟机的模式、特性，使用的编译器版本等配置信息。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/buid-success.png" alt="buid-success.pn"></p><h3 id="4-1-开始编译"><a href="#4-1-开始编译" class="headerlink" title="4.1  开始编译"></a>4.1  开始编译</h3><pre class="line-numbers language-none"><code class="language-none">$ make images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里 “images” 是 “product-images” 编译目标（Target）的简写，这个目标的作用是编译出整个 JDK镜像，除了 “product-images”外，其他编译目标还有</p><ul><li>hotspot：只编译HotSpot虚拟机 </li><li>hotspot-<variant>：只编译特定模式的 HotSpot 虚拟机</variant></li><li>docs-image：产生 JDK 的文档镜像</li><li>test-image：产生 JDK 的测试镜像</li><li>all-images：相当于连续调用 product、docs、test 三个编译目标</li><li>bootcycle-images：编译两次 JDK，其中第二次使用第一次编译结果作为 Bootstrap JDK</li><li>clean：清理 make 命令产生的临时文件</li><li>dist-clean：清理make 和 configure 命令产生的临时文件</li></ul><p>在 configure 命令以及 make images 命令的执行过程 中，会在 “build/macosx-x86_64-server-slowdebug”目录 下产生如下目录结构</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">├── Makefile├── bootcycle-spec.gmk├── build.log├── buildjdk-spec.gmk├── buildtools  用于生成、存放编译过程中用到的工具├── compare.sh├── configure-support├── configure.log├── hotspot  HotSpot虚拟机编译的中间文件├── images 使用 make *-image 产生的镜像存放在这里├── jdk  编译后产生的 JDK 就放在这里├── make-support ├── spec.gmk└── support 存放编译时产生的中间文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译完成之后，进入 OpenJDK 源码的 “build/配置名称/jdk” 目录下就可以看到 OpenJDK 的完整编译结果了</p><p>验证编译成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ /Users/zhangquan/jvm/jdk12-06222165c35f/jdk12-06222165c35f/build/macosx-x86_64-server-slowdebug/jdk/bin/java -versionopenjdk version "12-internal" 2019-03-19OpenJDK Runtime Environment (slowdebug build 12-internal+0-adhoc.zhangquan.jdk12-06222165c35f)OpenJDK 64-Bit Server VM (slowdebug build 12-internal+0-adhoc.zhangquan.jdk12-06222165c35f, mixed mode)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-生成Compilation-Database"><a href="#4-2-生成Compilation-Database" class="headerlink" title="4.2 生成Compilation Database"></a>4.2 生成Compilation Database</h3><p>在配置CLion的时候,直接import编译好之后的jdk源码,你会发现头文件都是红色的,无法找到提示,是因为CLion生产的CMakeLists.txt有问题,如果想要解决这个问题就需要修改这个文件,很明显我不会修。<br>最后通过JetBrains说的利用Compilation Database (blog.jetbrains.com/clion/2020/…) 在CLion中构建OpenJDK解决了这个问题。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ make CONF=macosx-x86_64-server-slowdebug compile-commandsBuilding target 'compile-commands' in configuration 'macosx-x86_64-server-slowdebug'Updating compile_commands.jsonFinished building target 'compile-commands' in configuration 'macosx-x86_64-server-slowdebug'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行完该命令,就会在${source_root}/build/macosx-x86_64-server-slowdebug下生成compile_commands.json文件。</p><h2 id="5-Clion-导入源码"><a href="#5-Clion-导入源码" class="headerlink" title="5. Clion 导入源码"></a>5. Clion 导入源码</h2><h3 id="5-1-导入-project"><a href="#5-1-导入-project" class="headerlink" title="5.1 导入 project"></a>5.1 导入 project</h3><p>在导入project 之前先配置好 Toolchains</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/Toolchanis.png" alt="Toolchains"></p><p>配置好 Toolchains 后，通过 File -&gt; Open 功能，选中 ${source_root}/build/macosx-x86_64-server-slowdebug/compile_commands.json,As a project 打开，这样就导入了 Compilation Database 文件，接下来 CLion 开始进行索引。</p><p>这时候，你会发现你是看不到源码的，所以下面需要修改项目的根目录，通过 Tools -&gt; Compilation Database -&gt; Change Project Root 功能，选中你的源码目录，也就是 ${source_root}, 这样设置就可以在 CLion 中看到源代码啦。</p><pre class="line-numbers language-none"><code class="language-none">${source_root} 指的是 ~/jvm/jdk12-06222165c35f/jdk12-06222165c35f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-debug-之前配置"><a href="#5-2-debug-之前配置" class="headerlink" title="5.2 debug 之前配置"></a>5.2 debug 之前配置</h3><p>需要在 <code>Preferences --&gt; Build, Exceution, Deployment --&gt; Custom Build Targets</code> 配置构建目标</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/make.png" alt="make"></p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/clean.png" alt="clean"></p><p>通过这两个配置每次构建之前都会重新编译我们的 jdk, 修改 jvm 代码之后可以直接进行重新调试。</p><h3 id="5-3-debug-配置"><a href="#5-3-debug-配置" class="headerlink" title="5.3 debug 配置"></a>5.3 debug 配置</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/debug_config.png" alt="debug_config"></p><p>Executable：选择 ${source_root}/build/macosx-x86_64-server-slowdebug/jdk/bin/java, 或者其它你想调试的文件，比如 javac；<br>Before luanch：这个下面新增的时候有一个 bug, 去掉就不会每次执行都去 Build, 节省时间，但其实 OpenJDK 增量编译的方式，每次 Build 都很快，所以就看个人选择了。</p><h3 id="5-4-debug"><a href="#5-4-debug" class="headerlink" title="5.4 debug"></a>5.4 debug</h3><p>在 <code>${source_root}/src/java.base/share/native/libjli/java.c</code>的 401 行打断点，点击 Debug, 然后 F9 放掉，</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/debug1.png" alt="debug1"></p><p>不出意外你会遇到下面这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/debug2.png" alt="debug2"></p><p>由于我们使用的 LLDB 进行 debug 的，所以在进入第一个断点的时候在 LLDB 下执行以下命令可以避免此类问题</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pro hand -p true -s false SIGSEGV SIGBUS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/debug3.png" alt="debug3"></p><p>最终就可以看到 java -version 的输出效果如下<br><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/debug4.png" alt="debug4"></p><p>不过每次 debug 的时候都要输入这么一句就很麻烦，所以我们可以在 <strong>~/.lldbinit</strong> 文件中，使用如下命令，实现每次 Debug 时自动打个断点，然后输入 pro hand -p true -s false SIGSEGV SIGBUS, 最后继续执行后续流程，文件内容如下 (其中 main.c 文件的路径自行替换)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">breakpoint set --file /Users/zhangquan/jvm/jdk12-06222165c35f/jdk12-06222165c35f/src/java.base/share/native/launcher/main.c --line 98 -C "pro hand -p true -s false SIGSEGV SIGBUS" --auto-continue true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-5-与-Java-程序联合-debug"><a href="#5-5-与-Java-程序联合-debug" class="headerlink" title="5.5 与 Java 程序联合 debug"></a>5.5 与 Java 程序联合 debug</h3><p>上面演示的实际是 java -version 如何 debug, 那么如何做到通过自己编写的 java 代码作为程序入口来调试呢？</p><p>首先 java 代码如下 (我用 idea 编写的):</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/main.png" alt="main"></p><p>CLion 中配置如下</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/main2.png" alt="main2"></p><p>运行结果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/main3.png" alt="main3"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>&lt;&lt;深入理解 Java 虚拟机：JVM 高级特性与最佳实践&gt;&gt;</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中对链表的简单操作</title>
      <link href="/2021/12/09/c-yu-yan-zhong-dui-lian-biao-de-jian-dan-cao-zuo/"/>
      <url>/2021/12/09/c-yu-yan-zhong-dui-lian-biao-de-jian-dan-cao-zuo/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h3><p>链表（linked list）就是一个或多个节点的集合。链表中的每个节点通过指针连接在一起。程序通过指针访问链表中的节点。</p><h3 id="二、单链表"><a href="#二、单链表" class="headerlink" title="二、单链表"></a>二、单链表</h3><p>在单链表中，每个节点包含一个指向链表下一个节点的指针。链表的最后一个节点的指针字段值为<code>NULL</code>，表示链表后面不再有其他节点。</p><p>在你找到链表的第1个节点后，指针就可以带你访问剩余所有节点。为了记住链表的起始位置，可以使用一个根指针（root pointer）。根指针指向链表的第一个节点。</p><h3 id="三、单链表操作"><a href="#三、单链表操作" class="headerlink" title="三、单链表操作"></a>三、单链表操作</h3><p>以下所有例子中的节点的类型定义我们放在<strong>node.h</strong>，内容如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_NODE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_NODE_H</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">NODE</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">NODE</span> <span class="token operator">*</span>link<span class="token punctuation">;</span>        <span class="token keyword">int</span>             value<span class="token punctuation">;</span><span class="token punctuation">}</span> Node<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* _NODE_H */</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="向单链表表头插入节点"><a href="#向单链表表头插入节点" class="headerlink" title="向单链表表头插入节点"></a>向单链表表头插入节点</h4><p>我们简单的实现一个向链表表头插入节点的程序</p><p>例子：node.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"node.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/* 定义两个指向节点的指针变量 */</span>Node <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* 指向第一个节点的根指针 */</span>Node <span class="token operator">*</span>new<span class="token punctuation">;</span><span class="token comment">/* 指向动态分配内存的节点指针 */</span><span class="token comment">/* 动态分配内存，创建新结点 */</span>new <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>new <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 给新结点成员 value 赋值 */</span>new<span class="token operator">-&gt;</span>value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">/* 我们只是简单地向链表表头插入新节点 */</span>new<span class="token operator">-&gt;</span>link <span class="token operator">=</span> root<span class="token punctuation">;</span>root <span class="token operator">=</span> new<span class="token punctuation">;</span><span class="token comment">/* 再插入一个节点 */</span>new <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>new <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>new<span class="token operator">-&gt;</span>value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>new<span class="token operator">-&gt;</span>link <span class="token operator">=</span> root<span class="token punctuation">;</span>root <span class="token operator">=</span> new<span class="token punctuation">;</span><span class="token comment">/* 遍历链表 */</span>Node <span class="token operator">*</span>current <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@192 list]$ ./node105<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>向链表中插入节点这种操作是经常被使用的，我们把上述步骤封装成一个函数</p><p>例子：node2.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"node.h"</span></span><span class="token keyword">static</span> Node <span class="token operator">*</span><span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pr_list</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>Node <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* 指向第一个节点的根指针 */</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pr_list</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 向链表的表头插入节点 * * 第一个参数是指向链表首节点的指针 * 第二个参数是新节点中 value 成员的值 * 如果插入成功返回指向新链表首节点的指针 */</span><span class="token keyword">static</span> Node <span class="token operator">*</span><span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>Node <span class="token operator">*</span>new<span class="token punctuation">;</span>new <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>new <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc failed in insert.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>new<span class="token operator">-&gt;</span>value <span class="token operator">=</span> n<span class="token punctuation">;</span>new<span class="token operator">-&gt;</span>link <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">return</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 遍历链表 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pr_list</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>current<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@192 list]$ ./node215105<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="从单链表中删除一个节点"><a href="#从单链表中删除一个节点" class="headerlink" title="从单链表中删除一个节点"></a>从单链表中删除一个节点</h4><p>我们简单的实现一个指定一个 <code>value</code>值，从链表中删除第一个包含该值的节点，返回删除后的新链表</p><p>例子：node3.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"node.h"</span></span><span class="token keyword">static</span> Node <span class="token operator">*</span><span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pr_list</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> Node <span class="token operator">*</span><span class="token function">delete</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>Node <span class="token operator">*</span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* 指向第一个节点的根指针 */</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pr_list</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 向链表的表头插入节点 * * 第一个参数是指向链表首节点的指针 * 第二个参数是新节点中 value 成员的值 * 如果插入成功返回指向新链表首节点的指针 */</span><span class="token keyword">static</span> Node <span class="token operator">*</span><span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>Node <span class="token operator">*</span>new<span class="token punctuation">;</span>new <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>new <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc failed in insert.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>new<span class="token operator">-&gt;</span>value <span class="token operator">=</span> n<span class="token punctuation">;</span>new<span class="token operator">-&gt;</span>link <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">return</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 遍历链表 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pr_list</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>current<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 指定一个 n 值，从链表中删除第一个包含该值的节点，返回删除后的新链表 */</span><span class="token keyword">static</span> Node <span class="token operator">*</span><span class="token function">delete</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>Node <span class="token operator">*</span>current<span class="token punctuation">,</span> <span class="token operator">*</span>previous<span class="token punctuation">;</span>current <span class="token operator">=</span> root<span class="token punctuation">;</span>previous <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> current<span class="token operator">-&gt;</span>value <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>previous <span class="token operator">=</span> current<span class="token punctuation">;</span>current <span class="token operator">=</span> current<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 链表中没有一个节点的 value 值等于n */</span><span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>previous <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 链表中第一个节点的 value值就等于n */</span>root <span class="token operator">=</span> current<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">/* 其它位置找到了这样的节点 */</span>previous<span class="token operator">-&gt;</span>link <span class="token operator">=</span> current<span class="token operator">-&gt;</span>link<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">free</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@192 list]$ ./node3             155<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中字符串处理函数</title>
      <link href="/2021/12/09/c-yu-yan-zhong-zi-fu-chuan-chu-li-han-shu/"/>
      <url>/2021/12/09/c-yu-yan-zhong-zi-fu-chuan-chu-li-han-shu/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、字符串基础"><a href="#一、字符串基础" class="headerlink" title="一、字符串基础"></a>一、字符串基础</h2><ul><li>字符串可以当作以<strong>空字符</strong>结尾的字符数组。</li></ul><p>空字符：一个所有位都为0的字节，因此用转义序列<code>\0</code>来表示。注意不要混淆空字符<code>'\0'</code>和零字符<code>'0'</code>。空字符的<code>ASCII</code>值为<code>0</code>，而零字符的码值为<code>48</code>。</p><ul><li>字符串长度就是它所包含的字符个数但不包括<strong>空字符</strong></li><li>字符串常量是用一对引号括起来的字符序列，在程序执行过程中保持不变的数据</li><li>字符串变量可以在程序运行过程中发生改变</li></ul><h2 id="二、字符串处理函数"><a href="#二、字符串处理函数" class="headerlink" title="二、字符串处理函数"></a>二、字符串处理函数</h2><h3 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h3><p>库函数<code>strlen</code>的原型如下：</p><p><code>size_t strlen(const char *s);</code></p><p>注意strlen返回一个类型为size_t的值，这个类型是一个无符号整数类型。在表达式中使用无符号数可能导致不可预料的结果。例如，下面两个表达式看上去是相等的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">strlen</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但事实上它们是不相等的。第一条语句将按照预想的那样工作，但第2条语句的结果将永远是真值。strlen的结果是个无符号数，所以操作符<code>&gt;=</code>左边的表达式也将是无符号数，而无符号数绝不可能是负的。</p><h3 id="不受限制的字符串函数"><a href="#不受限制的字符串函数" class="headerlink" title="不受限制的字符串函数"></a>不受限制的字符串函数</h3><ul><li>复制字符串</li></ul><p><code> char *strcpy(char *dest, const char *src);</code></p><p>这个函数把参数src字符串复制到dest参数。如果参数src和dest在内在中出现重叠，其结果是未定义的。由于dst参数将进行修改，所以它必须是个字符数组或一个指向动态分配内存的数组的指针，<strong>不能使用字符串常量</strong>。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"Original message"</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"Different"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"message = %s\n"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">message = Different<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组<code>message</code>将包含下面的内容</p><pre class="line-numbers language-none"><code class="language-none">char message[] = {'D', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', '\0', 'e', 's', 's', 'a', 'g', 'e', '\0'};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个<strong>空字符</strong>后面的几个字符再也无法被字符串函数访问，从现实的角度看，它们已经是丢失的了。</p><ul><li>连接字符串</li></ul><p><code> char *strcat(char *dest, const char *src);</code></p><p>要想把一个字符串添加（连接）到另一个字符串后面，可以使用<code>strcat</code>函数。</p><p>函数<code>strcat</code>要求<code>dest</code>参数原先已经包含一个空字符（可以是空字符串）。它找到这个字符串的未尾，并把<code>src</code>字符串的一份拷贝添加到这个位置。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"hello "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"message = %s\n"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">message <span class="token operator">=</span> hello string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>比较字符串</li></ul><p><code>int strcmp(const char *s1, const char *s2);</code></p><p>比较两个字符串时涉及对两个字符串对应的字符逐个比较，直到发现不匹配为止。采用的是<strong>字典比较</strong>，如果<code>s1</code>小于<code>s2</code>，返回一个小于零的值。如果<code>s1</code> 大于<code>s2</code>，返回一个大于零的值，如果两个字符串相等，返回零。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种写法是错误的，如果想要比较两个字符串相等，应该把返回值与零进行比较。</p><h3 id="长度受限的字符串函数"><a href="#长度受限的字符串函数" class="headerlink" title="长度受限的字符串函数"></a>长度受限的字符串函数</h3><pre class="line-numbers language-none"><code class="language-none">char *strncpy(char *dest, const char *src, size_t n);char *strncat(char *dest, const char *src, size_t n);int strncmp(const char *s1, const char *s2, size_t n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这些函接受一个显式的长度参数，用于限定进行复制或连接或比较的字符数。这些函数提供了一种方便的机制，可以防止难以预料的长字符串从它们的目标数组溢出。</p><h3 id="字符串查找函数"><a href="#字符串查找函数" class="headerlink" title="字符串查找函数"></a>字符串查找函数</h3><ul><li>查找一个字符</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strchr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数<code>strchr</code>在字符串s中查找字符c第1次出现的位置，找到后函数返回一个指向该位置的指针。如果该字符并不存在字符串中，函数就返回一个<code>NULL</code>指针。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Form follows function."</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* finds first 'f' */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p <span class="token operator">=</span> follows function<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数<code>strrchr</code>和<code>strchr</code>类似，但它会反向搜索字符。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Form follows function."</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* finds last 'f' */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p <span class="token operator">=</span> function<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查找任何几个字符 </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strpbrk</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>accept<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数<code>strpbrk</code>它并不查找某个特定的字符，而是查找任何一组字符第1次在字符串中出现的位置，它返回一个指向<code>s</code>中第一个匹配<code>accept</code>中任何一个字符的字符位置。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Form follows function."</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">strpbrk</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"mn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p <span class="token operator">=</span> m follows function<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查找一个子串</li></ul><pre class="line-numbers language-none"><code class="language-none">char *strstr(const char *haystack, const char *needle);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数<code>strstr</code>在第一个参数中查找第二个参数第1次出现的起始位置，并返回一个指向该位置的指针。如果<code>needle</code>并没有完整地出现在<code>haystack</code>的任何地方，函数将返回<code>NULL</code>，如果第二个参数是一个空字符串，函数就返回<code>haystack</code>。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Form follows function."</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">strstr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"fun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">p <span class="token operator">=</span> function<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查找一个字符串前缀</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">size_t</span> <span class="token function">strspn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>accept<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> <span class="token function">strcspn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>reject<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数<code>strspn</code>返回字符串中第一个<strong>不属于</strong>该组字符的<strong>字符的下标</strong>。<code>strcspn</code>函数返回第一个<strong>属于</strong>该组字符的<strong>字符的下标</strong>。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">size_t</span> n<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Form follows function."</span><span class="token punctuation">;</span>n <span class="token operator">=</span> <span class="token function">strspn</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"Form"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* n = 4 */</span> n <span class="token operator">=</span> <span class="token function">strspn</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">" \t\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* n = 0 */</span>n <span class="token operator">=</span> <span class="token function">strcspn</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"Form"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* n = 0 */</span>n <span class="token operator">=</span> <span class="token function">strcspn</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">" \t\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* n = 4 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查找标记</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strtok</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>delim<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数<code>strtok</code>目的是在字符串中搜索一个<strong>记号</strong>（就是一系列不包含特定分隔字符的字符）。调用<code>strtok(s1, s2)</code>它会在<code>s1</code>中搜索不包含在<code>s2</code>中的非空字符序列。<code>strtok</code>函数会在记号末尾的字符后面存储一个空字符作为<strong>标记</strong>，然后返回一个指针指向记号的首字符。</p><p>strtok函数最有用的特点是以后可以调用strtok函数在同一字符串中搜索更多的记号。调用<code>strtok(NULL, s2)</code>就可以继续上一次的strtok函数调用。和上一次调用一样，strtok函数会用一个空字符来标记新的记号的末尾，然后返回一个指向新记号的首字符的指针。这个过程可以持续进行，直到strtock函数返回空指针，这表明找不到符合要求的记号。</p><p>一个提取年月日的例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>month<span class="token punctuation">,</span> <span class="token operator">*</span>day<span class="token punctuation">,</span> <span class="token operator">*</span>year<span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">" April  28,1998"</span><span class="token punctuation">;</span> <span class="token comment">/* 月与日之间以空格或制表符分隔，逗号之前可能有空格或制表符 */</span>        month <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">" \t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    day <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">" \t,"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    year <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">" \t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"month = %s, day = %s, year = %s\n"</span><span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str = %s\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">month <span class="token operator">=</span> April<span class="token punctuation">,</span> day <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">,</span> year <span class="token operator">=</span> <span class="token number">1998</span>str <span class="token operator">=</span> April<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、内存操作函数"><a href="#三、内存操作函数" class="headerlink" title="三、内存操作函数"></a>三、内存操作函数</h2><ul><li> <code>void *memcpy(void *dest, const void *src, size_t n);</code></li></ul><p>函数<code>memcpy</code>从src的起始位置复制n个字节到dest的内存起始位置。可以用该函数复制任何类型的值，如果src和dest内存出现了重叠则结果是未定义的。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>         <span class="token function">memcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> a <span class="token operator">+</span> SIZE<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>void *memmove(void *dest, const void *src, size_t n);</code></li></ul><p>函数memmove功能与memcpy相同，但它能够正确处理源参数和目标参数内存出现重叠的情况。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>         <span class="token function">memmove</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> a <span class="token operator">+</span> SIZE<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>int memcmp(const void *s1, const void *s2, size_t n);</code></li></ul><p>函数memcmp对两段内存的内容进行比较，这两段内存分别起始于s1和s2，共比较n个字节。这些值按照无符号字符逐个字节进行比较，函数返回类型与strcmp一样。由于这些值是根据一串无符号字节进行比较的，所以如果memcmp函数用于比较不是单字节的数据（如整数或浮点数）就可能会现出不可预料的结果。</p><ul><li><code>void *memchr(const void *s, int c, size_t n);</code></li></ul><p>函数memchr从s的起始位置开始查找字符c第1次出现的位置，并返回一个指向该位置的指针，它共查找n个字节。</p><ul><li><code>void *memset(void *s, int c, size_t n);</code></li></ul><p>函数memset函数把s开始的n个字节都设置为字符c。</p><p>例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>         <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> a <span class="token operator">+</span> SIZE<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中数组并非指针</title>
      <link href="/2021/12/09/c-yu-yan-zhong-shu-zu-bing-fei-zhi-zhen/"/>
      <url>/2021/12/09/c-yu-yan-zhong-shu-zu-bing-fei-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h1 id="数组并非指针"><a href="#数组并非指针" class="headerlink" title="数组并非指针"></a>数组并非指针</h1><hr><h2 id="一、什么是声明，什么是定义"><a href="#一、什么是声明，什么是定义" class="headerlink" title="一、什么是声明，什么是定义"></a>一、什么是声明，什么是定义</h2><p>首先我们回顾下<code>C</code>语言中的声明和定义概念。</p><ul><li>定义</li></ul><p>只能出现在一个地方。定义它确定对象的类型并分配内存，用于创建新的对象。例如：<code>int a[100];</code></p><ul><li>声明</li></ul><p>可以出现多次。声明它描述了对象的类型，用于指代其他地方定义的对象（例如在其它文件里）。例如：<code>extern int a[];</code></p><p>记住C语言中的对象（比如函数和变量）必须有且只有一个定义，但它可以有多个<strong>extern</strong>声明。</p><p>extern对象的声明告诉编译器对象的类型和名字，对象的内存分配则在别处进行。由于并未在声明中为数组分配内存，所以并不需要提供关于数组长度的信息。对于多维数组，需要提供除左边一维之外其它维的长度。 </p><p>指针的外部声明与数组定义不匹配会导致出错，例如下面的示例：</p><p>文件 a.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件 b.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"a.c"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并运行：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@localhost Temp]$ gcc -g b.c -o bb.c: 在函数‘main’中:b.c:6: 错误：与‘a’类型冲突a.c:1: 附注：‘a’的上一个定义在此<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实要修正这个错误很容易，只要使声明与定义保持一致就行。</p><p>修改后的 b.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"a.c"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件 a.c 中 <code>int a[100]</code> 表示定义了 a 数组并分配了100个<code>int</code>的空间，而 <code>int *p</code> 则表示申请一个地址来装该指针。指针的名字是 p，它可以指向任何一个 <code>int</code>变量（或int型数组）。指针变量 p 本身始终位于同一个地址，但它的内容在任何时候都可以不同，指向不同地址的 int 变量。这些不同的 int 变量可以有不同的值。<code>int a[100]</code>中数组a的地址并不能改变，在不同的时候它的内容可以不同，但它总是表示100个连续的内存空间。</p><h2 id="二、数组并非指针"><a href="#二、数组并非指针" class="headerlink" title="二、数组并非指针"></a>二、数组并非指针</h2><p>我们经常听到过<strong>数组和指针是相同的</strong>这种说法，但其实这种说明并非完全正确，确实存在一种指针和数组的定义完全相同的上下文环境，但这只是数组的一种极为普通的用法，并非所有情况下都是如此。但是，人们却自然而然地归纳并假定在所有的情况下数组和指针都是等同的。我们分析下面两个小例子</p><p>a.c</p><pre class="line-numbers language-a.c" data-language="a.c"><code class="language-a.c">#include &lt;stdio.h&gt;int main(int argc, char **argv){char p[] = "abcd";printf("%c\n", p[0]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并运行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@localhost Temp]$ gcc -g a.c -o a[dendi875@localhost Temp]$ ./aa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>p.c</p><pre class="line-numbers language-p.c" data-language="p.c"><code class="language-p.c">#include &lt;stdio.h&gt;int main(int argc, char **argv){char *p = "abcd";printf("%c\n", p[0]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并运行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@localhost Temp]$ gcc -g p.c -o p[dendi875@localhost Temp]$ ./pa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面两个例子分别对数组和指针使用了下标的访问，它们都能正常运行并结果一致。但就是这种情况让我们错误的认为数组和指针完全相同。</p><p>下面我们分析下数组和指针是如何访问的</p><h3 id="对数组下标的引用"><a href="#对数组下标的引用" class="headerlink" title="对数组下标的引用"></a>对数组下标的引用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译器编译时为 p 变量分配了一个地址假设为 7321，上面的代码运行时分为两个步骤：</p><ul><li><p>运行时步骤1：取 i 的值，将它与 7321 相加</p></li><li><p>运行时步骤2：取地址（7321 + 1）的内容</p></li></ul><p>数组的这种引用方式是对内存的直接引用</p><h3 id="对指针进行下标的引用"><a href="#对指针进行下标的引用" class="headerlink" title="对指针进行下标的引用"></a>对指针进行下标的引用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译器编译时为p变量分配了一个地址假设为 1237，上面的代码运行时分为三个步骤：</p><ul><li><p>运行时步骤1：取地址 1237 的内容，假设为 8352</p></li><li><p>运行时步骤2：取得i的值，并将它与 8352 相加</p></li><li><p>运行时步骤3：取地址（8352 + 1）的内容</p></li></ul><p>指针的这种引用方式是对内存间接的引用</p><h2 id="三、数组和指针的其它区别"><a href="#三、数组和指针的其它区别" class="headerlink" title="三、数组和指针的其它区别"></a>三、数组和指针的其它区别</h2><table><thead><tr><th>指针</th><th align="center">数组</th></tr></thead><tbody><tr><td>保存数据的地址</td><td align="center">保存数据</td></tr><tr><td>间接访问数据，首先取得指针的内容，把它作为地址，然后从这个地址提取数据。<br>如果指针有一个下标 p[i] ，就把指针的内容加上 i 作为地址，从中提取数据</td><td align="center">直接访问数据，a[i] 只是简单地以 a + i 为地址取得数据</td></tr><tr><td>通常用于动态数据结构</td><td align="center">通常用于存储固定数目且数据类型相同的元素</td></tr><tr><td>相关的函数 malloc，free等</td><td align="center">隐式分配和删除</td></tr><tr><td>通常指向匿名数据</td><td align="center">自身即为数据名</td></tr></tbody></table><p>数组和指针都可以在它们的定义中用字符串常量进行初始化。尽管看上去一样，底层机制却不相同。</p><p>定义指针</p><pre class="line-numbers language-none"><code class="language-none">char *p;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义数组</p><pre class="line-numbers language-none"><code class="language-none">char buff[4096];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义指针时，编译器并不为指针所指向的对象分配空间，它只是分配指针本身的空间，除非在定义的同时赋给指针一个字符串常量进行初始化。例如，下面的定义创建了一个字符串常量（为其分配了内存）</p><pre class="line-numbers language-none"><code class="language-none">char *p = "abcd";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>只有对字符串常量才能这样，如浮点数就不行</p><pre class="line-numbers language-none"><code class="language-none">float *pi = 3.14; /* 错误，无法通过编译 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在ANSI C中，初始化指针时所创建的字符串常量被定义为只读。如果试图通过指针修改这个字符串的值，程序就会出现未定义的行为</li></ul><p>例如文件 p.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span> <span class="token comment">// 运行时会导致段错误 (core dumped)</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">'y'</span><span class="token punctuation">;</span>   <span class="token comment">// 同样的运行时会导致段错误 (core dumped)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>与指针相反，由字符串初始化的数组是可以修改的</li></ul><p>例如文件 a.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s = %s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译并运行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@localhost Temp]$ gcc -g a.c -o a[dendi875@localhost Temp]$ ./as = xbcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针（二）</title>
      <link href="/2021/12/09/c-he-zhi-zhen-er/"/>
      <url>/2021/12/09/c-he-zhi-zhen-er/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、数组指针"><a href="#一、数组指针" class="headerlink" title="一、数组指针"></a>一、数组指针</h2><p>数组指针就是指向数组的指针。首先它是一个指针，这个指针指向的是一个数组。</p><ul><li>例子1</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> calendar<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以把calendar看成是一个有12个元素的数组，每个元素又是一个有着31个整型元素的数组。可以把calendar当作一个二维数组，也可以把它当作一维数组组成的一维数组。</p><ul><li>例子2</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> calendar<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>monthp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span> <span class="token operator">=</span> calendar<span class="token punctuation">;</span> <span class="token comment">// 等价于 int (*monthp)[31] = &amp;calendar[0]; </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>monthp是<strong>数组指针</strong>。它是一个指向拥有31个整型元素的数组的指针。monthp指向了数组calendar的第一个元素（保存了数组第一个元素的地址）。<code>*monthp</code>是一个佣有31个整型元素的数组（可以想象为<code>int a[31];</code>中的<code>a</code>）</p><p>比如新的一年开始时，需要对calendar数组进行清空。下面展示几种不同的实现方式。</p><ul><li>calendar.c</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> calendar<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> month<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>month <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> month <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> month<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> day<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> day <span class="token operator">&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span> day<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>calendar<span class="token punctuation">[</span>month<span class="token punctuation">]</span><span class="token punctuation">[</span>day<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// *(calendar[month] + day) = 0;</span><span class="token comment">// *(*(calendar + month) + day) = 0;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是用数组取下标的方式。<code>calendar[month][day] = 0;</code>等价于<code>*(calendar[month] + day) = 0;</code>，也等价于<code>*(*(calendar + month) + day) = 0;</code></p><ul><li>calendar2.c</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> calendar<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>monthp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>monthp <span class="token operator">=</span> calendar<span class="token punctuation">;</span> monthp <span class="token operator">&lt;</span> calendar <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">;</span> monthp<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> day<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> day <span class="token operator">&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span> day<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>monthp <span class="token operator">+</span> day<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是用<strong>数组指针</strong>的方式来遍历数组calendar。<br>其中<code>for</code>语句中的<code>monthp = calendar; monthp &lt; calendar + 12; monthp++</code>可以换成<code>monthp = &amp;calendar[0]; monthp &lt; &amp;calendar[0] + 12; monthp++</code>。</p><ul><li>calendar3.c</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> calendar<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>monthp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>monthp <span class="token operator">=</span> calendar<span class="token punctuation">;</span> monthp <span class="token operator">&lt;</span> calendar <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">;</span> monthp<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> <span class="token operator">*</span>dayp<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>dayp <span class="token operator">=</span> <span class="token operator">*</span>monthp<span class="token punctuation">;</span> dayp <span class="token operator">&lt;</span> <span class="token operator">*</span>monthp <span class="token operator">+</span> <span class="token number">31</span><span class="token punctuation">;</span> dayp<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>dayp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>像用指针的方式遍历一维数组那样，用指针来遍历<code>*monthp</code>。<br>内层的<code>for</code>语句中的<code>dayp = *monthp; dayp &lt; *monthp + 31; dayp++</code>可以换成<code>dayp = &amp;(*monthp)[0]; dayp &lt; &amp;(*monthp)[0] + 31; dayp++</code>，也可以换成<code>dayp = *monthp; dayp &lt; &amp;(*monthp)[31]; dayp++</code></p><h2 id="二、指针数组"><a href="#二、指针数组" class="headerlink" title="二、指针数组"></a>二、指针数组</h2><p>指针数组它的类型是一个数组，数组中每个元素是一个指针。</p><p>我们用一个<strong>二维字符数组</strong>来说明下，C中的字符串可以当作以<code>NULL</code>字符结尾的<strong>一维字符数组</strong>，如下面的例子</p><ul><li>一维字符数组</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种写法是等价的。但与<code>char *message = "hello";</code>还是有区别的，</p><pre class="line-numbers language-char" data-language="char"><div class="caption"><span>message[]```声明message是一个**数组**，```char *message```声明message是一个**指针**。</span></div><code class="language-char">- 二维字符数组```cconst char keyword[][9] = {{'a', 'u', 't', 'o', '\0',  '\0',  '\0',  '\0', '\0'},{'s', 't', 'a', 't',  'i',   'c',  '\0',  '\0', '\0'},{'e', 'x', 't', 'e',  'r',  'n',  '\0',  '\0', '\0'},{'r', 'e', 'g', 'i',  's',   't',   'e',   'r', '\0'},{'c', 'o', 'n', 's',  't',  '\0',  '\0',  '\0', '\0'},{'r', 'e', 's', 't',  'r',   'i',   'c',   't', '\0'},{'v', 'o', 'l', 'a',  't',   'i',   'l',   'e', '\0'},};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> keyword<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"auto"</span><span class="token punctuation">,</span><span class="token string">"static"</span><span class="token punctuation">,</span><span class="token string">"extern"</span><span class="token punctuation">,</span><span class="token string">"register"</span><span class="token punctuation">,</span><span class="token string">"const"</span><span class="token punctuation">,</span><span class="token string">"restrict"</span><span class="token punctuation">,</span><span class="token string">"volatile"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这两种写法也是等价的，它们都可以当作<strong>二维字符数组</strong>，数组中每个元素是一个一维字符数组，或者每个元素以字符串的方式存储在数组中。</p><ul><li>指针数组</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>keyword<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"auto"</span><span class="token punctuation">,</span><span class="token string">"static"</span><span class="token punctuation">,</span><span class="token string">"extern"</span><span class="token punctuation">,</span><span class="token string">"register"</span><span class="token punctuation">,</span><span class="token string">"const"</span><span class="token punctuation">,</span><span class="token string">"restrict"</span><span class="token punctuation">,</span><span class="token string">"volatile"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>kwp<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>kwp <span class="token operator">=</span> keyword<span class="token punctuation">;</span> <span class="token operator">*</span>kwp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> kwp<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>kwp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种声明方式表示keyword是个数组，数组中每个元素是一个指向字符的指针。所以keyword是<strong>指针数组</strong>。它比<strong>二维字符数组</strong>声明方式更节约内存，特意数组最后加一个<code>NULL</code>指针，是为了可以在遍历是不需要知道数组的长度。</p><h2 id="三、函数指针"><a href="#三、函数指针" class="headerlink" title="三、函数指针"></a>三、函数指针</h2><p>函数指针就是指向函数的指针。它是一个指针，这个指针指向的是一个函数。</p><ul><li>pf.c</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/* 声明函数指针并初始化 */</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token comment">// 或者 int (*pf)(int, int) = &amp;f;</span><span class="token keyword">int</span> result<span class="token punctuation">;</span>        <span class="token comment">/* 三种方式调用函数 */</span>result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">=</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"result = %d\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子是<code>pf</code>就是一个函数指针，这个指针指向的是一个函数，这个函数需要满足有两个整型参数，返回值是整型。关于函数指针需要注意：</p><p>1）声明一个函数指针并不意味着它马上可以使用。和其它指针一样，对函数指针执行间接访问之前必须它把初始化为指向某个函数。</p><p>2）在函数指针初始化之前具有<code>f</code>的原型是很重要的，否则编译器就无法检查<code>f</code>的类型是否与<code>pf</code>所指向的类型一致（参数的个数、参数的类型、返回值的类型）</p><p>3）上面三种函数调用方式是等价的，<code>pf</code>是指向函数的指针，<code>(*pf)</code>就是<code>pf</code>所指向的那个函数。<code>(*pf)()</code>调用方式相比于<code>pf()</code>调用方式能提醒程序员<code>pf</code>是个函数指针而不是函数名。</p><p>提示：</p><p>函数它也像变量一样占用内存单元，所以每个函数都有一个地址，就像每个变量都有地址一样。C语言把指向函数的指针当作指向其它数据类型的指针一样对待，可以把它存储到变量中，或者可以当作数组的元素，或者作为结构或联合的成员，或者可以当前函数的参数或返回值。</p><ul><li>函数指针的用途<strong>回调函数</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">{</span><span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token function">add_to_list</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token function">search_list</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">compare_ints</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>first <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> expected_value <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>first <span class="token operator">=</span> <span class="token function">add_to_list</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>first <span class="token operator">=</span> <span class="token function">add_to_list</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>first <span class="token operator">=</span> <span class="token function">add_to_list</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token function">search_list</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token operator">&amp;</span>expected_value<span class="token punctuation">,</span> compare_ints<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Node value：%d\n"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Node not found.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 在链表开始处插入一个结点 * * @param  first 指向旧链表首结点的指针 * @param  value    需要存储到新结点的值 * @return new_node 返回指向新结点的指针 */</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token function">add_to_list</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>new_node<span class="token punctuation">;</span>new_node <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>new_node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>new_node<span class="token operator">-&gt;</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>new_node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token keyword">return</span> new_node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 在一个单向链表中查找一个指定的值，第一个参数是指向链表首结点的指针， * 第二个参数是需要查找的值，第三个参数是函数指针。 * 这个函数查找存在结点中的值与类型无关，可以查找整型，字符串等 */</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span><span class="token function">search_list</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> first<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>value<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">compare_ints</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> p <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> p <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、指针函数"><a href="#四、指针函数" class="headerlink" title="四、指针函数"></a>四、指针函数</h2><p>指针函数就是返回值为指针的函数。</p><ul><li>max.c <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"max = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>x <span class="token operator">&gt;</span> <span class="token operator">*</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>max函数就是一个指针函数，它返回值的类型是一个指向整型的指针。</li></ul><p>max函数还可以返回指向外部变量的指针</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>z<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>max函数还可以返回指向函数内部声明为<code>static</code>变量的指针。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、typedef定义函数指针类型"><a href="#五、typedef定义函数指针类型" class="headerlink" title="五、typedef定义函数指针类型"></a>五、typedef定义函数指针类型</h2><p>可以用<code>typedef</code>来<strong>定义函数指针</strong>，然后简化一些复杂的定义。比如C中的的信号处理函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用<code>typedef</code>定义函数指针，简化上面的定义</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>typedef定义函数指针类型的一个例子</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;typedef double (*ptrfun)(double, double);double add(double x, double y);int main(void){ptrfun pf = add;printf("%f\n", (*pf)(3.1415, 1.1111));return 0;}double add(double x, double y){return x + y;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ptrfun```是自定义的数据类型，可以像其它数据类型一样用来定义变量，或定义函数的返回值，或定义函数参数等，只不过```ptrfun```定义的变量是**指向函数的指针类型**。可以理解为像```int" data-language="ptrfun```是自定义的数据类型，可以像其它数据类型一样用来定义变量，或定义函数的返回值，或定义函数参数等，只不过```ptrfun```定义的变量是**指向函数的指针类型**。可以理解为像```int"><div class="caption"><span>*```定义的变量是指向整型的指针类型一样。</span></div><code class="language-ptrfun```是自定义的数据类型，可以像其它数据类型一样用来定义变量，或定义函数的返回值，或定义函数参数等，只不过```ptrfun```定义的变量是**指向函数的指针类型**。可以理解为像```int">```cint *p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ptrfun```和```int" data-language="ptrfun```和```int"><div class="caption"><span>*```类似都是指向某种类型的指针。一个是指向函数的指针，一个是指针整型的指针。</span></div><code class="language-ptrfun```和```int">## 六、typedef定义函数类型可以用typedef来**定义函数**，然后简化一些复杂的定义。比如C中的信号处理函数```signal``````cvoid (*signal(int signum, void (*func)(int)))(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用<code>typedef</code>定义函数，来简化上面的定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token function">Sigfunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sigfunc <span class="token operator">*</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> Sigfunc <span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>typedef定义函数类型的一个例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">double</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Fun <span class="token operator">*</span>pf <span class="token operator">=</span> add<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token number">3.1415</span><span class="token punctuation">,</span> <span class="token number">1.1111</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<code>Fun pf = add;</code>这是错误的，因为<code>add</code>是<strong>函数指针</strong>，而Fun的类型是<strong>函数</strong>;</p><p>使用<code>typedef</code>定义的Fun是函数。可以把它理解成像定义了整型一样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">int_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用<code>Fun</code>来定义指针变量和用<code>int_t</code>来定义指针变量一样都要加<code>*</code>号。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int_t</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span>Func <span class="token operator">*</span>pf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和指针（一）</title>
      <link href="/2021/12/09/c-he-zhi-zhen-yi/"/>
      <url>/2021/12/09/c-he-zhi-zhen-yi/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、声明指针"><a href="#一、声明指针" class="headerlink" title="一、声明指针"></a>一、声明指针</h2><ul><li>例子1</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面语句的意思是声明i为一个整型变量，声明p为一个指向整型的指针，并且取i的地址对该指针进行初始化。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token operator">*</span><span class="token operator">&amp;</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的意思是把值2赋值给变量i与<code>i=2;</code>作用相同。我们来分析下，首先<code>&amp;</code>操作符产生i的地址，它是一个指针常量（我们并不需要知道这个指针常量的实际值）。接着，<code>*</code>操作符对其操作数执行间接访问操作，这个操作数就是i的地址。所以值2就存储于i中。</p><p><strong>注意</strong>：这里需要说明的是<code>*</code>号根据所处的上下文环境不同，它表示的含义也不一样。在声明中<code>int *p = &amp;i;</code>，其<code>*</code>号作用是指明p的类型以便告诉编译器p是一个指向int类型的变量指针，而在语句中（比如<code>*&amp;i = 2;</code>），<code>*</code>号会执行间接访问操作。</p><ul><li>例子2</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span>    b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>人们会很自然的认为这条语句把所有三个变量声明为指向整型的指针，但其实<code>*</code>号只对b有用。b是一个整型指针，其余两个只是普通的整型。要声明三个指针正确的应该是这样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token operator">*</span>d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>例子3</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>message <span class="token operator">=</span> <span class="token string">"Hello world"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条语句把message声明为一个指向字符的指针，并用字符串常量中第1个字符的地址对该指针进行初始化。<br><strong>注意</strong>：千万不要误认为是对<code>*message</code>赋值，事实上它是赋值给<code>message</code>本身。等价于下面的声明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>message<span class="token punctuation">;</span>message <span class="token operator">=</span> <span class="token string">"Hello world"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>例子4</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>ptr_to_char<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条语句意思是把变量ptr_to_char声明为一个指向字符的指针。但添加<code>typedef</code>声明变为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr_to_char<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个声明把ptr_to_char作为<strong>指向字符的指针类型</strong>的新名字，可以像其它预定义类型的名字一样用它来声明变量。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ptr_to_char a <span class="token operator">=</span> <span class="token string">"Hello world"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：没有<code>typedef</code>时ptr_to_char是一个变量，有<code>typedef</code>时ptr_to_char是一种新的数据类型名字，像<code>int</code>，<code>char</code> 一样可以用来声明变量。<code>ptr_to_char</code>声明的变量是指向字符的指针。</p><ul><li>例子5</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">/* 错误的 */</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>j<span class="token punctuation">;</span> <span class="token comment">/*合法的 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为函数<code>f</code>有<code>const</code>进行了限定（只读不能修改），不能改变指针p所指向的对象，但是可以改变p本身。</p><ul><li>例子6</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">/* 合法的 */</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>j<span class="token punctuation">;</span> <span class="token comment">/* 错误的 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>const</code>放到了参数名的前面，那么不能改变p本身，但可以改变p所指向的对象。这个特性不经常用到。</p><h2 id="二、NULL指针"><a href="#二、NULL指针" class="headerlink" title="二、NULL指针"></a>二、NULL指针</h2><p>NULL是一个特殊的指针变量，表示不指向任何东西。<code>NULL</code>指针的概念是非常有用的，它可以赋值给一个任何类型的指针，用于表示那个指针目前并未指向任何东西。</p><p>对指针进行间接访问操作（<code>*</code>）可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西。因此对一个<code>NULL</code>指针进行间接访问操作是非法的。<strong>在对指针进行间接访问操作之前，必须确保它并非NULL指针</strong>。</p><p>良好的编程习惯就是，如果你已经知道指针将被初始化为什么地址，就把它初始化为该地址，否则就把它初始化为<code>NULL</code>。</p><h2 id="三、指针常量"><a href="#三、指针常量" class="headerlink" title="三、指针常量"></a>三、指针常量</h2><p>指针常量与非指针常量在本质上是不同的，因为编译器负责把变量赋值给计算机内存中的位置，程序员事先无法知道某个特定的变量将存储到内存中的哪个位置。因此，可以通过取地址操作符<code>&amp;</code>获取一个变量的地址，而不是直接把它地址写成字面值常量的形式。</p><p>在极少见的情况下，我们偶尔需要使用指针常量，这时我们可以通过把一个整型值强制转换为指针类型来创建它。<br>比如：假设我们知道了整型变量a存储在内存的地址为100，那么可以这样赋值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">100</span> <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把100从“整型”转换为“指向整型的指针”，再对它进行间接访问就是合法的。<br>但是很少有机会需要使用这种技巧。</p><p>再看一个示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的数组名<code>a</code>是个<strong>指针常量</strong>而不是指针变量，它保存了数组第1个元素的地址（a指向了数组第一个元素）。<strong>你不能修改常量的值</strong>。</p><p>只有在两种场合下，数组名并不用指针常量来表示（数组名并不保存数组第一个元素的地址）：</p><p>1）数组名作为<code>sizeof</code>操作符时<code>sizeof</code>返回整个数组的长度，而不是指针常量的长度</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size = %lu\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）数组名作为<code>&amp;</code>操作符时对一个数组名使用取地址操作符产生的是一个指向数组的指针</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> calendar<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>monthp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span>monthp <span class="token operator">=</span> calendar<span class="token punctuation">;</span> <span class="token comment">// 等价于 monthp = &amp;calendar[0];</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>monthp是一个指向拥有31个整型元素的数组的指针。如果把calendar当作一个一维数组元素组成的一维数组，那么可以把monthp当作是指向calendar第一个元素的指针。而<code>*monthp</code>就是一个一维数组，它可以像普通的一维数组名那样用下标取元素，<code>(*monthp)[0]</code>等价于<code>*((*monthp) + 0)</code>，还等价于<code>calendar[0][0]</code>，如果把calendar看成是一个二维数组的话，这三种方式都是取calendar第0行第0列的元素。</p><h2 id="四、指向指针的指什"><a href="#四、指向指针的指什" class="headerlink" title="四、指向指针的指什"></a>四、指向指针的指什</h2><ul><li>例子1</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ppi<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>pppi<span class="token punctuation">;</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>ppi <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span>pppi <span class="token operator">=</span> <span class="token operator">&amp;</span>ppi<span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token operator">*</span>ppi <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>pppi <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码14-17行都具有相同的效果，都是对变量i进行赋值为1。<br>i是一个整型。<br>pi是一个指向整型的指针。<br>ppi是一个指向整型的指针的指针。<br>pppi是一个指向整型的指针的指针的指针。</p><p>上面代码10-12行还可以换成下面这样：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">pppi <span class="token operator">=</span> <span class="token operator">&amp;</span>ppi<span class="token punctuation">;</span><span class="token operator">*</span>pppi <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token operator">*</span>ppi  <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// **pppi = &amp;i;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="五、void-通用型指针"><a href="#五、void-通用型指针" class="headerlink" title="五、void *通用型指针"></a>五、<code>void *</code>通用型指针</h2><p>看一个示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage：concat &lt;s1&gt; &lt;s2&gt;\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"r = %s\n"</span><span class="token punctuation">,</span> <span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>argv <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>argv <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc failed in concat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">strcpy</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcat</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">[</span>zq@localhost Temp<span class="token punctuation">]</span>$ <span class="token punctuation">.</span><span class="token operator">/</span>concat abc defr <span class="token operator">=</span> abcdef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的示例中<code>malloc</code>函数返回值类型是<code>void *</code>，这种返回值类型我们称为<strong>通用类型指针</strong>，当调用内存分配函数时，<br>函数无法知道计划存储在内存块中的数据类型是什么类型的，所以它不能返回<code>int</code>类型指针，也不能返回<code>char</code>类型指针等普通类型的指针。取而代之的，函数就返回<code>void *</code>类型指针。<br>*<em>通常情况下，不需要强制转换，可以把void <em>类型值赋值给任何指针类型的变量</em></em></p><p>上面的代码中<code>printf("r = %s\n", concat(*(argv + 1), *(argv + 2)));</code>也可以写成<code>printf("r = %s\n", concat(argv[1], argv[2]));</code></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>指针是Ｃ语言的灵魂，它很强大但也很容易出错，必须掌握<strong>指针编程</strong>的知识和技巧</li><li>指针就是地址，指针变量就是保存内存地址的变量，指针变量的值就是一个数字</li><li>一般我们说p指向了i，意思是指针p保存了i的地址</li><li>使用<code>&amp;</code>获取变量的地址</li><li>间接访问操作<code>*</code>只能作用于指针类型的表达式且非<code>NULL</code></li><li>数组取下标与指针间接访问的互相转换可以记住一个公式：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">array<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>array <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>array</strong>是代表数组名，<strong>s</strong>是表达式</p><ul><li>声明一个指针变量并不会自动分配任何内存。在对指针执行间接访问前，指针必须进行初始化或者使它指向现有的内存或者给它分配动态内存。对未初始化的指针变量执行间接访问操作是非法的，而且这种错误常常难于验证检测。其结果常常是一个不相关的值被修改。这种错误是很难被调试发现的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autotools简介（autoconf, automake）</title>
      <link href="/2021/12/09/autotools-jian-jie-autoconf-automake/"/>
      <url>/2021/12/09/autotools-jian-jie-autoconf-automake/</url>
      
        <content type="html"><![CDATA[<h1 id="Autotools简介（autoconf-automake）"><a href="#Autotools简介（autoconf-automake）" class="headerlink" title="Autotools简介（autoconf, automake）"></a>Autotools简介（autoconf, automake）</h1><hr><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>无论是在Linux还是在Unix环境中，make都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到make或 make install。利用make工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用make和 makefile工具就可以轻而易举的理顺各个源文件之间纷繁复杂的相互关系。</p><p>但是如果通过查阅make的帮助文档来手工编写Makefile,对任何程序员都是一场挑战。幸而有GNU 提供的Autoconf及Automake这两套工具使得编写makefile不再是一个难题。</p><p>本文将介绍如何利用 GNU Autoconf 及 Automake 这两套工具来协助我们自动产生 Makefile文件，并且让开发出来的软件可以像大多数源码包那样，只需”./configure”, “make”,”make install” 就可以把程序安装到系统中。</p><h2 id="二、从epoch程序开始"><a href="#二、从epoch程序开始" class="headerlink" title="二、从epoch程序开始"></a>二、从epoch程序开始</h2><p>我们从一个获取系统时间的程序为例开始讲解。</p><p>1）新建目录</p><p>在你的工作目录下新建一个epoch目录，我们用它来存放epoch程序及相关文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ mkdir epoch$ cd epoch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2）epoch.c</p><p>编写一个epoch.c程序，内容如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"config.h"</span></span><span class="token keyword">double</span> <span class="token function">get_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> sec<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_GETTIMEOFDAY</span></span>    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">;</span>    <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tv<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sec <span class="token operator">=</span> tv<span class="token punctuation">.</span>tv_sec<span class="token punctuation">;</span>    sec <span class="token operator">+=</span> tv<span class="token punctuation">.</span>tv_usec <span class="token operator">/</span> <span class="token number">1000000.0</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    sec <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> sec<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> <span class="token function">get_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）生成configure</p><p>我们使用autoscan命令来帮助我们根据目录下的源代码生成一个configure.ac的模板文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ autoscan$ lsautoscan.log  configure.scan  epoch.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行后在epoch目录下会生成一个文件configure.scan，我们可以拿它作为configure.ac的模板。现在将configure.scan改名为configure.ac，并且编辑它，修改成下面的内容：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ mv configure.scan configure.ac<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#                                               -*- Autoconf -*-# Process this file with autoconf to produce a configure script.AC_PREREQ([2.63])AC_INIT(epoch, 1.0, quanzhang875@gmail.com)AM_INIT_AUTOMAKE(epoch, 1.0)AC_CONFIG_SRCDIR([epoch.c])AC_CONFIG_HEADERS([config.h])# Checks for programs.AC_PROG_CC# Checks for libraries.# Checks for header files.AC_CHECK_HEADERS([sys/time.h])# Checks for typedefs, structures, and compiler characteristics.# Checks for library functions.AC_CHECK_FUNCS([gettimeofday])AC_OUTPUT(Makefile)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行命令<strong>aclocal</strong>和<strong>autoconf</strong>及<strong>autoheader</strong>，就会分别生成<strong>aclocal.m4</strong>和<strong>configure</strong>及<strong>config.h.in</strong>文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ aclocal$ lsaclocal.m4  autom4te.cache  autoscan.log  configure.ac  epoch.c$ autoconf$ lsaclocal.m4  autom4te.cache  autoscan.log  configure  configure.ac  epoch.c$ autoheader$ lsaclocal.m4  autom4te.cache  autoscan.log  config.h.in  configure  configure.ac  epoch.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4）新建 Makefile.am</p><p>Makefile.am文件内容：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ vi Makefile.am<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">AUTOMAKE_OPTIONS=foreignbin_PROGRAMS=epochepoch_SOURCES=epoch.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>automake会根据你写的Makefile.am来自动生成Makefile.in。</p><p>Makefile.am中定义的宏和目标，会指导automake生成指定的代码。例如，宏bin_PROGRAMS将导致编译和连接的目标被生成。</p><p>5）运行automake</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ automake --add-missingconfigure.ac:6: installing `./install-sh'configure.ac:6: installing `./missing'Makefile.am: installing `./depcomp'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6）运行configure生成Makefile和config.h</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ./configurechecking for a BSD-compatible install... /usr/bin/install -cchecking whether build environment is sane... yeschecking for a thread-safe mkdir -p... /bin/mkdir -pchecking for gawk... gawkchecking whether make sets $(MAKE)... yeschecking for gcc... gccchecking for C compiler default output file name... a.outchecking whether the C compiler works... yeschecking whether we are cross compiling... nochecking for suffix of executables...checking for suffix of object files... ochecking whether we are using the GNU C compiler... yeschecking whether gcc accepts -g... yeschecking for gcc option to accept ISO C89... none neededchecking for style of include used by make... GNUchecking dependency style of gcc... gcc3checking how to run the C preprocessor... gcc -Echecking for grep that handles long lines and -e... /bin/grepchecking for egrep... /bin/grep -Echecking for ANSI C header files... yeschecking for sys/types.h... yeschecking for sys/stat.h... yeschecking for stdlib.h... yeschecking for string.h... yeschecking for memory.h... yeschecking for strings.h... yeschecking for inttypes.h... yeschecking for stdint.h... yeschecking for unistd.h... yeschecking sys/time.h usability... yeschecking sys/time.h presence... yeschecking for sys/time.h... yeschecking for gettimeofday... yesconfigure: creating ./config.statusconfig.status: creating Makefileconfig.status: creating config.hconfig.status: executing depfiles commands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsaclocal.m4      autoscan.log  config.h.in  config.status  configure.ac  epoch.c     Makefile     Makefile.in  stamp-h1autom4te.cache  config.h      config.log   configure      depcomp       install-sh  Makefile.am  missing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到此时<strong>Makefile</strong>和<strong>config.h</strong>已经产生出来了。</p><p>7）使用Makefile编译代码</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ makemake  all-ammake[1]: Entering directory `/home/dendi875/auto/epoch'gcc -DHAVE_CONFIG_H -I.     -g -O2 -MT epoch.o -MD -MP -MF .deps/epoch.Tpo -c -o epoch.o epoch.cmv -f .deps/epoch.Tpo .deps/epoch.Pogcc  -g -O2   -o epoch epoch.omake[1]: Leaving directory `/home/dendi875/auto/epoch'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8）运行epoch</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ./epoch1561952071.857380<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样epoch就编译出来了，你还可以试着使用一些其它的make命令，如<strong>make clean</strong>，<strong>make install</strong>，<strong>make dist</strong>。</p><h2 id="三、流程图"><a href="#三、流程图" class="headerlink" title="三、流程图"></a>三、流程图</h2><p>我们用一张图来表示产生<strong>Makefile</strong>和<strong>config.h</strong>的流程</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/afp2.png"></p><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ul><li><a href="http://www.laruence.com/2009/11/18/1154.html">automake，autoconf使用详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> Autoconf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-PHP API 的使用</title>
      <link href="/2021/12/05/elasticsearch-php-api-de-shi-yong/"/>
      <url>/2021/12/05/elasticsearch-php-api-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在<a href="https://zhangquan.me/2021/06/29/elasticsearch-xue-xi-yan-jiu/">elasticsearch研究学习</a>文章中，详细的介绍了<code>ES</code>的重要概念、安装和配置、<strong>ik</strong> 中文分词插件的使用、基本的 <strong>Elasticsearch APIs</strong> 的使用。<code>ES</code>的官方客户端在<code>PHP</code>、<code>Java</code>、<code>Go</code>、<code>Python</code>等其他许多语言中都是可用的。</p><p>本篇我们就来学习下<code>PHP</code>作为<code>ES</code>客户端的基本操作。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 <code>composer.json</code> 文件中增加 elasticsearch-php：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">{    "require": {        "elasticsearch/elasticsearch": "~5.0"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>composer install</code>命令来安装客户端：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">composer install --no-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后加载 autoload.php，并实例化一个客户端对象：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'ES_SERVER'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'es.servers.dev.ofc:9200'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'vendor/autoload.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Elasticsearch<span class="token punctuation">\</span>ClientBuilder</span><span class="token punctuation">;</span><span class="token variable">$client</span> <span class="token operator">=</span> <span class="token class-name static-context">ClientBuilder</span><span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">-&gt;</span><span class="token function">setHosts</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token constant">ES_SERVER</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token operator">-&gt;</span><span class="token function">setRetries</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                            <span class="token operator">-&gt;</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="API-的使用"><a href="#API-的使用" class="headerlink" title="API 的使用"></a>API 的使用</h2><h3 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h3><p>索引管理操作可以使你管理<code>ES</code>集群中的索引，例如：创建、删除、更新索引以及索引的设置和索引的映射。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>创建索引使用的是<code>create</code>函数：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$params</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string single-quoted-string">'index'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'orders'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$response</span> <span class="token operator">=</span> <span class="token variable">$client</span><span class="token operator">-&gt;</span><span class="token function">indices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token variable">$params</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在创建索引时把所需要的请求正文放到<code>body</code>参数中：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$params = [    'index' =&gt; 'userdoor',// 索引名字，类比数据库    'body' =&gt; [        'settings' =&gt; [            'number_of_replicas' =&gt; 1,            'number_of_shards'=&gt;  5,            'max_result_window' =&gt; 1000,        ],        'mappings' =&gt; [            'person' =&gt; [ // 类型名字，类比数据表                '_source' =&gt; ['enabled' =&gt; true],                'properties' =&gt; [ // 下面是包括字段名称，类比数据表中的字段                    'name' =&gt; ['type' =&gt; 'string', 'analyzer' =&gt; 'ik_max_word'], // 姓名                    'title' =&gt; ['type' =&gt; 'string', 'analyzer' =&gt; 'ik_max_word'], // 头衔                    'desc' =&gt; ['type' =&gt; 'string', 'analyzer' =&gt; 'ik_max_word'], // 备注                ]            ]        ]    ]];$response = $client-&gt;indices()-&gt;create($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以验证是否索引是否创建成功：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X GET 'http://localhost:9200/userdoor?pretty' -d ''{  "userdoor" : {    "aliases" : { },    "mappings" : {      "person" : {        "properties" : {          "desc" : {            "type" : "text",            "analyzer" : "ik_max_word"          },          "name" : {            "type" : "text",            "analyzer" : "ik_max_word"          },          "title" : {            "type" : "text",            "analyzer" : "ik_max_word"          }        }      }    },    "settings" : {      "index" : {        "number_of_shards" : "5",        "provided_name" : "userdoor",        "max_result_window" : "1000",        "creation_date" : "1576396958776",        "number_of_replicas" : "1",        "uuid" : "kvwBns5gThOTB2qX2TIwbA",        "version" : {          "created" : "5050399"        }      }    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调整索引映射设置"><a href="#调整索引映射设置" class="headerlink" title="调整索引映射设置"></a>调整索引映射设置</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/php-api/5.0/_index_management_operations.html#_put_mappings_api">Put Mappings API</a> 允许你修改现有索引的映射，或添加新的映射</p><p>比如我们可以再加两个字段<code>age</code>和<code>timeCreated</code>：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$params = [    'index' =&gt; 'userdoor',    'type' =&gt; 'person',    'body' =&gt; [        'person' =&gt; [            'properties' =&gt; [                'timeCreated' =&gt; [                    'type' =&gt; 'date',                    'format' =&gt; 'yyyy-MM-dd HH:mm:ss'                ],                'age' =&gt; [                    'type' =&gt; 'integer'                ]            ]        ]    ]];// Update the index mapping$client-&gt;indices()-&gt;putMapping($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以验证是否更新成功：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X GET 'http://localhost:9200/userdoor?pretty' -d ''{  "userdoor" : {    "aliases" : { },    "mappings" : {      "person" : {        "properties" : {          "age" : {            "type" : "integer"          },          "desc" : {            "type" : "text",            "analyzer" : "ik_max_word"          },          "name" : {            "type" : "text",            "analyzer" : "ik_max_word"          },          "timeCreated" : {            "type" : "date",            "format" : "yyyy-MM-dd HH:mm:ss"          },          "title" : {            "type" : "text",            "analyzer" : "ik_max_word"          }        }      }    },    "settings" : {      "index" : {        "number_of_shards" : "5",        "provided_name" : "userdoor",        "max_result_window" : "1000",        "creation_date" : "1576396958776",        "number_of_replicas" : "1",        "uuid" : "kvwBns5gThOTB2qX2TIwbA",        "version" : {          "created" : "5050399"        }      }    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>使用<code>delete</code>函数来删除索引</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$params = ['index' =&gt; 'userdoor'];$response = $client-&gt;indices()-&gt;delete($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="文档的操作"><a href="#文档的操作" class="headerlink" title="文档的操作"></a>文档的操作</h3><h4 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h4><p>使用<code>index</code>函数来新增文档</p><ul><li>单条文档的新增</li></ul><p>提供<code>ID</code>值：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$params</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string single-quoted-string">'index'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'userdoor'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'type'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'person'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'id'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'1'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'body'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>        <span class="token string single-quoted-string">'name'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'张三'</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'title'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'架构师'</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'desc'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'系统架构师'</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'age'</span> <span class="token operator">=&gt;</span> <span class="token number">28</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'timeCreated'</span> <span class="token operator">=&gt;</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Y-m-d H:i:s'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Document will be indexed to userdoor/person/1</span><span class="token variable">$response</span> <span class="token operator">=</span> <span class="token variable">$client</span><span class="token operator">-&gt;</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token variable">$params</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让<code>ES</code>自已生成<code>ID</code>：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$params = [    'index' =&gt; 'userdoor',    'type' =&gt; 'person',    'body' =&gt; [        'name' =&gt; '李四',        'title' =&gt; '程序员',        'desc' =&gt; '前端开发',        'age' =&gt; 28,        'timeCreated' =&gt; date('Y-m-d H:i:s'),    ]];// Document will be indexed to userdoor/person/&lt;autogenerated ID&gt;$response = $client-&gt;index($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>批量文档的新增</li></ul><p>使用<code>bulk</code>来批量增加文档。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$params</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'body'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string single-quoted-string">'index'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>            <span class="token string single-quoted-string">'_index'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'userdoor'</span><span class="token punctuation">,</span>            <span class="token string single-quoted-string">'_type'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'person'</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$params</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'body'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string single-quoted-string">'name'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'王五'</span><span class="token operator">.</span><span class="token variable">$i</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'title'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'测试'</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'desc'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'自动化测试'</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'age'</span> <span class="token operator">=&gt;</span> <span class="token number">26</span> <span class="token operator">+</span> <span class="token variable">$i</span><span class="token punctuation">,</span>        <span class="token string single-quoted-string">'timeCreated'</span> <span class="token operator">=&gt;</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Y-m-d H:i:s'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$responses</span> <span class="token operator">=</span> <span class="token variable">$client</span><span class="token operator">-&gt;</span><span class="token function">bulk</span><span class="token punctuation">(</span><span class="token variable">$params</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h4><p>使用<code>get</code>函数来查看文档</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$params = [    'index' =&gt; 'userdoor',    'type' =&gt; 'person',    'id' =&gt; '1'];// Get doc at /userdoor/person/1$response = $client-&gt;get($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><p>使用<code>update</code>函数来更新文档：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$params = [    'index' =&gt; 'userdoor',    'type' =&gt; 'person',    'id' =&gt; '1',    'body' =&gt; [        'doc' =&gt; [            'desc' =&gt; '系统架构师，业务架构师'        ]    ]];// Update doc at /userdoor/person/1$response = $client-&gt;update($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><p>使用<code>delete</code>函数来删除文档：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$params = [    'index' =&gt; 'userdoor',    'type' =&gt; 'person',    'id' =&gt; 1];// Delete doc at /userdoor/person/1$response = $client-&gt;delete($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索的操作"><a href="#搜索的操作" class="headerlink" title="搜索的操作"></a>搜索的操作</h3><ul><li>Match 查询</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$params</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string single-quoted-string">'index'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'userdoor'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'type'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'person'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'body'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>        <span class="token string single-quoted-string">'query'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>            <span class="token string single-quoted-string">'match'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>                <span class="token string single-quoted-string">'desc'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'架构师'</span>            <span class="token punctuation">]</span>        <span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$results</span> <span class="token operator">=</span> <span class="token variable">$client</span><span class="token operator">-&gt;</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token variable">$params</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上示例输出：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ php es.phpArray(    [took] =&gt; 9    [timed_out] =&gt;    [_shards] =&gt; Array        (            [total] =&gt; 5            [successful] =&gt; 5            [failed] =&gt; 0        )    [hits] =&gt; Array        (            [total] =&gt; 1            [max_score] =&gt; 1.1000589            [hits] =&gt; Array                (                    [0] =&gt; Array                        (                            [_index] =&gt; userdoor                            [_type] =&gt; person                            [_id] =&gt; 1                            [_score] =&gt; 1.1000589                            [_source] =&gt; Array                                (                                    [name] =&gt; 张三                                    [title] =&gt; 架构师                                    [desc] =&gt; 系统架构师，业务架构师                                    [age] =&gt; 28                                    [timeCreated] =&gt; 2019-12-15 08:44:01                                )                        )                )        ))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以使用原生<code>json</code>来代替数组：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$json = '{"query": {"match": {"desc": "架构师"}}}';$params = [    'index' =&gt; 'userdoor',    'type' =&gt; 'person',    'body' =&gt; $json];$results = $client-&gt;search($params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Bool 查询</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$params</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string single-quoted-string">'index'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'userdoor'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'type'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'person'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'body'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>        <span class="token string single-quoted-string">'query'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>            <span class="token string single-quoted-string">'bool'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>                <span class="token string single-quoted-string">'must'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>                    <span class="token punctuation">[</span><span class="token string single-quoted-string">'match'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string single-quoted-string">'name'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'王五'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token punctuation">[</span><span class="token string single-quoted-string">'match'</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string single-quoted-string">'age'</span> <span class="token operator">=&gt;</span> <span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span>            <span class="token punctuation">]</span>        <span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$results</span> <span class="token operator">=</span> <span class="token variable">$client</span><span class="token operator">-&gt;</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token variable">$params</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhangquan.me/2021/06/29/elasticsearch-xue-xi-yan-jiu/">elasticsearch研究学习</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/client/php-api/5.0/index.html">官方 Elasticsearch-PHP API 文档</a></li><li><a href="https://www.elastic.co/guide/cn/elasticsearch/php/current/_quickstart.html">官方 Elasticsearch-PHP API 中文文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Elasticsearch - 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 集成 CAT 全链路监控</title>
      <link href="/2021/11/26/spring-boot-ji-cheng-cat-quan-lian-lu-jian-kong/"/>
      <url>/2021/11/26/spring-boot-ji-cheng-cat-quan-lian-lu-jian-kong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、编写一个-springboot-与-cat-整合的案例"><a href="#一、编写一个-springboot-与-cat-整合的案例" class="headerlink" title="一、编写一个 springboot 与 cat 整合的案例"></a>一、编写一个 springboot 与 cat 整合的案例</h2><h3 id="将-cat-client-通过源码安装到本地仓库"><a href="#将-cat-client-通过源码安装到本地仓库" class="headerlink" title="将 cat-client 通过源码安装到本地仓库"></a>将 cat-client 通过源码安装到本地仓库</h3><ul><li>cat-client的源码路径：cat/lib/java</li><li>进入源码路径后，执行命令：<pre class="line-numbers language-none"><code class="language-none">mvn clean install -DskipTests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>安装成功后，在本地仓库就存在 cat-client-3.0.0.jar 包了</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-10.png"></p><h3 id="CAT客户端-Demo"><a href="#CAT客户端-Demo" class="headerlink" title="CAT客户端 Demo"></a>CAT客户端 Demo</h3><h4 id="maven-引入-cat-客户端包，在-pom-xml-加入"><a href="#maven-引入-cat-客户端包，在-pom-xml-加入" class="headerlink" title="maven 引入 cat 客户端包，在 pom.xml 加入"></a>maven 引入 cat 客户端包，在 pom.xml 加入</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt;    &lt;artifactId&gt;cat-client&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置domain"><a href="#配置domain" class="headerlink" title="配置domain"></a>配置domain</h4><ul><li>在资源文件中新建app.properties文件</li></ul><p>在resources资源文件META-INF下，注意是src/main/resources/META-INF/文件夹，加上domain配置，如：app.name=spring-boot-cat-simple</p><ul><li>接着我们以一个简单的接口测试演练下，项目结构如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-dashboard-5.png"></p><p>HelloController 类</p><pre class="line-numbers language-none"><code class="language-none">package com.zq.controller;import com.zq.service.CatService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;// @RestController 的意思是 Controller 里面的方法都以 json 格式输出@RestControllerpublic class HelloController {    @Autowired    private CatService catServiceImpl;    @RequestMapping("/hello")    public String index(HttpServletRequest request) {        String url = request.getRequestURL().toString();        return catServiceImpl.hello(url);    }    @RequestMapping("/error")    public String error(HttpServletRequest request) {        String url = request.getRequestURL().toString();        return catServiceImpl.error(url);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Service 类</p><pre class="line-numbers language-none"><code class="language-none">package com.zq.service.impl;import com.dianping.cat.Cat;import com.dianping.cat.message.Transaction;import com.zq.service.CatService;import org.springframework.stereotype.Service;@Servicepublic class CatServiceImpl implements CatService {    @Override    public String hello(String url) {        // 创建一个 Transaction        Transaction transaction = Cat.newTransaction("URL", url);        try {            // 处理业务            myBusiness();            // 设置成功状态            transaction.setStatus(Transaction.SUCCESS);        } catch (Exception e) {            // 设置错误状态            transaction.setStatus(e);            // 记录错误信息            Cat.logError(e);        } finally {            // 结束 Transaction            transaction.complete();        }        return "hello";    }    @Override    public String error(String url) {        // 创建一个 Transaction        Transaction transaction = Cat.newTransaction("URL", url);        try {            // 处理业务            int i = 1 / 0;            // 设置成功状态            transaction.setStatus(Transaction.SUCCESS);        } catch (Exception e) {            // 设置错误状态            transaction.setStatus(e);            // 记录错误信息            Cat.logError(e);        } finally {            // 结束 Transaction            transaction.complete();        }        return "error";    }    private void myBusiness() {        // 模拟业务处理时间        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>请求：<a href="http://localhost:8900/hello">http://localhost:8900/hello</a></p></li><li><p>请求：<a href="http://localhost:8900/hello/error">http://localhost:8900/hello/error</a></p></li></ul><h2 id="二、查看监控信息"><a href="#二、查看监控信息" class="headerlink" title="二、查看监控信息"></a>二、查看监控信息</h2><p>进入 cat 控制台，点击 Transaction 按钮 ，之后点击全部，会看到有哪些客户端，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-dashboard-1.png"></p><p>点击客户端 spring-boot-cat-simple ，出现如图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-dashboard-2.png"></p><p>接着再点击 URL 的 Type </p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-dashboard-3.png"></p><p>如上图，可以清晰的看到 请求的 总个数（tatal）、均值（avg）、最大/最小（max/min)、标准差（std）等，其他都比较直观</p><p>点击 “log View” 可以查看 错误信息，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-dashboard-4.png"></p><h2 id="三、源码"><a href="#三、源码" class="headerlink" title="三、源码"></a>三、源码</h2><ul><li><a href="https://github.com/dendi875/spring-boot-study/tree/main/spring-boot-cat-simple">spring-boot-cat-simple</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> CAT </tag>
            
            <tag> JAVA </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAT服务端安装</title>
      <link href="/2021/11/26/cat-fu-wu-duan-an-zhuang/"/>
      <url>/2021/11/26/cat-fu-wu-duan-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="我的本地开发环境"><a href="#我的本地开发环境" class="headerlink" title="我的本地开发环境"></a>我的本地开发环境</h2><ul><li>操作系统： macOS Catalina 10.15.6</li><li>IDE： Intelij IDEA</li><li>JDK版本：1.8</li><li>Mysql： 5.7.21</li><li>Maven： 3.6.3</li><li>Server version: Apache Tomcat/8.5.70</li></ul><h2 id="一、Cat-源代码下载"><a href="#一、Cat-源代码下载" class="headerlink" title="一、Cat 源代码下载"></a>一、Cat 源代码下载</h2><p>下载地址：<a href="https://github.com/dianping/cat">https://github.com/dianping/cat</a></p><ul><li>cat源码：下载 master 分支代码 </li><li>cat依赖包：下载 mvn-repo 分支代码</li></ul><h2 id="二、在本地打-cat-的-war-包"><a href="#二、在本地打-cat-的-war-包" class="headerlink" title="二、在本地打 cat 的 war 包"></a>二、在本地打 cat 的 war 包</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20211126145728.png"></p><h3 id="在cat工程执行编译命令"><a href="#在cat工程执行编译命令" class="headerlink" title="在cat工程执行编译命令"></a>在cat工程执行编译命令</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># zhangquan @ MacBook-Pro in ~/docker-php-dev/www/github/cat on git:master x [20:29:15] C:1$ mvn clean compile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>报错1：Could not find artifact org.unidal.framework:foundation-service:jar:2.5.0</li></ul><pre class="line-numbers language-none"><code class="language-none">[ERROR] Failed to execute goal on project cat-core: Could not resolve dependencies for project com.dianping.cat:cat-core:jar:3.0.0: The following artifacts could not be resolved: org.unidal.framework:foundation-service:jar:2.5.0, org.unidal.framework:web-framework:jar:2.4.0, org.unidal.framework:dal-jdbc:jar:2.4.0: Could not find artifact org.unidal.framework:foundation-service:jar:2.5.0 in alimaven (http://maven.aliyun.com/nexus/content/groups/public) -&gt; [Help 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解决：将下载的mvn-repo分支解压，放入到本地的.m2仓库中；</p><p>本地 mvn-repo 分支解压，解压出org目录，并将org目录拷贝到本地的.m2仓库中</p><pre class="line-numbers language-none"><code class="language-none">$ ll ~/.m2/repository/org/unidal drwxrwxr-x@  3 zhangquan  180847186    96B 11 14  2017 eunitdrwxrwxr-x@ 11 zhangquan  180847186   352B 11 14  2017 frameworkdrwxrwxr-x@  4 zhangquan  180847186   128B 11 23 20:31 mavendrwxrwxr-x@  9 zhangquan  180847186   288B 11 14  2017 webres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再执行编译命令：</p><ul><li>报错2：Could not find artifact org.codehaus.plexus:plexus-container-default:jar:3.1.0</li></ul><pre class="line-numbers language-none"><code class="language-none">[ERROR] Failed to execute goal org.unidal.maven.plugins:codegen-maven-plugin:2.5.8:dal-model (generate data model) on project cat-client: Execution generate data model of goal org.unidal.maven.plugins:codegen-maven-plugin:2.5.8:dal-model failed: Plugin org.unidal.maven.plugins:codegen-maven-plugin:2.5.8 or one of its dependencies could not be resolved: Could not find artifact org.codehaus.plexus:plexus-container-default:jar:3.1.0 in unidal (http://unidal.org/nexus/content/repositories/releases/) -&gt; [Help 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决：在.m2仓库找到org.unidal.maven.plugins:codegen-maven-plugin:2.5.8版本的pom文件codegen-maven-plugin-2.5.8.pom用idea打开，点击父引用的default，跳转到default-2.5.8.pom文件中，将文件中foundation-service.version从3.1.0版本修改为4.0.0版本；</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-2.png"></p><p>再执行编译命令：编译即可成功</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-3.png"></p><h3 id="在cat根目录执行install命令"><a href="#在cat根目录执行install命令" class="headerlink" title="在cat根目录执行install命令"></a>在cat根目录执行install命令</h3><pre class="line-numbers language-none"><code class="language-none"># zhangquan @ MacBook-Pro in ~/docker-php-dev/www/github/cat on git:master x [20:49:13] C:130$ mvn clean install -DskipTests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>报错：Failure to find org.unidal.framework:test-framework:jar:2.4.0</p><pre class="line-numbers language-none"><code class="language-none">[ERROR] Failed to execute goal on project cat-client: Could not resolve dependencies for project com.dianping.cat:cat-client:jar:3.0.0: Failure to find org.unidal.framework:test-framework:jar:2.4.0 in http://unidal.org/nexus/content/repositories/releases/ was cached in the local repository, resolution will not be reattempted until the update interval of unidal has elapsed or updates are forced -&gt; [Help 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决：修改cat根目录的pom.xml文件中test-framework的版本，改为2.5.0</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-4.png"></p><p>再执行install命令：安装成功</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-5.png"></p><p>install成功后，将cat-home-3.0.0.war修改为cat.war</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20211126151958.png"></p><h3 id="查看每个module具体生效的pom信息"><a href="#查看每个module具体生效的pom信息" class="headerlink" title="查看每个module具体生效的pom信息"></a>查看每个module具体生效的pom信息</h3><p>在cat根目录执行命令：打开cat.txt，即可看到cat-home定义的version</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mvn help:effective-pom &gt; cat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、服务端安装和配置"><a href="#三、服务端安装和配置" class="headerlink" title="三、服务端安装和配置"></a>三、服务端安装和配置</h2><h3 id="安装CAT的数据库"><a href="#安装CAT的数据库" class="headerlink" title="安装CAT的数据库"></a>安装CAT的数据库</h3><ul><li>创建数据库，数据库名cat，数据库编码使用utf8mb4，否则可能造成中文乱码等问题；</li></ul><pre class="line-numbers language-none"><code class="language-none">CREATE DATABASE `cat` DEFAULT CHARACTER SET utf8mb4 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将 cat工程中，script目录中的 sql 拷贝到cat数据库运行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20211126152613.png"></p><p>sql拷贝到cat数据库运行，初始化数据表；</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20211126152731.png"></p><p>由于MySQL的系统参数max_allowed_packet默认配置较小，可能会限制server接受的数据包大小，有时候大的插入和更新会被max_allowed_packet 参数限制掉，导致失败，所以要修改max_allowed_packet的值，修改后需要重启mysql；</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-9.png"></p><h3 id="Cat配置文件"><a href="#Cat配置文件" class="headerlink" title="Cat配置文件"></a>Cat配置文件</h3><p>创建以下两个目录：</p><ul><li>/data/appdatas/cat</li><li>/data/applogs/cat </li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-6.png"></p><p>在 /data/appdatas/cat 目录中，添加 client.xml，datasources.xml 配置文件</p><p>client.xml配置</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;config mode="client"&gt;    &lt;servers&gt;          &lt;!-- 服务端地址, 端口固定--&gt;  &lt;!-- 如果有多个Server, 就继续增加相应的节点配置 --&gt;  &lt;!-- 这是告诉客户端应该去链接哪个服务端，从哪个服务端里获取配置信息 ，相关源码也在 DefaultClientConfigManager中 --&gt;  &lt;!--将172.16.48.114修改为部署CAT的内网IP,请不要写127.0.0.1和外网IP --&gt; &lt;server ip="172.16.48.114" port="2280" http-port="8080" /&gt;    &lt;/servers&gt;&lt;/config&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>datasources.xml配置文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;data-sources&gt;    &lt;data-source id="cat"&gt;        &lt;maximum-pool-size&gt;3&lt;/maximum-pool-size&gt;        &lt;connection-timeout&gt;1s&lt;/connection-timeout&gt;        &lt;idle-timeout&gt;10m&lt;/idle-timeout&gt;        &lt;statement-cache-size&gt;1000&lt;/statement-cache-size&gt;        &lt;properties&gt;            &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;            &lt;url&gt;&lt;![CDATA[jdbc:mysql://www.myvbox.com:3306/cat]]&gt;&lt;/url&gt;  &lt;!-- 请替换为真实数据库URL及Port  --&gt;            &lt;user&gt;root&lt;/user&gt;  &lt;!-- 请替换为真实数据库用户名  --&gt;            &lt;password&gt;123456&lt;/password&gt;  &lt;!-- 请替换为真实数据库密码  --&gt;            &lt;connectionProperties&gt;&lt;![CDATA[useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;socketTimeout=120000]]&gt;&lt;/connectionProperties&gt;        &lt;/properties&gt;    &lt;/data-source&gt;&lt;/data-sources&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tomcat启动cat项目"><a href="#tomcat启动cat项目" class="headerlink" title="tomcat启动cat项目"></a>tomcat启动cat项目</h3><p>将cat.war拷贝到tomcat的webapps目录，再启动tomcat；</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-7.png"></p><p>运行命令启动 tomcat</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/cat-8.png"></p><p>启动成功后，访问：<a href="http://localhost:8080/cat/r">http://localhost:8080/cat/r</a></p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20211126153830.png"></p><h3 id="按照实际需要，修改服务端配置和客户端路由"><a href="#按照实际需要，修改服务端配置和客户端路由" class="headerlink" title="按照实际需要，修改服务端配置和客户端路由"></a>按照实际需要，修改服务端配置和客户端路由</h3><p>使用admin/admin登录</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20211126154013.png"></p><p>进入【服务端配置】页面修改IP地址：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;server-config&gt;   &lt;server id="default"&gt;      &lt;properties&gt;         &lt;property name="local-mode" value="true"/&gt;         &lt;property name="job-machine" value="true"/&gt;         &lt;property name="send-machine" value="false"/&gt;         &lt;property name="alarm-machine" value="false"/&gt;         &lt;property name="hdfs-enabled" value="false"/&gt;         &lt;property name="remote-servers" value="172.16.48.114:8080"/&gt;      &lt;/properties&gt;      &lt;storage local-base-dir="/data/appdatas/cat/bucket/" max-hdfs-storage-time="15" local-report-storage-time="2" local-logivew-storage-time="1" har-mode="true" upload-thread="5"&gt;         &lt;hdfs id="dump" max-size="128M" server-uri="hdfs://127.0.0.1/" base-dir="/user/cat/dump"/&gt;         &lt;harfs id="dump" max-size="128M" server-uri="har://127.0.0.1/" base-dir="/user/cat/dump"/&gt;         &lt;properties&gt;            &lt;property name="hadoop.security.authentication" value="false"/&gt;            &lt;property name="dfs.namenode.kerberos.principal" value="hadoop/dev80.hadoop@testserver.com"/&gt;            &lt;property name="dfs.cat.kerberos.principal" value="cat@testserver.com"/&gt;            &lt;property name="dfs.cat.keytab.file" value="/data/appdatas/cat/cat.keytab"/&gt;            &lt;property name="java.security.krb5.realm" value="value1"/&gt;            &lt;property name="java.security.krb5.kdc" value="value2"/&gt;         &lt;/properties&gt;      &lt;/storage&gt;      &lt;consumer&gt;         &lt;long-config default-url-threshold="1000" default-sql-threshold="100" default-service-threshold="50"&gt;            &lt;domain name="cat" url-threshold="500" sql-threshold="500"/&gt;            &lt;domain name="OpenPlatformWeb" url-threshold="100" sql-threshold="500"/&gt;         &lt;/long-config&gt;      &lt;/consumer&gt;   &lt;/server&gt;   &lt;server id="172.16.48.114"&gt;      &lt;properties&gt;         &lt;property name="job-machine" value="true"/&gt;         &lt;property name="send-machine" value="false"/&gt;         &lt;property name="alarm-machine" value="true"/&gt;      &lt;/properties&gt;   &lt;/server&gt;&lt;/server-config&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入【客户端路由】页面修改IP地址：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/20211126154551.png"></p>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> CAT </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 系统在根目录创建文件夹</title>
      <link href="/2021/11/26/mac-xi-tong-zai-gen-mu-lu-chuang-jian-wen-jian-jia/"/>
      <url>/2021/11/26/mac-xi-tong-zai-gen-mu-lu-chuang-jian-wen-jian-jia/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Mac 操作系统挺适合开发者进行写代码，最近碰到了一个问题，问题是如何在 macOS 根目录创建文件夹。不同的 macOS 版本处理方式不同，下面我们展开讲一下</p><h3 id="二、为什么要在-Mac-根目录创建文件夹"><a href="#二、为什么要在-Mac-根目录创建文件夹" class="headerlink" title="二、为什么要在 Mac 根目录创建文件夹"></a>二、为什么要在 Mac 根目录创建文件夹</h3><p>有些场景程序需要访问根目录的特定文件夹，所以需要在 macOS 根目录创建文件夹。</p><p>比如 <code>Spring Boot</code> 工程在 Mac 操作系统本地运行时，公司会默指定 <code>/data0/log-data/</code> 类似的目录，来存储工程运行的日志。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/mac-1.png"></p><p>那怎么如何在 macOS 根目录创建文件夹，下面分不同的 macOS 版本来解决：</p><ul><li>macOS@Catalina 版本</li><li>macOS@Big Sur 版本</li></ul><h3 id="三、macOS-Catalina-版本的创建文件夹方法"><a href="#三、macOS-Catalina-版本的创建文件夹方法" class="headerlink" title="三、macOS@Catalina 版本的创建文件夹方法"></a>三、macOS@Catalina 版本的创建文件夹方法</h3><p>第一步：关闭电脑然后重启，重启时长按 command + R 键，启动内建的 macOS 恢复系统</p><p>第二步：从菜单栏找到终端工具，运行下面命令，然后重启：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">csrutil disable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令目的是关闭 SIP，SIP 全称为「System Integrity Protection」即「系统完整性保护」。可以通过 <code>csrutil status</code> 查看其 SIP 状态。</p><p>第三步：重启完后，先重新挂载根目录，打开终端工具运行下面命令即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo mount -uw /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第四步：创建对应的 <code>/Users/zhangquan/data</code>、<code>/Users/zhangquan/data0</code> 文件夹，然后将对应的文件目录软链接到根目录。运行下面命令即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir  /Users/zhangquan/datamkdir  /Users/zhangquan/data0sudo ln -s /Users/zhangquan/data /datasudo ln -s /Users/zhangquan/data0 /data0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：需要用软链接来解决，是因为在根目录直接创建文件夹的话，一旦重启电脑，之前创建的目录又是只读权限了。</p><p>最后，重新重启 command + R 键，启动内建的 macOS 恢复系统，重新打开 SIP：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">csrutil enable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="四、macOS-Big-Sur-版本的创建文件夹方法"><a href="#四、macOS-Big-Sur-版本的创建文件夹方法" class="headerlink" title="四、macOS@Big Sur 版本的创建文件夹方法"></a>四、macOS@Big Sur 版本的创建文件夹方法</h3><p>第一步：启动内建的 macOS 恢复系统，关闭 SIP<br>第二步：运行下面命令，修改 synthetic.conf 文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo vi /etc/synthetic.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三步：编辑该文件，输入下面内容，将对应的文件夹映射到根目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">data    /Users/zhangquan/datadata0   /Users/zhangquan/data0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：</p><ul><li>提前创建被映射的文件夹</li><li>中间是 Tab，不是空格<br>最后重启系统后，系统根目录就会出现了对应的文件夹，实现方式也是一个软链接的形式</li></ul><h3 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h3><ul><li>尽量不要再 mac 根目录操作一些命令，比如 chmod 等</li><li>SIP 打开后，及时关闭</li><li>mac 支持文件软链接形式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作积累 </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-结构型模式-外观模式 (Facade Pattern)</title>
      <link href="/2021/07/09/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-wai-guan-mo-shi-facade-pattern/"/>
      <url>/2021/07/09/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-wai-guan-mo-shi-facade-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式 (Facade Pattern)"></a>外观模式 (Facade Pattern)</h1><hr><h3 id="0-外观模式概述"><a href="#0-外观模式概述" class="headerlink" title="0. 外观模式概述"></a>0. 外观模式概述</h3><p>不知道大家有没有比较过自己泡茶和去茶馆喝茶的区别，如果是自己泡茶需要自行准备茶叶、茶具和开水，如图(A)所示，而去茶馆喝茶，最简单的方式就是跟茶馆服务员说想要一杯什么样的茶，是铁观音、碧螺春还是西湖龙井？正因为茶馆有服务员，顾客无须直接和茶叶、茶具、开水等交互，整个泡茶过程由服务员来完成，顾客只需与服务员交互即可，整个过程非常简单省事，如图(B)所示。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/tea.jpg" alt="tea"></p><p>在软件开发中，有时候为了完成一项较为复杂的功能，一个客户端类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户端类只需与该类交互。外观模式通过引入一个新的外观类(Facade)来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。在外观模式中，那些需要交互的业务类被称为子系统(Subsystem)。如果没有外观类，那么每个客户端类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大；而引入外观类之后，客户端类只需要直接与外观类交互，客户端类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度。</p><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><blockquote><p>外观模式 (Facade Pattern)：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></blockquote><p>外观模式又称为门面模式，它是一种<strong>对象结构型模式</strong>。</p><p>外观模式是<strong>迪米特法则</strong>的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户端类与子系统的耦合度。</p><h3 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h3><p>外观模式包含如下角色：</p><ul><li><p><code>Facade</code>：<strong>外观</strong></p><ul><li>客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li></ul></li><li><p><code>SubSystem</code>：<strong>子系统</strong></p><ul><li>在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/FacadePattern-0.png" alt="FacadePattern-0"></p><h3 id="3-模式实现"><a href="#3-模式实现" class="headerlink" title="3. 模式实现"></a>3. 模式实现</h3><ul><li><p>外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户端类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。</p></li><li><p>外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能。</p></li></ul><h3 id="4-外观模式应用实例"><a href="#4-外观模式应用实例" class="headerlink" title="4. 外观模式应用实例"></a>4. 外观模式应用实例</h3><p>下面通过一个实例进一步学习和理解外观模式。</p><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>现在需要开发一个文件加密功能，该功能可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件。这三个操作相对独立，为了实现代码的独立重用，让设计更符合<strong>单一职责原则</strong>，这三个操作的业务代码封装在三个不同的类中。</p><p>现使用外观模式设计该文件加密功能。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><ul><li>EncryptFacade：<code>外观类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * EncryptFacade 加密外观类。 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-05 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">EncryptFacade</span><span class="token punctuation">{</span>    <span class="token comment">/**     * @var FileReader     */</span>    <span class="token keyword">private</span> <span class="token variable">$fileReader</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @var CipherMachine     */</span>    <span class="token keyword">private</span> <span class="token variable">$cipherMachine</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @var FileWriter     */</span>    <span class="token keyword">private</span> <span class="token variable">$fileWriter</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">fileReader</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">cipherMachine</span> <span class="token operator">=</span> <span class="token class-name static-context">CipherMachine</span><span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">fileWriter</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">fileEncrypt</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$fileNameSrc</span><span class="token punctuation">,</span> <span class="token keyword type-hint">string</span> <span class="token variable">$fileNameDes</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token comment">/* 读取文件，获取明文 */</span>        <span class="token variable">$plainStr</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">fileReader</span><span class="token operator">-&gt;</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token variable">$fileNameSrc</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 数据加密，将明文转换为密文 */</span>        <span class="token variable">$encryptStr</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">cipherMachine</span><span class="token operator">-&gt;</span><span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token variable">$plainStr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 保存密文，写入文件 */</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">fileWriter</span><span class="token operator">-&gt;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$encryptStr</span><span class="token punctuation">,</span> <span class="token variable">$fileNameDes</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>FileReader、CipherMachine、FileWriter： <code>子系统类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * FileReader 文件读取类，充当子系统类。 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-05 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">FileReader</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">read</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$fileNameSrc</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$stream</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token variable">$fileNameSrc</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">stream_get_contents</span><span class="token punctuation">(</span><span class="token variable">$stream</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$stream</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> <span class="token variable">$ex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token variable">$str</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * CipherMachine 数据加密类，充当子系统类。 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-05 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">CipherMachine</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token variable">$iv</span> <span class="token operator">=</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token variable">$instance</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$ivlen</span> <span class="token operator">=</span> <span class="token function">openssl_cipher_iv_length</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'aes-256-ctr'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$iv</span> <span class="token operator">=</span> <span class="token function">openssl_random_pseudo_bytes</span><span class="token punctuation">(</span><span class="token variable">$ivlen</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">iv</span> <span class="token operator">=</span> <span class="token variable">$iv</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function-definition function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">self</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword static-context">self</span><span class="token operator">::</span><span class="token variable">$instance</span> <span class="token keyword">instanceof</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword static-context">self</span><span class="token operator">::</span><span class="token variable">$instance</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword static-context">self</span><span class="token operator">::</span><span class="token variable">$instance</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">encrypt</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$plainText</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">openssl_encrypt</span><span class="token punctuation">(</span><span class="token variable">$plainText</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'aes-256-ctr'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'secret'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">iv</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">decrypt</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$ciphertext</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">openssl_decrypt</span><span class="token punctuation">(</span><span class="token variable">$ciphertext</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'aes-256-ctr'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'secret'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">iv</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * FileWriter 文件保存类，充当子系统类。 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-05 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">FileWriter</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">write</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$ciphertext</span><span class="token punctuation">,</span> <span class="token keyword type-hint">string</span> <span class="token variable">$fileNameDes</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$handle</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token variable">$fileNameDes</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">,</span> <span class="token variable">$ciphertext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>加密文件<code>src.txt</code>内容为</li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost Facade-Pattern]# echo 'hello,world!' &gt;  src.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>客户端测试</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$encryptFacade</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EncryptFacade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$encryptFacade</span><span class="token operator">-&gt;</span><span class="token function">fileEncrypt</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'src.txt'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'des.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>加密后的<code>des.txt</code>内容为</li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost Facade-Pattern]# cat des.txtpw2x3UEeO8GVjum36A==<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><p>示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/FacadePattern-1.png" alt="FacadePattern-1"></p><h3 id="6-外观模式的优点"><a href="#6-外观模式的优点" class="headerlink" title="6. 外观模式的优点"></a>6. 外观模式的优点</h3><p>外观模式的主要优点如下：</p><p>(1)它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</p><p>(2)它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</p><p>(3)一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</p><h3 id="7-外观模式的缺点"><a href="#7-外观模式的缺点" class="headerlink" title="7. 外观模式的缺点"></a>7. 外观模式的缺点</h3><p>外观模式的主要缺点如下：</p><p>(1)不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</p><p>(2)增加新的子系统可能需要修改外观类的源代码，违背了<strong>开闭原则</strong>。</p><h3 id="8-外观模式适用场景"><a href="#8-外观模式适用场景" class="headerlink" title="8. 外观模式适用场景"></a>8. 外观模式适用场景</h3><p>在以下情况下可以考虑使用外观模式：</p><p>(1)当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</p><p>(2)客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</p><p>(3)在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-结构型模式-组合模式 (Composite Pattern)</title>
      <link href="/2021/07/08/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-zu-he-mo-shi-composite-pattern/"/>
      <url>/2021/07/08/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-zu-he-mo-shi-composite-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式 (Composite Pattern)"></a>组合模式 (Composite Pattern)</h1><hr><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>树形结构在软件中随处可见，例如操作系统中的目录结构、应用软件中的菜单、办公系统中的公司组织结构等等，如何运用面向对象的方式来处理这种树形结构是组合模式需要解决的问题，组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性地处理树形结构中的叶子节点（不包含子节点的节点）和树枝节点（包含子节点的节点）。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/tree.png" alt="tree"></p><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><blockquote><p>组合模式 (Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即树枝对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式。</p></blockquote><p>组合模式是一种<strong>对象结构型模式</strong>。</p><h3 id="2-组合模式结构"><a href="#2-组合模式结构" class="headerlink" title="2. 组合模式结构"></a>2. 组合模式结构</h3><p>组合模式包含如下角色：</p><ul><li><p><code>Component</code>：<strong>抽象构件</strong></p><ul><li>它可以是接口或抽象类，为树叶构件和树枝构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</li></ul></li><li><p><code>Leaf</code>：<strong>树叶构件</strong></p><ul><li>它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。</li></ul></li><li><p><code>Composite</code>：<strong>树枝构件</strong></p><ul><li>它在组合结构中表示树枝节点对象，树枝节点包含子节点，其子节点可以是叶子节点，也可以是树枝节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/Composite-Pattern-0.jpg" alt="Composite-Pattern-0.jpg"></p><h3 id="3-组合模式应用实例"><a href="#3-组合模式应用实例" class="headerlink" title="3. 组合模式应用实例"></a>3. 组合模式应用实例</h3><p>下面通过一个实例进一步学习和理解组合模式。</p><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在Dendi软件公司的内部办公系统OA系统中，有一个与公司组织结构对应的树形菜单，行政人员可以给各级单位下发通知，这些单位可以是总公司的一个部门，也可以是一个分公司，还可以是分公司的一个部门。用户只需要选择一个根节点即可实现通知的下发操作，而无须关心具体的实现细节。</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">└── Dendi公司北京总部    ├── 上海分公司    │&nbsp;&nbsp; ├── 上海分公司财务部    │&nbsp;&nbsp; ├── 上海分公司人力资源部    │&nbsp;&nbsp; └── 上海分公司研发部    ├── 深圳分公司    │&nbsp;&nbsp; ├── 深圳分公司财务部    │&nbsp;&nbsp; ├── 深圳分公司人力资源部    │&nbsp;&nbsp; └── 深圳分公司研发部    ├── 总公司财务部    ├── 总公司人力资源部    └── 总公司研发部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><ul><li>Units：<code>抽象构件</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 抽象单位类：抽象构件 * 这里单位即可以是某个部门，也可以某个公司 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-07-22 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">Units</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">name</span> <span class="token operator">=</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* 下发通知 */</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">sendNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Company： <code>树枝构件角色</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 公司类：树枝构件角色 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-07-22 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Company</span> <span class="token keyword">extends</span> <span class="token class-name">Units</span><span class="token punctuation">{</span>    <span class="token comment">/**     * 单位的集合，用于存储Units类型的成员     *     * @var array     */</span>    <span class="token keyword">private</span> <span class="token variable">$unitList</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Units</span> <span class="token variable">$u</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">unitList</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$u</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">remove</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Units</span> <span class="token variable">$u</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$key</span> <span class="token operator">=</span> <span class="token function">array_search</span><span class="token punctuation">(</span><span class="token variable">$u</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">unitList</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$key</span> <span class="token operator">!==</span> <span class="token constant boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">unset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">unitList</span><span class="token punctuation">[</span><span class="token variable">$key</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getChild</span><span class="token punctuation">(</span><span class="token keyword type-hint">int</span> <span class="token variable">$i</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">unitList</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">sendNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"*****%s收到通知*****\n"</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 递归调用子构件的sendNotify()方法 */</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">unitList</span> <span class="token keyword">as</span> <span class="token variable">$unit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$unit</span><span class="token operator">-&gt;</span><span class="token function">sendNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ResearchDepartment、FinanceDepartment、HRDepartment： <code>树叶构件角色</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 研发部：树叶构件角色 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-07-22 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">ResearchDepartment</span> <span class="token keyword">extends</span> <span class="token class-name">Units</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">sendNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"-----%s收到通知-----\n"</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 财务部：树叶构件角色 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-07-22 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">FinanceDepartment</span> <span class="token keyword">extends</span> <span class="token class-name">Units</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">sendNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"-----%s收到通知-----\n"</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 人力资源部：树叶构件角色 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-07-22 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">HRDepartment</span> <span class="token keyword">extends</span> <span class="token class-name">Units</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">sendNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"-----%s收到通知-----\n"</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端测试代码</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 客户端测试代码 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-07-22 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Client</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$rootCompany</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Dendi公司北京总部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shangHaiCompany</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"上海分公司"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shenZhenCompany</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"深圳分公司"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootRD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResearchDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"总公司研发部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootFD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinanceDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"总公司财务部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootHRD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HRDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"总公司人力资源部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shangHaiRD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResearchDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"上海分公司研发部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shangHaiFD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinanceDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"上海分公司财务部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shangHaiHRD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HRDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"上海分公司人力资源部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shenZhenRD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResearchDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"深圳分公司研发部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shenZhenFD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinanceDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"深圳分公司财务部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shenZhenHRD</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HRDepartment</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"深圳分公司人力资源部"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shangHaiCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shangHaiRD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shangHaiCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shangHaiFD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shangHaiCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shangHaiHRD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shenZhenCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shenZhenRD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shenZhenCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shenZhenFD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$shenZhenCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shenZhenHRD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$rootRD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$rootFD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$rootHRD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shangHaiCompany</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rootCompany</span><span class="token operator">-&gt;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$shenZhenCompany</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//从"北京总部"节点开始下发通知</span>        <span class="token variable">$rootCompany</span><span class="token operator">-&gt;</span><span class="token function">sendNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>以上例程会输出：<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span>Dendi公司北京总部收到通知<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>总公司研发部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>总公司财务部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>总公司人力资源部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span>上海分公司收到通知<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>上海分公司研发部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>上海分公司财务部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>上海分公司人力资源部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span>深圳分公司收到通知<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>深圳分公司研发部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>深圳分公司财务部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>深圳分公司人力资源部收到通知<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-UML类图"><a href="#4-UML类图" class="headerlink" title="4. UML类图"></a>4. UML类图</h3><p>示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/Composite-Pattern-1.png" alt="Composite-Pattern-1"></p><h3 id="5-组合模式总结"><a href="#5-组合模式总结" class="headerlink" title="5. 组合模式总结"></a>5. 组合模式总结</h3><ul><li><p>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表树枝，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是树枝，可以对其进行统一处理。同时树枝对象与抽象构件类之间还建立一个聚合关联关系，在树枝对象中既可以包含叶子，也可以包含树枝，以此实现递归组合，形成一个树形结构。</p></li><li><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式：</p></li></ul><p>(1)透明组合模式<br>透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()等方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与树枝对象所提供的方法是一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式，因为在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示。</p><p>(2)安全组合模式<br>安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。</p><p>安全组合模式的缺点是不够透明，因为叶子构件和树枝构件具有不同的方法，且树枝构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和树枝构件。在实际应用中，安全组合模式的使用频率也非常高。</p><h3 id="6-组合模式的优点"><a href="#6-组合模式的优点" class="headerlink" title="6. 组合模式的优点"></a>6. 组合模式的优点</h3><p>组合模式的主要优点如下：</p><p>(1)组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</p><p>(2)客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</p><p>(3)在组合模式中增加新的树枝构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</p><p>(4)组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和树枝对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</p><h3 id="7-组合模式的缺点"><a href="#7-组合模式的缺点" class="headerlink" title="7. 组合模式的缺点"></a>7. 组合模式的缺点</h3><p>组合模式的主要缺点如下：</p><p>在增加新构件时很难对树枝构件中的构件类型进行限制。有时候我们希望一个树枝构件中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。</p><h3 id="8-组合模式适用场景"><a href="#8-组合模式适用场景" class="headerlink" title="8.组合模式适用场景"></a>8.组合模式适用场景</h3><p>在以下情况下可以考虑使用组合模式：</p><p>(1)在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。</p><p>(2)在一个使用面向对象语言开发的系统中需要处理一个树形结构。</p><p>(3)在一个系统中能够分离出叶子对象和树枝对象，而且它们的类型不固定，需要增加一些新的类型。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-结构型模式-装饰模式 (Decorator Pattern)</title>
      <link href="/2021/07/06/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-zhuang-shi-mo-shi-decorator-pattern/"/>
      <url>/2021/07/06/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-zhuang-shi-mo-shi-decorator-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰模式-Decorator-Pattern"><a href="#装饰模式-Decorator-Pattern" class="headerlink" title="装饰模式 (Decorator Pattern)"></a>装饰模式 (Decorator Pattern)</h1><hr><h3 id="0、早餐店的故事"><a href="#0、早餐店的故事" class="headerlink" title="0、早餐店的故事"></a>0、早餐店的故事</h3><ul><li>我们借助早餐店的故事来认识一下装饰模式。小张刚创业一个人开了一家早餐店提供煎饼、手抓饼出售，现在需要实现一个制作面饼的系统。</li></ul><blockquote><ul><li>实现方案</li></ul></blockquote><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** * 一个各种面饼的制作接口 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-30 13:55:28 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">interface</span> <span class="token class-name-definition class-name">Pie</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 煎饼套餐：加鸡蛋、香肠、番茄酱 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-30 14:16:40 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">JianBing</span> <span class="token keyword">implements</span> <span class="token class-name">Pie</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"普通的煎饼"</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">attachEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token operator">-&gt;</span><span class="token function">attachSausage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token operator">-&gt;</span><span class="token function">attachKetchup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+鸡蛋"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachSausage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+香肠"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachKetchup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+番茄酱"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 手抓饼套餐：加鸡蛋、油条、辣椒酱 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-30 13:58:45 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">ShouZhuaBing</span> <span class="token keyword">implements</span> <span class="token class-name">Pie</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"普通的手抓饼"</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">attachEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token operator">-&gt;</span><span class="token function">attachCruller</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token operator">-&gt;</span><span class="token function">attachChiliPaste</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+鸡蛋"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachCruller</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+油条"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachChiliPaste</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+辣椒酱"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 早餐类，出售各种面饼 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-30 14:03:50 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Breakfast</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token variable">$pie</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Pie</span> <span class="token variable">$pie</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">pie</span> <span class="token operator">=</span> <span class="token variable">$pie</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">pie</span><span class="token operator">-&gt;</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//Client 调用</span><span class="token variable">$breakfastOne</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Breakfast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JianBing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$breakfastOne</span><span class="token operator">-&gt;</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//普通的煎饼+鸡蛋+香肠+番茄酱</span><span class="token variable">$breakfastTwo</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Breakfast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShouZhuaBing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$breakfastTwo</span><span class="token operator">-&gt;</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//普通的手抓饼+鸡蛋+油条+辣椒酱</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li><p>由于小张每天起早贪黑的努力工作生意越来越好，娶上了媳妇现在多了一个帮手，小张想要扩张一下出售面饼的各类，还想要出售鸡蛋灌饼、葱花鸡蛋饼等。原来的面饼系统就出现了一些问题</p><ul><li>每增加一种面饼种类就要增加一个该面饼的实现类。</li><li>随着面饼种类越来越多类的数量也就越多，类的维护成本就很大。</li><li>面饼的制作不够灵活，制作方法里硬编码了制作的配料。</li><li>公用的配料制作方法没有得到复用，比如鸡蛋配料方法。</li></ul></li><li><p>问：那小张该如何做？</p><ul><li>答：请看下面的<strong>装饰模式</strong></li></ul></li></ul><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>装饰模式 (Decorator Pattern)：它属于对象<strong>结构型模式</strong>。动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。</p><h3 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h3><p>装饰模式包含如下角色：</p><ul><li><p><code>Component</code>：抽象构件类</p><ul><li>定义一个对象接口，可以给这些对象动态地添加职责（方法）。</li></ul></li><li><p><code>ConcreteComponent</code>：具体构件类</p><ul><li>定义了具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</li></ul></li><li><p><code>Decorator</code>：抽象装饰类</p><ul><li>抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。</li></ul></li><li><p><code>ConcreteDecorator</code>：具体装饰类</p><ul><li>具体装饰类是抽象装饰类的子类，负责向构件中添加新的职责。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/DecoratorPattern-0.png" alt="DecoratorPattern-0.png"></p><h3 id="3-装饰模式实现的面饼系统代码示例"><a href="#3-装饰模式实现的面饼系统代码示例" class="headerlink" title="3. 装饰模式实现的面饼系统代码示例"></a>3. 装饰模式实现的面饼系统代码示例</h3><ul><li>Grain：抽象构件类</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 一个制作杂粮的接口 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 12:14:38 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">interface</span> <span class="token class-name-definition class-name">Grain</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>JianBing、ShouZhuaBing：具体构件类</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 煎饼类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 12:14:38 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">JianBing</span> <span class="token keyword">implements</span> <span class="token class-name">Grain</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"普通的煎饼"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 手抓饼类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 12:14:38 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">ShouZhuaBing</span> <span class="token keyword">implements</span> <span class="token class-name">Grain</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"普通的手抓饼"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>GrainDecorator：抽象装饰类</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 面饼装饰抽象类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 13:14:42 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">GrainDecorator</span> <span class="token keyword">implements</span> <span class="token class-name">Grain</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$grain</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Grain</span> <span class="token variable">$grain</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">grain</span> <span class="token operator">=</span> <span class="token variable">$grain</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">grain</span><span class="token operator">-&gt;</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Egg、Sausage、Ketchup、Cruller、ChiliPaste：具体装饰类</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token operator">**</span> <span class="token operator">*</span> 鸡蛋装饰类 <span class="token operator">*</span> <span class="token operator">*</span> @author     <span class="token operator">&lt;</span>dendi875@<span class="token number">163.</span>com<span class="token operator">&gt;</span> <span class="token operator">*</span> @createDate <span class="token number">2018</span><span class="token operator">-</span><span class="token number">03</span><span class="token operator">-</span><span class="token number">31</span> <span class="token number">13</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">42</span> <span class="token operator">*</span> @copyright  <span class="token function">Copyright</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2018</span> dendi875@<span class="token number">163.</span>com <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Egg</span> <span class="token keyword">extends</span> <span class="token class-name">GrainDecorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Grain</span> <span class="token variable">$grain</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$grain</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">attachEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+鸡蛋"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 香肠装饰类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 13:15:54 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Sausage</span> <span class="token keyword">extends</span> <span class="token class-name">GrainDecorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Grain</span> <span class="token variable">$grain</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$grain</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">attachSausage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachSausage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+香肠"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 番茄酱装饰类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 13:16:36 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Ketchup</span> <span class="token keyword">extends</span> <span class="token class-name">GrainDecorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Grain</span> <span class="token variable">$grain</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$grain</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">attachKetchup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachKetchup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+番茄酱"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 油条装饰类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 13:16:55 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Cruller</span> <span class="token keyword">extends</span> <span class="token class-name">GrainDecorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Grain</span> <span class="token variable">$grain</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$grain</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">attachCruller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachCruller</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+油条"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 辣椒酱装饰类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 13:17:17 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">ChiliPaste</span> <span class="token keyword">extends</span> <span class="token class-name">GrainDecorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Grain</span> <span class="token variable">$grain</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$grain</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">attachChiliPaste</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">attachChiliPaste</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"+辣椒酱"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-客户端的使用"><a href="#4-客户端的使用" class="headerlink" title="4. 客户端的使用"></a>4. 客户端的使用</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 早餐类，出售各种面饼 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-31 13:22:19 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Breakfast</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token variable">$grain</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token class-name type-declaration">Grain</span> <span class="token variable">$grain</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">grain</span> <span class="token operator">=</span> <span class="token variable">$grain</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">grain</span><span class="token operator">-&gt;</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//Client 调用</span><span class="token comment">//制作一套煎饼</span><span class="token variable">$pie</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ketchup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Sausage</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Egg</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JianBing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$breakfast</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Breakfast</span><span class="token punctuation">(</span><span class="token variable">$pie</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$breakfast</span><span class="token operator">-&gt;</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//普通的煎饼+鸡蛋+香肠+番茄酱</span><span class="token comment">//Client 调用</span><span class="token comment">//制作一套手抓饼</span><span class="token variable">$pie</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChiliPaste</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cruller</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Egg</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShouZhuaBing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$breakfast</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Breakfast</span><span class="token punctuation">(</span><span class="token variable">$pie</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$breakfast</span><span class="token operator">-&gt;</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//普通的手抓饼+鸡蛋+油条+辣椒酱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><p>装饰模式实现的面饼系统示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/DecoratorPattern-1.png" alt="DecoratorPattern-1.png"></p><p>现在的面饼系统就变得强大了许多，可以按照顾客的需求用各种配料来装饰面饼而且装饰的顺序也很灵活，各种配料也能得以<strong>复用</strong>（同种配料可以被不同种类面饼利用），系统也很容易维护。</p><h3 id="6-模式分析"><a href="#6-模式分析" class="headerlink" title="6. 模式分析"></a>6. 模式分析</h3><ul><li>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。</li><li>装饰模式把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户端代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象。</li></ul><h3 id="7-装饰模式的优点"><a href="#7-装饰模式的优点" class="headerlink" title="7. 装饰模式的优点"></a>7. 装饰模式的优点</h3><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合<strong>开闭原则</strong>。</li><li>有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。</li></ul><h3 id="8-装饰模式的缺点"><a href="#8-装饰模式的缺点" class="headerlink" title="8. 装饰模式的缺点"></a>8. 装饰模式的缺点</h3><ul><li>使用装饰模式进行系统设计时将产生很多具体装饰类，将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><h3 id="9-适用场景"><a href="#9-适用场景" class="headerlink" title="9. 适用场景"></a>9. 适用场景</h3><p>以下情况可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul><h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h3><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类<code>Component</code>作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰。</li><li>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li><li>如果只有一个具体装饰类，那么就没有必要建立一个单独的<code>Decorator</code>，可以把<code>Decorator</code>和<code>ConcreteDecorator</code>的责任合并成一个类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-结构型模式-适配器模式 (Adapter Pattern)</title>
      <link href="/2021/07/01/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-gua-pei-qi-mo-shi-adapter-pattern/"/>
      <url>/2021/07/01/she-ji-mo-shi-zhi-jie-gou-xing-mo-shi-gua-pei-qi-mo-shi-adapter-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 (Adapter Pattern)"></a>适配器模式 (Adapter Pattern)</h1><hr><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>我的笔记本电脑的工作电压是20V，而我国的家庭用电是220V，如何让20V的笔记本电脑能够在220V的电压下工作？答案是引入一个电源适配器(AC Adapter)，俗称充电器或变压器，有了这个电源适配器，生活用电和笔记本电脑即可兼容，如图1所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/ac.jpg" alt="ac"></p><p>图1 电源适配器示意图</p><p>在软件开发中，有时也存在类似这种不兼容的情况，我们也可以像引入一个电源适配器一样引入一个称之为适配器的角色来协调这些存在不兼容的结构，这种设计方案即为适配器模式。</p><p>与电源适配器相似，在适配器模式中引入了一个被称为适配器(Adapter)的包装类，而它所包装的对象称为适配者(Adaptee)，即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。</p><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><blockquote><p>适配器模式 (Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p></blockquote><p>适配器模式既可以作为<strong>类结构型模式</strong>，也可以作为<strong>对象结构型模式</strong>。</p><ul><li>适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。</li><li>在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。</li><li>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高。</li></ul><h3 id="2-对象适配器模式结构"><a href="#2-对象适配器模式结构" class="headerlink" title="2. 对象适配器模式结构"></a>2. 对象适配器模式结构</h3><p>对象适配器模式包含如下角色：</p><ul><li><p><code>Target</code>：<strong>目标抽象类</strong></p><ul><li>目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li></ul></li><li><p><code>Adaptee</code>：<strong>适配者类</strong></p><ul><li>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体的类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li></ul></li><li><p><code>Adapter</code>：<strong>适配器类</strong></p><ul><li>适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Targe并关联一个Adaptee对象使二者产生联系。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/Adapter-Pattern-0.jpg" alt="Adapter-Pattern-0"></p><p>根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的specificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。</p><h3 id="3-适配器模式应用实例"><a href="#3-适配器模式应用实例" class="headerlink" title="3. 适配器模式应用实例"></a>3. 适配器模式应用实例</h3><p>下面通过一个实例进一步学习和理解适配器模式。</p><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><blockquote><p>Sunny软件公司在很久以前曾开发了一个算法库，里面包含了一些常用的算法，例如排序算法和查找算法，在进行各类软件开发时经常需要重用该算法库中的算法。在为某学校开发教务管理系统时，开发人员发现需要对学生成绩进行排序和查找，该系统的设计人员已经开发了一个成绩操作接口ScoreOperation，在该接口中声明了排序方法<code>arraySort(array $list): array</code>和查找方法<code>arraySearch(int $needle, array $haystack): int</code>，为了提高排序和查找的效率，开发人员决定重用算法库中的快速排序算法类QuickSort和二分查找算法类BinarySearch，其中QuickSort的<code>qSort(array $list): array</code>方法实现了快速排序，BinarySearch的<code>binsearch(array $arr, int $start, int $end, int $needle): int</code>方法实现了二分查找。</p></blockquote><p>由于某些原因，现在Sunny公司开发人员已经找不到该算法库的源代码，无法直接通过复制和粘贴操作来重用其中的代码；部分开发人员已经针对ScoreOperation接口编程，如果再要求对该接口进行修改或要求大家直接使用QuickSort类和BinarySearch类将导致大量代码需要修改。</p><p>Sunny软件公司开发人员面对这个没有源码的算法库，遇到一个幸福而又烦恼的问题：如何在既不修改现有接口又不需要任何算法库代码的基础上能够实现算法库的重用？</p><p>通过分析，我们不难得知，现在Sunny软件公司面对的问题有点类似本章最开始所提到的电压问题，成绩操作接口ScoreOperation好比只支持20V电压的笔记本，而算法库好比220V的家庭用电，这两部分都没有办法再进行修改，而且它们原本是两个完全不相关的结构，如图2所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/algorithm.jpg" alt="algorithm"></p><p>图2 需协调的两个系统的结构示意图</p><p>解决方案：我们需要ScoreOperation接口能够和已有算法库一起工作，让它们在同一个系统中能够兼容，最好的实现方法是增加一个类似电源适配器一样的适配器角色，通过适配器来协调这两个原本不兼容的结构。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><ul><li>ScoreOperation：<code>目标抽象类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 抽象成绩操作类：目标抽象类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-06-25 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">interface</span> <span class="token class-name-definition class-name">ScoreOperation</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">arraySort</span><span class="token punctuation">(</span><span class="token keyword type-hint">array</span> <span class="token variable">$list</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">array</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">arraySearch</span><span class="token punctuation">(</span><span class="token keyword type-hint">int</span> <span class="token variable">$needle</span><span class="token punctuation">,</span> <span class="token keyword type-hint">array</span> <span class="token variable">$haystack</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">int</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>QuickSort、BinarySearch： <code>适配者类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 快速排序类：适配者 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-06-25 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">QuickSort</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">qSort</span><span class="token punctuation">(</span><span class="token keyword type-hint">array</span> <span class="token variable">$list</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">array</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$list</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token variable">$list</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$baseValue</span> <span class="token operator">=</span> <span class="token variable">$list</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$leftArray</span> <span class="token operator">=</span> <span class="token variable">$rightArray</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$list</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$list</span> <span class="token keyword">as</span> <span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$value</span> <span class="token operator">&lt;</span> <span class="token variable">$baseValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$leftArray</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token variable">$rightArray</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token variable">$leftArray</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">qSort</span><span class="token punctuation">(</span><span class="token variable">$leftArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$rightArray</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">qSort</span><span class="token punctuation">(</span><span class="token variable">$rightArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">array_merge</span><span class="token punctuation">(</span><span class="token variable">$leftArray</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$baseValue</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$rightArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 二分查找类：适配者 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-06-25 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">BinarySearch</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">binsearch</span><span class="token punctuation">(</span><span class="token keyword type-hint">array</span> <span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token keyword type-hint">int</span> <span class="token variable">$start</span><span class="token punctuation">,</span> <span class="token keyword type-hint">int</span> <span class="token variable">$end</span><span class="token punctuation">,</span> <span class="token keyword type-hint">int</span> <span class="token variable">$needle</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">int</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$start</span> <span class="token operator">&gt;</span> <span class="token variable">$end</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$mid</span> <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$end</span> <span class="token operator">+</span> <span class="token variable">$start</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$mid</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token variable">$needle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">binsearch</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$start</span><span class="token punctuation">,</span> <span class="token variable">$end</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">$needle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$mid</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token variable">$needle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token function">binsearch</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$start</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">$end</span><span class="token punctuation">,</span> <span class="token variable">$needle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token variable">$mid</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>OperationAdapter： <code>适配器类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 操作适配器：适配器类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-06-25 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">OperationAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">ScoreOperation</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token variable">$sortObj</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token variable">$searchObj</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">sortObj</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">searchObj</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinarySearch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">arraySort</span><span class="token punctuation">(</span><span class="token keyword type-hint">array</span> <span class="token variable">$list</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">array</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">sortObj</span><span class="token operator">-&gt;</span><span class="token function">qSort</span><span class="token punctuation">(</span><span class="token variable">$list</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">arraySearch</span><span class="token punctuation">(</span><span class="token keyword type-hint">int</span> <span class="token variable">$needle</span><span class="token punctuation">,</span> <span class="token keyword type-hint">array</span> <span class="token variable">$haystack</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">int</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">searchObj</span><span class="token operator">-&gt;</span><span class="token function">binsearch</span><span class="token punctuation">(</span><span class="token variable">$haystack</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$haystack</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">$needle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端测试代码</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/* 定义成绩数组 */</span><span class="token variable">$scores</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">76</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$operation</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OperationAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token variable">$operation</span><span class="token operator">-&gt;</span><span class="token function">arraySort</span><span class="token punctuation">(</span><span class="token variable">$scores</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"成绩排序结果："</span><span class="token operator">.</span><span class="token function">implode</span><span class="token punctuation">(</span><span class="token string single-quoted-string">','</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//output：成绩排序结果：50,69,76,84,88,90,90,91,96</span><span class="token variable">$key1</span> <span class="token operator">=</span> <span class="token variable">$operation</span><span class="token operator">-&gt;</span><span class="token function">arraySearch</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$key2</span> <span class="token operator">=</span> <span class="token variable">$operation</span><span class="token operator">-&gt;</span><span class="token function">arraySearch</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$key3</span> <span class="token operator">=</span> <span class="token variable">$operation</span><span class="token operator">-&gt;</span><span class="token function">arraySearch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"查找成绩为90的索引位置："</span><span class="token operator">.</span><span class="token variable">$key1</span><span class="token punctuation">;</span>   <span class="token comment">//output：查找成绩为90的索引位置：5</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"查找成绩84的索引位置："</span><span class="token operator">.</span><span class="token variable">$key2</span><span class="token punctuation">;</span>   <span class="token comment">//output：查查找成绩84的索引位置：3</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"查找成绩100的索引位置："</span><span class="token operator">.</span><span class="token variable">$key3</span><span class="token punctuation">;</span>  <span class="token comment">//output：查找成绩100的索引位置：-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-UML类图"><a href="#4-UML类图" class="headerlink" title="4. UML类图"></a>4. UML类图</h3><p>示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/AdapterPattern-1.png" alt="AdapterPattern-1"></p><h3 id="5-适配器模式的优点"><a href="#5-适配器模式的优点" class="headerlink" title="5. 适配器模式的优点"></a>5. 适配器模式的优点</h3><p>适配器模式的主要优点如下：</p><p>(1)将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p><p>(2)增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p><p>(3)一个对象适配器可以把多个不同的适配者适配到同一个目标。</p><h3 id="6-适配器模式的缺点"><a href="#6-适配器模式的缺点" class="headerlink" title="6. 适配器模式的缺点"></a>6. 适配器模式的缺点</h3><p>类适配器模式的主要缺点如下：</p><p>(1)PHP不支持多继承，一次最多只能适配一个适配者类，不能同时适配多个适配者；但可以通过<code>Trait</code>来减少单继承的限制。</p><p>(2)适配者类不能为最终类，如在PHP中不能为final类；</p><p>对象适配器模式的缺点如下：</p><p>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><h3 id="7-适配器模式适用场景"><a href="#7-适配器模式适用场景" class="headerlink" title="7.适配器模式适用场景"></a>7.适配器模式适用场景</h3><p>在以下情况下可以考虑使用适配器模式：</p><p>(1)系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</p><p>(2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-创建型模式-原型模式 (Prototype Pattern)</title>
      <link href="/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-yuan-xing-mo-shi-prototype-pattern/"/>
      <url>/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-yuan-xing-mo-shi-prototype-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式 (Prototype Pattern)"></a>原型模式 (Prototype Pattern)</h1><hr><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>有些时候，我们需要创建多个类似的大对象，如果每次去new，初始化开销很大，这个时候我们先new一个模版对象，然后其它实例都去clone这个模版，这样可以节约不少性能。这个模版就是原型（Prototype）,原型模式比单纯的clone要稍微升级一下。</p><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>原型模式 (Prototype Pattern)：它属于对象<strong>创建型模式</strong>。用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h3 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h3><p>原型模式包含如下角色：</p><ul><li><p><code>Prototype</code>：<strong>抽象原型角色</strong></p><ul><li>声明一个克隆自身的接口。</li></ul></li><li><p><code>ConcretePrototype</code>：<strong>具体原型角色</strong></p><ul><li>实现一个克隆自身的操作。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/PrototypePattern-0.png" alt="PrototypePattern-0"></p><h3 id="3-浅复制和深复制"><a href="#3-浅复制和深复制" class="headerlink" title="3. 浅复制和深复制"></a>3. 浅复制和深复制</h3><p>用示例说明一下PHP中浅复制和深复制</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 员工类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-04-21 14:14:48 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Person</span><span class="token punctuation">{</span>    <span class="token comment">/**     * @var string     */</span>    <span class="token keyword">public</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @var Account     */</span>    <span class="token keyword">public</span> <span class="token variable">$account</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">,</span> <span class="token class-name type-declaration">Account</span> <span class="token variable">$account</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">name</span> <span class="token operator">=</span> <span class="token variable">$name</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">account</span> <span class="token operator">=</span> <span class="token variable">$account</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 账户类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-04-21 14:22:04 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Account</span><span class="token punctuation">{</span>    <span class="token comment">/**     * @var float     */</span>    <span class="token keyword">public</span> <span class="token variable">$balance</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token keyword type-hint">float</span> <span class="token variable">$balance</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">balance</span> <span class="token operator">=</span> <span class="token variable">$balance</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$p1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'小明'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token number">10000.00</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$p2</span> <span class="token operator">=</span> <span class="token keyword">clone</span> <span class="token variable">$p1</span><span class="token punctuation">;</span><span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">account</span><span class="token operator">-&gt;</span><span class="token property">balance</span> <span class="token operator">=</span> <span class="token number">20000.00</span><span class="token punctuation">;</span><span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">name</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'小王'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//小王</span><span class="token keyword">echo</span> <span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">account</span><span class="token operator">-&gt;</span><span class="token property">balance</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//20000</span><span class="token keyword">echo</span> <span class="token variable">$p2</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//小明</span><span class="token keyword">echo</span> <span class="token variable">$p2</span><span class="token operator">-&gt;</span><span class="token property">account</span><span class="token operator">-&gt;</span><span class="token property">balance</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//20000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例结果可以看出<code>$p2</code>对象是<code>$p1</code>clone后的一个副本，修改了<code>$p1</code>对象<code>name</code>值后<code>$p2</code>的<code>name</code>值并未改变（是我们所期望的），但<code>$p1</code>中的<code>account</code>属性是一个指向<code>Account</code>对象的引用，clone后<code>$p2</code>和原来的<code>$p1</code>的<code>account</code>还是指向同一个对象（这显然不是我们所期望的），这就是<strong>浅复制</strong></li></ul><p>改造<code>Person</code>类后的<strong>深复制</strong></p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 员工类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-04-21 14:14:48 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Person</span><span class="token punctuation">{</span>    <span class="token comment">/**     * @var string     */</span>    <span class="token keyword">public</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @var Account     */</span>    <span class="token keyword">public</span> <span class="token variable">$account</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">,</span> <span class="token class-name type-declaration">Account</span> <span class="token variable">$account</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">name</span> <span class="token operator">=</span> <span class="token variable">$name</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">account</span> <span class="token operator">=</span> <span class="token variable">$account</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">account</span> <span class="token operator">=</span> <span class="token keyword">clone</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">account</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$p1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'小明'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token number">10000.00</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$p2</span> <span class="token operator">=</span> <span class="token keyword">clone</span> <span class="token variable">$p1</span><span class="token punctuation">;</span><span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">account</span><span class="token operator">-&gt;</span><span class="token property">balance</span> <span class="token operator">=</span> <span class="token number">20000.00</span><span class="token punctuation">;</span><span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">name</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'小王'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//小王</span><span class="token keyword">echo</span> <span class="token variable">$p1</span><span class="token operator">-&gt;</span><span class="token property">account</span><span class="token operator">-&gt;</span><span class="token property">balance</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//20000</span><span class="token keyword">echo</span> <span class="token variable">$p2</span><span class="token operator">-&gt;</span><span class="token property">name</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//小明</span><span class="token keyword">echo</span> <span class="token variable">$p2</span><span class="token operator">-&gt;</span><span class="token property">account</span><span class="token operator">-&gt;</span><span class="token property">balance</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-基于深复制的原型模式示例"><a href="#4-基于深复制的原型模式示例" class="headerlink" title="4. 基于深复制的原型模式示例"></a>4. 基于深复制的原型模式示例</h3><p>我们现在正开发一个游戏，有不同的地图，地图大小都是一样的，并且都有海洋，但是不同的地图温度不一样。</p><ul><li>MapPrototype：抽象原型类</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 抽象地图原型类，地图有长、宽、海洋 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-04-21 13:45:27 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">MapPrototype</span><span class="token punctuation">{</span>    <span class="token comment">/**     * @var int     */</span>    <span class="token keyword">public</span> <span class="token variable">$width</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @var int     */</span>    <span class="token keyword">public</span> <span class="token variable">$height</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @var Sea     */</span>    <span class="token keyword">public</span> <span class="token variable">$sea</span><span class="token punctuation">;</span>    <span class="token comment">/**     * @param array $attributes     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setAttribute</span><span class="token punctuation">(</span><span class="token keyword type-hint">array</span> <span class="token variable">$attributes</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$attributes</span> <span class="token keyword">as</span> <span class="token variable">$key</span><span class="token operator">=&gt;</span><span class="token variable">$val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token variable">$key</span> <span class="token operator">=</span> <span class="token variable">$val</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @return void     */</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Map：具体原型类</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 具体原型类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-04-21 13:50:40 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Map</span> <span class="token keyword">extends</span> <span class="token class-name">MapPrototype</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">sea</span>  <span class="token operator">=</span> <span class="token keyword">clone</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">sea</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Sea：海洋类</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 海洋类 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-04-21 13:52:16 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Sea</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$color</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'蓝色'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-客户端的使用"><a href="#5-客户端的使用" class="headerlink" title="5. 客户端的使用"></a>5. 客户端的使用</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">//先创建一个原型对象</span><span class="token variable">$mapPrototype</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">;</span><span class="token variable">$mapPrototype</span><span class="token operator">-&gt;</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'width'</span><span class="token operator">=&gt;</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'height'</span><span class="token operator">=&gt;</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'sea'</span><span class="token operator">=&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Sea</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原型对象已经有了（模版已经有了），如果我们需要一个新的map对象只需要克隆一下模版就行</span><span class="token variable">$newMap1</span> <span class="token operator">=</span> <span class="token keyword">clone</span> <span class="token variable">$mapPrototype</span><span class="token punctuation">;</span><span class="token variable">$newMap1</span><span class="token operator">-&gt;</span><span class="token property">sea</span><span class="token operator">-&gt;</span><span class="token property">color</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'深蓝'</span><span class="token punctuation">;</span> <span class="token comment">//给第一张地图的海洋换个颜色</span><span class="token keyword">echo</span> <span class="token variable">$newMap1</span><span class="token operator">-&gt;</span><span class="token property">sea</span><span class="token operator">-&gt;</span><span class="token property">color</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//深蓝</span><span class="token comment">//需要第二张地图只需再克隆一下模版</span><span class="token variable">$newMap2</span> <span class="token operator">=</span> <span class="token keyword">clone</span> <span class="token variable">$mapPrototype</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$newMap2</span><span class="token operator">-&gt;</span><span class="token property">sea</span><span class="token operator">-&gt;</span><span class="token property">color</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span> <span class="token comment">//蓝色，可以看出修改地图1海洋颜色并不影响地图2的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们可以发现利用原型模式，只需要实例并初始化一个地图原型对象。以后如果需要生产一个新的地图对象，都可以直接通过clone原型对象产生。省去了重新初始化的过程。</li></ul><h3 id="6-UML类图"><a href="#6-UML类图" class="headerlink" title="6. UML类图"></a>6. UML类图</h3><p>原型模式实现的地图示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/PrototypePattern-1.png" alt="PrototypePattern-1"></p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul><li>原型模式是创建型模式的一种，其特点在于通过<strong>复制</strong>一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的<strong>原型</strong>，这个原型是可定制的。</li><li>原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-创建型模式-建造者模式 (Builder Pattern)</title>
      <link href="/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-jian-zao-zhe-mo-shi-builder-pattern/"/>
      <url>/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-jian-zao-zhe-mo-shi-builder-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式 (Builder Pattern)"></a>建造者模式 (Builder Pattern)</h1><hr><h3 id="0-建造者模式概述"><a href="#0-建造者模式概述" class="headerlink" title="0. 建造者模式概述"></a>0. 建造者模式概述</h3><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><blockquote><p>建造者模式 (Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>建造者模式又称为生成器模式，它是一种<strong>对象创建型模式</strong>。</p><h3 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h3><p>建造者模式包含如下角色：</p><ul><li><p><code>Builder</code>：<strong>抽象建造者</strong></p><ul><li>它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</li></ul></li><li><p><code>ConcreteBuilder</code>：<strong>具体建造者</strong></p><ul><li>它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</li></ul></li><li><p><code>Product</code>：<strong>产品角色</strong></p><ul><li>它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</li></ul></li><li><p><code>Director</code>：<strong>指挥者</strong></p><ul><li>指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象，然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/BuilderPattern-0.png" alt="BuilderPattern-0"></p><h3 id="3-模式实现"><a href="#3-模式实现" class="headerlink" title="3. 模式实现"></a>3. 模式实现</h3><ul><li><p>建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p></li><li><p>在建造者模式的结构中引入了一个指挥者类Director，该类主要有两个作用：一方面它隔离了客户端与产品创建的过程；另一方面它控制产品的创建过程，包括某个buildPartX()方法是否被调用以及多个buildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p></li></ul><h3 id="4-建造者模式应用实例"><a href="#4-建造者模式应用实例" class="headerlink" title="4. 建造者模式应用实例"></a>4. 建造者模式应用实例</h3><p>下面通过一个实例进一步学习和理解建造者模式。</p><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>现在需要开发一个创建RPG游戏角色的功能，像大多数RPG游戏一样不同类型的游戏角色，其性别、脸型、服装、发型等外部特性都有所差异，例如“天使”拥有美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”极其丑陋，留着光头并穿一件刺眼的黑衣。</p><p>现使用建造者模式来实现游戏角色的创建。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><ul><li>Actor：<code>产品角色类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 游戏角色类(复杂产品类)，本例子成员属性(部件或零件)都是很简单的string，真实情况下 *可能会存在多个成员属性是其它类的对象，所以才构成一个复杂对象 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-12 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Actor</span><span class="token punctuation">{</span>    <span class="token comment">/**     * 角色类型     * @var string     */</span>    <span class="token keyword">private</span> <span class="token variable">$type</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 角色性别     * @var string     */</span>    <span class="token keyword">private</span> <span class="token variable">$sex</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 角色脸形     * @var string     */</span>    <span class="token keyword">private</span> <span class="token variable">$face</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 角色服装     * @var string     */</span>    <span class="token keyword">private</span> <span class="token variable">$constume</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 角色发型     * @var string     */</span>    <span class="token keyword">private</span> <span class="token variable">$hairstype</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setType</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">type</span> <span class="token operator">=</span> <span class="token variable">$type</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setSex</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$sex</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">sex</span> <span class="token operator">=</span> <span class="token variable">$sex</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setFace</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$face</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">face</span> <span class="token operator">=</span> <span class="token variable">$face</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setConstume</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$constume</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">constume</span> <span class="token operator">=</span> <span class="token variable">$constume</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setHairstype</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$hairstype</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">hairstype</span> <span class="token operator">=</span> <span class="token variable">$hairstype</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">type</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">sex</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">face</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getConstume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">constume</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getHairstype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">hairstype</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ActorBuilder： <code>抽象建造者类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 角色建造器：抽象建造者 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-12 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">ActorBuilder</span><span class="token punctuation">{</span>    <span class="token comment">/**     * 游戏角色产品对象     * @var Actor     */</span>    <span class="token keyword">protected</span> <span class="token variable">$actor</span><span class="token punctuation">;</span>    <span class="token comment">/**     *+-----------------------------------------------------------     *| 这里ActorBuilder 与 Actor 表现为组合关系。     *|----------------------------------------------------------     *| ActorBuilder为整体对象，Actor为成员对象。     *|-----------------------------------------------------------     *| 组合关系表示类之间整体和部分的关系，成员对象与整体对象之间     *| 具有同生共死的关系，一旦整体对象不存在，成员对象也将不存在。     *+-----------------------------------------------------------     *| 组合关系通常通过在整体类的构造方法中直接实例化成员类。     *+-----------------------------------------------------------     *     * @return Actor     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Actor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildConstume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildHairstyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 返回一个构建好的完整的游戏角色对象     *     * @return Actor     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createActor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">Actor</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HeroBuilder、AngelBuilder、DevilBuilder： <code>具体建造类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 英雄角色建造器：具体建造者 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-12 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">HeroBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">ActorBuilder</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'英雄'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'男'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setFace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'英俊'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildConstume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setConstume</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'盔甲'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildHairstyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setHairstype</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'飘逸'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 天使角色建造器：具体建造者 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-12 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">AngelBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">ActorBuilder</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'天使'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'女'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setFace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'漂亮'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildConstume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setConstume</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'白裙'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildHairstyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setHairstype</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'披肩长发'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 恶魔角色建造器：具体建造者 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-12 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">DevilBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">ActorBuilder</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'恶魔'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'妖'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setFace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'丑陋'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildConstume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setConstume</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'黑衣'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">buildHairstyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">actor</span><span class="token operator">-&gt;</span><span class="token function">setHairstype</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'光头'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ActorDirector： <code>指挥者类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 游戏角色创建者：指挥者 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-12 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">ActorDirector</span><span class="token punctuation">{</span>    <span class="token comment">/**     * 逐步构建复杂产品对象     *+-----------------------------------------------------------     *| 这里ActorDirector 与 ActorBuilder 表现为是依赖关系。     *+-----------------------------------------------------------     *|依赖关系通常有三种方式来实现     *|1.将一个类的对象作为另一个类中方法的参数     *|2.一个类的方法中将另一个类的对象作为其局部变量     *|3.在一个类的方法中调用另一个类的静态方法     *+-----------------------------------------------------------     *     * @return Actor     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">build</span><span class="token punctuation">(</span><span class="token class-name type-declaration">ActorBuilder</span> <span class="token variable">$actorBuilder</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">Actor</span>    <span class="token punctuation">{</span>        <span class="token variable">$actorBuilder</span><span class="token operator">-&gt;</span><span class="token function">buildType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$actorBuilder</span><span class="token operator">-&gt;</span><span class="token function">buildSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$actorBuilder</span><span class="token operator">-&gt;</span><span class="token function">buildFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$actorBuilder</span><span class="token operator">-&gt;</span><span class="token function">buildConstume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$actorBuilder</span><span class="token operator">-&gt;</span><span class="token function">buildHairstyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$actorBuilder</span><span class="token operator">-&gt;</span><span class="token function">createActor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端测试代码</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/* 指明要创造的具体建造者 */</span><span class="token variable">$builder</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeroBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 实例化指挥者类 */</span><span class="token variable">$actorDirector</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActorDirector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 通过指挥者创建完整的产品 */</span><span class="token variable">$actor</span> <span class="token operator">=</span> <span class="token variable">$actorDirector</span><span class="token operator">-&gt;</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token variable">$builder</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"类型："</span><span class="token operator">.</span><span class="token variable">$actor</span><span class="token operator">-&gt;</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token operator">.</span>     <span class="token string double-quoted-string">"性别："</span><span class="token operator">.</span><span class="token variable">$actor</span><span class="token operator">-&gt;</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token operator">.</span>     <span class="token string double-quoted-string">"面容："</span><span class="token operator">.</span><span class="token variable">$actor</span><span class="token operator">-&gt;</span><span class="token function">getFace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token operator">.</span>     <span class="token string double-quoted-string">"服装："</span><span class="token operator">.</span><span class="token variable">$actor</span><span class="token operator">-&gt;</span><span class="token function">getConstume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token operator">.</span>     <span class="token string double-quoted-string">"发型："</span><span class="token operator">.</span><span class="token variable">$actor</span><span class="token operator">-&gt;</span><span class="token function">getHairstype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上例程会输出：</p><p>类型：英雄<br>性别：男<br>面容：英俊<br>服装：盔甲<br>发型：飘逸</p><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><p>示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/BuilderPattern-1.png" alt="BuilderPattern-1"></p><h3 id="6-建造者模式的优点"><a href="#6-建造者模式的优点" class="headerlink" title="6. 建造者模式的优点"></a>6. 建造者模式的优点</h3><p>建造者模式的主要优点如下：</p><p>(1)在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>(2)每一个具体建造者都相对独立，而与其他的具体建造者无关，因些可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</p><p>(3)可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p><p>(4)由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”</p><h3 id="7-建造者模式的缺点"><a href="#7-建造者模式的缺点" class="headerlink" title="7. 建造者模式的缺点"></a>7. 建造者模式的缺点</h3><p>建造者模式的主要缺点如下：</p><p>(1)建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>(2)如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</p><h3 id="8-建造者模式适用场景"><a href="#8-建造者模式适用场景" class="headerlink" title="8. 建造者模式适用场景"></a>8. 建造者模式适用场景</h3><p>在以下情况下可以考虑使用建造者模式：</p><p>(1)需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</p><p>(2)需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</p><p>(3)对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</p><p>(4)隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-创建型模式-抽象工厂模式 (Abstract Factory Pattern)</title>
      <link href="/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-chou-xiang-gong-han-mo-shi-abstract-factory-pattern/"/>
      <url>/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-chou-xiang-gong-han-mo-shi-abstract-factory-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式 (Abstract Factory Pattern)"></a>抽象工厂模式 (Abstract Factory Pattern)</h1><hr><h3 id="0-抽象工厂模式概述"><a href="#0-抽象工厂模式概述" class="headerlink" title="0. 抽象工厂模式概述"></a>0. 抽象工厂模式概述</h3><p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。为了更好地理解抽象工厂模式，我们先引入两个概念：</p><p>(1)产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p>(2)产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</p><p>产品等级结构与产品族示意图如图1所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/1.jpg" alt="1"></p><p>图1 产品族与产品等级结构示意图</p><p>在图1中，不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。图1中一共有五个产品族，分属于三个不同的产品等级结构。我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品。</p><p>当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图2所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/2.jpg" alt="2"></p><p>图2 抽象工厂模式示意图</p><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><blockquote><p>抽象工厂模式 (Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p></blockquote><p>抽象工厂模式是一种<strong>对象创建型模式</strong>。</p><ul><li><p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p></li><li><p>在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族。</p></li></ul><h3 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h3><p>抽象工厂模式包含如下角色：</p><ul><li><p><code>AbstractFactory</code>：<strong>抽象工厂</strong></p><ul><li>它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li></ul></li><li><p><code>ConcreteFactory</code>：<strong>具体工厂</strong></p><ul><li>它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li></ul></li><li><p><code>AbstractProduct</code>：<strong>抽象产品</strong></p><ul><li>它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li></ul></li><li><p><code>ConcreteProduct</code>：<strong>具体产品</strong></p><ul><li>它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/AbstractFactoryPattern-0.jpg" alt="AbstractFactoryPattern-0"></p><h3 id="3-抽象工厂模式应用实例"><a href="#3-抽象工厂模式应用实例" class="headerlink" title="3. 抽象工厂模式应用实例"></a>3. 抽象工厂模式应用实例</h3><p>下面通过一个实例进一步学习和理解抽象工厂模式。</p><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>我们就以生产家用电器的例子来学习下抽象工厂模式，现有多个工厂，每个工厂都生产自己品牌电视机、冰箱、洗衣机；客户端可以很灵活的选择某个工厂生产的一系列产品，也能方便的增加新的工厂。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><ul><li>HomeAppliancesFactory：<code>抽象工厂类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 家用电器工厂接口：抽象工厂 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">HomeAppliancesFactory</span><span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createTv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createIceBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createWasher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HaierFactory、MideaFactory： <code>具体工厂</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * Haier工厂：具体工厂 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">HaierFactory</span> <span class="token keyword">extends</span> <span class="token class-name">HomeAppliancesFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createTv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">HaierTv</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HaierTv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createIceBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">HaierIceBox</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HaierIceBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createWasher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">HaierWasher</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HaierWasher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * Midea工厂：具体工厂 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">MideaFactory</span> <span class="token keyword">extends</span> <span class="token class-name">HomeAppliancesFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createTv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">MideaTv</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MideaTv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createIceBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">MideaIceBox</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MideaIceBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createWasher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">MideaWasher</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MideaWasher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Tv： <code>抽象产品类</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 电视机接口：抽象产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">interface</span> <span class="token class-name-definition class-name">Tv</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HaierTv、MideaTv： <code>具体产品</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * Haier电视机类：具体产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">HaierTv</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Haier电视"</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * Midea电视机类：具体产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">MideaTv</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Midea电视"</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>IceBox： <code>抽象产品</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 冰箱接口：抽象产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">interface</span> <span class="token class-name-definition class-name">IceBox</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HaierIceBox、MideaIceBox： <code>具体产品</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * Haier冰箱类：具体产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">HaierIceBox</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Haier冰箱"</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * Midea冰箱类：具体产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">MideaIceBox</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Midea冰箱"</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Washer： <code>抽象产品</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 洗衣机接口：抽象产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">interface</span> <span class="token class-name-definition class-name">Washer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HaierWasher、MideaWasher： <code>具体产品</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * Haier洗衣机类：具体产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">HaierWasher</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Haier洗衣机"</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * Midea洗衣机类：具体产品 * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-05-26 * @copyright  Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">MideaWasher</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Midea洗衣机"</span><span class="token operator">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端测试代码</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">//$factory = new HaierFactory();</span><span class="token variable">$factory</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MideaFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$tv</span> <span class="token operator">=</span> <span class="token variable">$factory</span><span class="token operator">-&gt;</span><span class="token function">createTv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$iceBox</span> <span class="token operator">=</span> <span class="token variable">$factory</span><span class="token operator">-&gt;</span><span class="token function">createIceBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$washer</span> <span class="token operator">=</span> <span class="token variable">$factory</span><span class="token operator">-&gt;</span><span class="token function">createWasher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$tv</span><span class="token operator">-&gt;</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$iceBox</span><span class="token operator">-&gt;</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$washer</span><span class="token operator">-&gt;</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上例程会输出：</p><p>Midea电视<br><br>Midea冰箱<br><br>Midea洗衣机<br></p><p>如果需要更换成Haier生产的电器则只需把 <code>new MideaFactory()</code>变为<code>new HaierFactory() </code></p><h3 id="4-UML类图"><a href="#4-UML类图" class="headerlink" title="4. UML类图"></a>4. UML类图</h3><p>示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/AbstractFactoryPattern-1.png" alt="AbstractFactoryPattern-1"></p><h3 id="5-抽象工厂模式分析"><a href="#5-抽象工厂模式分析" class="headerlink" title="5. 抽象工厂模式分析"></a>5. 抽象工厂模式分析</h3><p>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><p>(1)增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</p><p>(2)增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</p><p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p><h3 id="6-抽象工厂模式的优点"><a href="#6-抽象工厂模式的优点" class="headerlink" title="6. 抽象工厂模式的优点"></a>6. 抽象工厂模式的优点</h3><p>抽象工厂模式的主要优点如下：</p><p>(1)抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</p><p>(2)当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p><p>(3)增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><h3 id="7-抽象工厂模式的缺点"><a href="#7-抽象工厂模式的缺点" class="headerlink" title="7. 抽象工厂模式的缺点"></a>7. 抽象工厂模式的缺点</h3><p>抽象工厂模式的主要缺点如下：</p><p>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p><h3 id="8-抽象工厂模式适用场景"><a href="#8-抽象工厂模式适用场景" class="headerlink" title="8. 抽象工厂模式适用场景"></a>8. 抽象工厂模式适用场景</h3><p>在以下情况下可以考虑使用抽象工厂模式：</p><p>(1)一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</p><p>(2)系统中有多于一个的产品族，而每次只使用其中某一产品族。用户可以动态改变产品族，也可以很方便地增加新的产品族。</p><p>(3)属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一品牌的电视机和冰箱，电视机与冰箱之间没有直接关系，但它们都是属于某一品牌的，此时具有一个共同的约束条件：品牌的类型。</p><p>(4)产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-创建型模式-工厂方法模式 (Factory Method Pattern)</title>
      <link href="/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-gong-han-fang-fa-mo-shi-factory-method-pattern/"/>
      <url>/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-gong-han-fang-fa-mo-shi-factory-method-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式 (Factory Method Pattern)"></a>工厂方法模式 (Factory Method Pattern)</h1><hr><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>工厂方法模式 (Factory Method Pattern)：它属于类创建型模式。定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类中完成。</p><h3 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h3><p>工厂方法模式包含如下角色：</p><ul><li><p>AbstractProduct: 抽象产品</p><ul><li>抽象产品角色是所有需要实例化产品类的父类</li></ul></li><li><p>ConcreteProduct：具体产品</p><ul><li>具体的产品，继承了抽象产品</li></ul></li><li><p>Factory：抽象工厂</p><ul><li>声明工厂方法，该方法返回一个AbstractProduct类型的对象</li></ul></li><li><p>ConcreteFactory：具体工厂</p><ul><li>重新定义工厂方法以返回一个ConcreteProduct类型的对象</li></ul></li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>以一个简单的计算器功能来说明下各角色的应用：</p><ul><li>Operation.php：抽象产品</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 运算抽象类 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-17 14:52:15 * @copyright Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">Operation</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$numberA</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$numberB</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function-definition function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setNumberA</span><span class="token punctuation">(</span><span class="token variable">$numberA</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span> <span class="token operator">=</span> <span class="token variable">$numberA</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getNumberA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setNumberB</span><span class="token punctuation">(</span><span class="token variable">$numberB</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span> <span class="token operator">=</span> <span class="token variable">$numberB</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getNumberB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>OperationAdd.php、OperationSub.php：具体产品</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 加法运算类 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-17 14:54:10 * @copyright Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">OperationAdd</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">bcadd</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 减法运算类 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-17 14:54:26 * @copyright Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">OperationSub</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">bcsub</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>FactoryInterface.php：抽象工厂</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 运算工厂接口类 * 定义了一个用于创建对象的接口，让其子类决定实例化哪一个类 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-17 14:56:24 * @copyright Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">interface</span> <span class="token class-name-definition class-name">FactoryInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createOperate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>AddFactory.php、SubFactory.php：具体工厂</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 加法类工厂 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-17 15:01:27 * @copyright Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">AddFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createOperate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OperationAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 减法类工厂 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-17 17:21:41 * @copyright Copyright (c) 2018 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">SubFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">createOperate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OperationSub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-客户端的使用"><a href="#4-客户端的使用" class="headerlink" title="4. 客户端的使用"></a>4. 客户端的使用</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$addFactory</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AddFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$addOperation</span> <span class="token operator">=</span> <span class="token variable">$addFactory</span><span class="token operator">-&gt;</span><span class="token function">createOperate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$addOperation</span><span class="token operator">-&gt;</span><span class="token function">setNumberA</span><span class="token punctuation">(</span><span class="token number">2000.30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$addOperation</span><span class="token operator">-&gt;</span><span class="token function">setNumberB</span><span class="token punctuation">(</span><span class="token number">299.40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token variable">$addOperation</span><span class="token operator">-&gt;</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><p>工厂方法模式实现的简单计算器示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/FactoryMethodPattern.png" alt="FactoryMethodPattern"></p><h3 id="6-工厂方法模式的优点"><a href="#6-工厂方法模式的优点" class="headerlink" title="6. 工厂方法模式的优点"></a>6. 工厂方法模式的优点</h3><ul><li>基于抽象工厂和抽象产品的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广，使得在系统中加入新产品时，无须修改抽象工厂和抽象产品，也无须修改具体工厂和具体产品，而只要添加一个具体工厂和具体产品就行。这样，系统的可扩展性也就变得非常好，完全符合“开放－封闭原则”。</li></ul><h3 id="7-工厂方法模式的缺点"><a href="#7-工厂方法模式的缺点" class="headerlink" title="7. 工厂方法模式的缺点"></a>7. 工厂方法模式的缺点</h3><ul><li>在添加新产品时，需要编写新的具体工厂类和具体产品类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度和额外的开放量，有更多的类需要加载和解析，会给系统带来一些额外的开销。</li><li>由于引入了抽象工厂类和抽象产品类，增加了系统的抽象性和理解难度。</li></ul><h3 id="8-适用场景"><a href="#8-适用场景" class="headerlink" title="8. 适用场景"></a>8. 适用场景</h3><p>以下情况可以使用简单工厂方法模式：</p><ul><li>客户端不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道其所对应的工厂即可，具体的产品由具体工厂类创建，客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类将覆盖父类的方法，从而使得系统更容易扩展。</li></ul><h3 id="9-模式扩展"><a href="#9-模式扩展" class="headerlink" title="9. 模式扩展"></a>9. 模式扩展</h3><ul><li>多态性的丧失和模式的退化：一般来说，具体工厂类应当有一个抽象工厂父类，如果只有一个具体工厂类的话，抽象工厂父类就可以省略，也将发生退化。当只有一个具体工厂类时，在具体工厂类中可以创建所有的具体产品对象，并且具体工厂类中的方法设计为静态方法时，工厂模式就退化成简单工厂模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-创建型模式-简单工厂模式 (Simple Factory Pattern)</title>
      <link href="/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-jian-dan-gong-han-mo-shi-simple-factory-pattern/"/>
      <url>/2021/06/30/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-jian-dan-gong-han-mo-shi-simple-factory-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="简单工厂模式-Simple-Factory-Pattern"><a href="#简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="简单工厂模式 (Simple Factory Pattern)"></a>简单工厂模式 (Simple Factory Pattern)</h1><hr><h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有相同的接口或父类。</p><h3 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h3><p>简单工厂模式包含如下角色：</p><ul><li><p>Factory：工厂</p><ul><li>工厂负责实现创建所需类的实例</li></ul></li><li><p>AbstractProduct: 抽象产品</p><ul><li>抽象产品是所有具体产品类的父类</li></ul></li><li><p>ConcreteProduct：具体产品</p><ul><li>具体产品是创建目标</li></ul></li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>以一个简单的计算器功能来说明下各角色的应用：</p><ul><li>OperationFactory.php：工厂</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 运算工厂类 * 一、根据不同的参数来创建加法、减法类等实例。 * 二、通常createOperate方法为公开的静态方法。 * 三、通常createOperate方法中包含简单的switch...case判断逻辑。 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-08 20:03:21 * @copyright Copyright (c) 2017 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">OperationFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function-definition function">createOperate</span><span class="token punctuation">(</span><span class="token variable">$operate</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$operation</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword type-casting">string</span><span class="token punctuation">)</span><span class="token variable">$operate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string single-quoted-string">'+'</span><span class="token punctuation">:</span>                <span class="token variable">$operation</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OperationAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string single-quoted-string">'-'</span><span class="token punctuation">:</span>                <span class="token variable">$operation</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OperationSub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token variable">$operation</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Operation.php：抽象产品</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 运算抽象类 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-08 20:00:07 * @copyright Copyright (c) 2017 dendi875@163.com */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">Operation</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$numberA</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$numberB</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function-definition function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setNumberA</span><span class="token punctuation">(</span><span class="token variable">$numberA</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span> <span class="token operator">=</span> <span class="token variable">$numberA</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getNumberA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">setNumberB</span><span class="token punctuation">(</span><span class="token variable">$numberB</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span> <span class="token operator">=</span> <span class="token variable">$numberB</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getNumberB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>OperationAdd.php、OperationSub.php：具体产品</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * 加法运算类 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-08 20:02:42 * @copyright Copyright (c) 2017 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">OperationAdd</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">bcadd</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 减法运算类 * * @author    &lt;dendi875@163.com&gt; * @createDate 2018-03-08 20:03:01 * @copyright Copyright (c) 2017 dendi875@163.com */</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">OperationSub</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">bcsub</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberA</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-&gt;</span><span class="token property">numberB</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-客户端的使用"><a href="#4-客户端的使用" class="headerlink" title="4. 客户端的使用"></a>4. 客户端的使用</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$operation</span> <span class="token operator">=</span> <span class="token class-name static-context">OperationFactory</span><span class="token operator">::</span><span class="token function">createOperate</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$operation</span><span class="token operator">-&gt;</span><span class="token function">setNumberA</span><span class="token punctuation">(</span><span class="token number">2000.30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$operation</span><span class="token operator">-&gt;</span><span class="token function">setNumberB</span><span class="token punctuation">(</span><span class="token number">299.40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token variable">$operation</span><span class="token operator">-&gt;</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><p>简单工厂模式实现的计算器示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/SimpleFactoryPattern-0.png" alt="SimpleFactoryPattern-0"></p><h3 id="6-简单工厂模式的优点"><a href="#6-简单工厂模式的优点" class="headerlink" title="6. 简单工厂模式的优点"></a>6. 简单工厂模式的优点</h3><ul><li>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</li><li>客户端无须知道所创建产品类的类名，只需要知道具体产品类所对应的参数，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量</li></ul><h3 id="7-简单工厂模式的缺点"><a href="#7-简单工厂模式的缺点" class="headerlink" title="7. 简单工厂模式的缺点"></a>7. 简单工厂模式的缺点</h3><ul><li>使用简单工厂模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度。</li><li>在产品类型较多时，有可能造成工厂类逻辑过于复杂，不利于系统的扩展和维护。</li><li>一旦添加新的产品就不得不修改工厂类逻辑，在工厂类的方法中增加“Case”条件分支，修改了原生的类，这就违背了开放－封闭原则</li></ul><h3 id="8-适用场景"><a href="#8-适用场景" class="headerlink" title="8. 适用场景"></a>8. 适用场景</h3><p>以下情况可以使用简单工厂模式：</p><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只关心传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道各产品类所对应的参数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之-创建型模式-单例模式（Singleton Pattern）</title>
      <link href="/2021/06/29/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-dan-li-mo-shi-singleton-pattern/"/>
      <url>/2021/06/29/she-ji-mo-shi-zhi-chuang-jian-xing-mo-shi-dan-li-mo-shi-singleton-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之-单例模式（Singleton-Pattern）"><a href="#设计模式之-单例模式（Singleton-Pattern）" class="headerlink" title="设计模式之-单例模式（Singleton Pattern）"></a>设计模式之-单例模式（Singleton Pattern）</h1><hr><h3 id="1-模式动机"><a href="#1-模式动机" class="headerlink" title="1. 模式动机"></a>1. 模式动机</h3><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统只能有一个计时工具或ID（序号）生成器；一个系统中只能有一个锁定应用程序的文件。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h3 id="2-模式定义"><a href="#2-模式定义" class="headerlink" title="2. 模式定义"></a>2. 模式定义</h3><p>单例模式（Singleton Pattern）：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：</p><ul><li><p>一是某个类只能有一个实例</p></li><li><p>二是它必须自行创建这个实例</p></li><li><p>三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式</p></li></ul><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h3><ul><li>Singleton.php</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** * Singleton * * @author     &lt;dendi875@163.com&gt; * @createDate 2018-03-02 14:12:28 * @copyright  Copyright (c) 2019 dendi875@163.com */</span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name-definition class-name">Singleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token variable">$instance</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 提供一个公有的静态方法     *     * @return Singleton     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function-definition function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">Singleton</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword static-context">static</span><span class="token operator">::</span><span class="token variable">$instance</span> <span class="token operator">===</span> <span class="token constant">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword static-context">static</span><span class="token operator">::</span><span class="token variable">$instance</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">static</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword static-context">static</span><span class="token operator">::</span><span class="token variable">$instance</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 不允许从外部调用，以防止创建多个实例，     * 要使用单例，必须从 Singleton::getInstance() 获取实例     */</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 防止实例被克隆（这将创建它的第二个实例）     */</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 防止被反序列化（这将创建它的第二个实例）     */</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function-definition function">__wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-模式分析"><a href="#4-模式分析" class="headerlink" title="4. 模式分析"></a>4. 模式分析</h3><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<strong>Singleton</strong>。单例类拥有一个私有构造函数，确保用户无法通过<code>new</code>关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的方法，该方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p><p>在单例模式的实现过程中，需要注意如下三点：</p><ul><li><p>单例类的构造函数为私有</p></li><li><p>提供一个自身的静态私有成员变量</p></li><li><p>提供一个公有的静态方法</p></li></ul><h3 id="5-UML类图"><a href="#5-UML类图" class="headerlink" title="5. UML类图"></a>5. UML类图</h3><p>简单工厂模式实现的计算器示例代码UML图：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/singleton.png" alt="singleton"></p><h3 id="6-优点"><a href="#6-优点" class="headerlink" title="6. 优点"></a>6. 优点</h3><ul><li><p>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</p></li><li><p>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</p></li></ul><h3 id="7-缺点"><a href="#7-缺点" class="headerlink" title="7. 缺点"></a>7. 缺点</h3><ul><li><p>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难</p></li><li><p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、PHP)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</p></li></ul><h3 id="8-适用场景"><a href="#8-适用场景" class="headerlink" title="8. 适用场景"></a>8. 适用场景</h3><p>以下情况可以使用单例模式：</p><ul><li><p>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象</p></li><li><p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</p></li><li><p>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</p></li></ul><h3 id="9-模式应用"><a href="#9-模式应用" class="headerlink" title="9. 模式应用"></a>9. 模式应用</h3><ul><li><p>数据库连接器</p></li><li><p>一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现</p></li></ul><h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h3><ul><li><p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</p></li><li><p>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</p></li><li><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过<code>new</code>关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的方法。该方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Beanstalkd 学习研究</title>
      <link href="/2021/06/29/beanstalkd-xue-xi-yan-jiu/"/>
      <url>/2021/06/29/beanstalkd-xue-xi-yan-jiu/</url>
      
        <content type="html"><![CDATA[<h1 id="Beanstalkd-学习研究"><a href="#Beanstalkd-学习研究" class="headerlink" title="Beanstalkd 学习研究"></a>Beanstalkd 学习研究</h1><hr><h2 id="1-Beanstalkd-介绍"><a href="#1-Beanstalkd-介绍" class="headerlink" title="1. Beanstalkd 介绍"></a>1. Beanstalkd 介绍</h2><p>Beanstalkd是一个简单、高效的工作队列系统，其最初设计目的是通过后台异步执行耗时任务方式降低高容量Web应用的页面延时。而其简单、轻量、易用等特点，和对<code>任务优先级（priority）</code>、<code>任务延时（delay）</code>、<code>任务超时重发（time-to-run）</code>和<code>任务预留（buired）</code>等控制，以及众多语言版本的客户端的良好支持，使其能够很好的支持分布式的后台任务和定时任务处理。</p><p>beanstalkd还提供了<code>binlog</code>机制，当重启beanstalkd，当前任务的状态能够从记录的本地<code>binlog</code>中恢复。</p><h2 id="2-Beanstalkd-中的重要概念"><a href="#2-Beanstalkd-中的重要概念" class="headerlink" title="2. Beanstalkd 中的重要概念"></a>2. Beanstalkd 中的重要概念</h2><h3 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/beanstalkd-architecture.png" alt="beanstalkd-architecture"></p><p><code>Beanstalkd</code> 使用 <code>Producer-Consumer</code>设计模式，无论是其协议结构还是使用方式都是类似<code>Memcached</code>风格的。以下是<code>Beanstalkd</code>设计思想中核心概念：</p><h4 id="job-任务"><a href="#job-任务" class="headerlink" title="job - 任务"></a>job - 任务</h4><p><code>job</code>是一个需要异步处理的处理，是 <code>Beanstalkd</code>中的基本单元，每个<code>job</code>都会有一个id和优先级，<code>job</code>需要放在一个<code>tube</code>中。 <code>Beanstalkd</code>中的任务（<code>job</code>）类似于其消息队列中的消息（<code>message</code>）的概念。</p><h4 id="tube-管道"><a href="#tube-管道" class="headerlink" title="tube - 管道"></a>tube - 管道</h4><p>管道即某一种类型的任务队列，其类似于消息的主题（<code>topic</code>），是<code>Producer</code>和<code>Consumer</code>的操作对象。一个<code>Beanstalkd</code>中可以有多个管道，每个管道都有自己的生产者（<code>Producer</code>）和消费者（<code>Consumer</code>），管道之间互相不影响。</p><h4 id="producer-生产者"><a href="#producer-生产者" class="headerlink" title="producer - 生产者"></a>producer - 生产者</h4><p>任务（<code>job</code>）的生产者，通过<code>put</code>命令来将一个<code>job</code>放到一个<code>tube</code>中。</p><h4 id="consumer-消费者"><a href="#consumer-消费者" class="headerlink" title="consumer - 消费者"></a>consumer - 消费者</h4><p>任务（<code>job</code>）的消费者，通过<code>reserve</code>来获取<code>job</code>，通过<code>delete</code>、<code>release</code>、<code>bury</code>来改变<code>job</code>的状态。</p><h3 id="2-2-任务生命周期"><a href="#2-2-任务生命周期" class="headerlink" title="2.2 任务生命周期"></a>2.2 任务生命周期</h3><p><code>Beanstalkd</code>中的任务（<code>job</code>）替代了消息（<code>message</code>）的概念，任务会有一系列状态。任务的生命周期如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/beanstalkd-job-status.png" alt="beanstalkd-job-status"></p><p>一个 <code>Beanstalkd</code>任务可能会包含以下状态：</p><ul><li><strong>READY</strong> - 需要立即处理的任务。当<code>producter</code>直接<code>put</code>一个任务时，任务就处理<code>READY</code>状态，以等待<code>consumer</code>来处理。当延时（<code>DELAYED</code>）任务到期后会自动成为当前<code>READY</code>状态的任务</li><li><strong>RESERVED</strong> - 已经被消费者获取，正在执行的任务。当<code>consumer</code>获取了当前<code>READY</code>的任务后，该任务的状态就会迁移到<code>RESERVED</code>状态，这时其它的<code>consumer</code>就不能再操作该任务。<code>Beanstalkd</code>会检查任务是否在<code>TTR</code>（<code>time-to-run</code>）内完成</li><li><strong>DELETED</strong> - 消息被删除，<code>Beanstalkd</code>不再维持这些消息。即任务生命周期结束</li><li><strong>DELAYED</strong> - 延迟执行的任务。当任务被延时<code>put</code>时，任务就处理<code>DELAYED</code>状态。等待时间过后，任务会被迁移到<code>READY</code>状态。当消费者处理任务后，可以将任务再次放回<code>DELAYED</code>队列延迟执行</li><li><strong>BURIED</strong> - 埋葬的任务，这时任务不会被执行，也不会消失。当<code>consumer</code>完成该任务后，可以选择<code>delete</code>或<code>release</code>或<code>bury</code>操作<ul><li><code>delete</code>后，任务被删除，生命周期结束</li><li><code>release</code>操作可以把任务状态迁移回<code>READY</code>状态或<code>DELAYED</code>状态，使其它<code>consumer</code>可以继续获取和执行该任务</li><li><code>bury</code>操作会埋葬任务，等需要该任务时，再将埋葬的任务<code>kick</code>回<code>READY</code>，也可以通过<code>delete</code>删除<code>BURIED</code>状态的任务</li></ul></li></ul><h3 id="2-3-Beanstalkd特点"><a href="#2-3-Beanstalkd特点" class="headerlink" title="2.3 Beanstalkd特点"></a>2.3 Beanstalkd特点</h3><ul><li><strong>任务优先级（priority）</strong></li></ul><p>任务（<code>job</code>）可以有<code>0~2^32</code>个优先级，<code>0</code>表示优先级最高。<code>Beanstalkd</code>采用最大最小堆（Minx-max heap）处理任务优先级排序，任何时刻调用<code>reverse</code>命令的消费者总是能拿到当前优先级最高的任务，时间复杂度为<code>O(logn)</code></p><ul><li><strong>任务延时（delay）</strong></li></ul><p><code>Beanstalkd</code>中可以通过两种方式延时执行任务：生产者发布任务时指定延时；或者当任务处理完毕后，消费者再次将任务放入队列延时执行（<code>release with delay</code>）。这种机制可以实现分布式定时任务，这种任务机制的优势是：如果某个消费者节点故障，任务超时重发（<code>time-to-run</code>）以保证任务转移到其它节点执行</p><ul><li><strong>任务超时重发（time-to-run）</strong></li></ul><p><code>Beanstalkd</code>把任务返回给消费者后，消费者必须在预设的<code>TTR</code>(<code>time-to-run</code>)时间内发送<code>delete</code>、或<code>release</code>、或<code>bury</code>命令改变任务的状态；否则<code>Beanstalkd</code>会认为任务处理失败，然后把任务交给另外的消费者节点执行。如果消费者预计在<code>TTR</code>时间内无法完成任务，可以发送<code>touch</code>命令，以使<code>Beanstalkd</code>重新计算<code>TTR</code></p><ul><li><strong>任务预留（buried）</strong></li></ul><p>当<code>RESERVED</code>状态的任务因为某些原因无法执行时，消费者可以使用<code>bury</code>命令将其设置为<code>buried</code>状态，这时<code>Beanstalkd</code>会继续保留这些任务。在具备任务执行条件时，再通过<code>kick</code>将任务迁移回<code>READY</code>状态</p><h2 id="3-beanstalkd安装使用"><a href="#3-beanstalkd安装使用" class="headerlink" title="3. beanstalkd安装使用"></a>3. beanstalkd安装使用</h2><p>Beanstalkd分为服务端和客户端两部分。可以在其官网查找相关安装包及安装方法：</p><ul><li>服务端：<a href="http://kr.github.io/beanstalkd/download.html">http://kr.github.io/beanstalkd/download.html</a></li><li>客户端：<a href="https://github.com/kr/beanstalkd/wiki/client-libraries">https://github.com/kr/beanstalkd/wiki/client-libraries</a></li></ul><h3 id="3-1-服务端"><a href="#3-1-服务端" class="headerlink" title="3.1 服务端"></a>3.1 服务端</h3><h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><p>下载、解压并进入源码目录后，执行<code>make</code>或<code>make install</code>命令即可：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ sudo make// 或$ sudo make install// 或$ sudo make install PERFIX=/usr/bin/beanstalkd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h4><p>在Unbuntu或Debian系统中，可以使用以下命令安装：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ sudo apt-get install beanstalkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在CentOS或RHEL系统中，首先需要更新<code>EPEL</code>源，然后再使用<code>yum</code>命令安装。</p><p>小提示：更多关于<code>EPEL</code>的知识可以查阅下面的资料：</p><ul><li><p><a href="https://fedoraproject.org/wiki/EPEL">Information on EPEL</a></p></li><li><p><a href="https://fedoraproject.org/wiki/EPEL/FAQ#howtouse">How to use EPEL</a></p></li></ul><p>在RHEL6/CentOS6中使用以下命令更新源：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ su -c 'rpm -Uvh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在RHEL7中：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ su -c 'rpm -Uvh http://download.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查<code>EPEL</code>源是否更新成功：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ yum repolist enabled | grep epel * epel: mirrors.yun-idc.comepel                  Extra Packages for Enterprise Linux 6 - i386        10,254<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行安装：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ yum install -y beanstalkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加入开启自启动：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ chkconfig beanstalkd  on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加用户组：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ groupadd beanstalkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加用户：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ useradd -M -g beanstalkd -s /sbin/nologin beanstalkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建<code>binlog</code>存放目录并修改所有者/所属组（有权限写入）：</p><pre class="line-numbers language-none"><code class="language-none">$ mkdir -p /data/beanstalkd/binlog/$ chown -R beanstalkd:beanstalkd  /data/beanstalkd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改配置文件中存放<code>binlog</code>的目录：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ vi /etc/sysconfig/beanstalkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>BEANSTALKD_BINLOG_DIR=/data/beanstalkd/binlog</em></p><h4 id="运行beanstalkd"><a href="#运行beanstalkd" class="headerlink" title="运行beanstalkd"></a>运行beanstalkd</h4><p>Beanstalkd安装后，就可以通过beanstalkd命令来启动或配置Beanstalkd。该命令的使用格式如下：</p><pre class="line-numbers language-none"><code class="language-none">beanstalkd [OPTIONS]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可选[OPTIONS]参数有：</p><ul><li>-b DIR - wal目录（开启binlog，断电重启后会自动恢复任务）</li><li>-f MS  - 指定MS毫秒内的 fsync (-f0 为”always fsync”)</li><li>-F - 从不 fsync (默认)</li><li>-l ADDR - 指定监听地址（默认为：0.0.0.0）</li><li>-p PORT - 指定监听端口（默认为：11300）</li><li>-u USER - 用户与用户组</li><li>-z BYTE - 最大的任务大小（默认为：65535）</li><li>-s BYTE - 每个wal文件的大小（默认为：10485760）</li><li>-c - 压缩binlog（默认）</li><li>-n - 不压缩binlog</li><li>-v - 显示版本信息</li><li>-h - 显示帮助</li></ul><p>我们使用<code>nohup</code>和<code>&amp;</code>来配合启动程序，这样能免疫 <strong>Ctrl-C发送的SIGINT信号和关闭session发送的SIGHUP信号</strong></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ nohup beanstalkd -l 0.0.0.0 -p 11300 -b /data/beanstalkd/binlog/ -u beanstalkd &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h3><p>客户端包含了Beanstalkd设计概念中的任务<code>生产者（Producer）</code>和<code>消费者（Consumer）</code>。Beanstalkd有很多语言版本客户端的实现，点击<a href="https://github.com/beanstalkd/beanstalkd/wiki/Client-Libraries">Beanstalkd 客户端</a>查找自已所需要的版本，如果都不能满足需要，还可以根据<a href="https://github.com/beanstalkd/beanstalkd/blob/v1.3/doc/protocol.txt">Beanstalkd 协议</a>自行实现。</p><p>笔者日常工作中，接触PHP语言较多，以下用一个PHP版本的Beanstalkd 客户端：<a href="https://packagist.org/packages/pda/pheanstalk">pda/pheanstalk</a>为例，简单演示Beanstalkd的任务处理流程。</p><p>安装 pda/pheanstalk</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ composer require pda/pheanstalk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="生产-job"><a href="#生产-job" class="headerlink" title="生产 job"></a>生产 job</h4><p>创建一个 producer 来生产 job</p><p>producer.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'./vendor/autoload.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Pheanstalk<span class="token punctuation">\</span>Pheanstalk</span><span class="token punctuation">;</span><span class="token variable">$pheanstalk</span>  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pheanstalk</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">11300</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$tubeName</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'syslog'</span><span class="token punctuation">;</span><span class="token variable">$jobData</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string single-quoted-string">'type'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'Debug'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'level'</span> <span class="token operator">=&gt;</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token comment">// error log</span>    <span class="token string single-quoted-string">'content'</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">'queue connect failed'</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'timestamp'</span> <span class="token operator">=&gt;</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token function">microtime</span><span class="token punctuation">(</span><span class="token constant boolean">true</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string single-quoted-string">'timeCreated'</span> <span class="token operator">=&gt;</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Y-m-d H:i:s'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$pheanstalk</span>    <span class="token operator">-&gt;</span><span class="token function">useTube</span><span class="token punctuation">(</span><span class="token variable">$tubeName</span><span class="token punctuation">)</span>    <span class="token operator">-&gt;</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$jobData</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 producer.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">$ php producer<span class="token operator">.</span>php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="消费-job"><a href="#消费-job" class="headerlink" title="消费 job"></a>消费 job</h4><p>创建一个 consumer 来消费 job</p><p>consumer.php</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&lt;?phpif (PHP_SAPI !== 'cli') {    echo 'Warning: should be invoked via the CLI version of PHP, not the '.PHP_SAPI.' SAPI'.PHP_EOL;}require_once('./vendor/autoload.php');use Pheanstalk\Pheanstalk;$pheanstalk  = new Pheanstalk('127.0.0.1', 11300);$tubeName = 'syslog';while (true) {    // 从指定队列获取信息，reserve 阻塞获取    $job = $pheanstalk-&gt;useTube($tubeName)-&gt;watch($tubeName)-&gt;ignore('default')-&gt;reserve(60);    if ($job !== false) {        // do stuff        echo $data = $job-&gt;getData();        // 处理完成，删除 job        $pheanstalk-&gt;delete($job);    }    usleep(500000); // 0.5 s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 consumer.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">$ php consumer<span class="token operator">.</span>php<span class="token punctuation">{</span><span class="token string double-quoted-string">"type"</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"Debug"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"level"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"content"</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"queue connect failed"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"timestamp"</span><span class="token punctuation">:</span><span class="token number">1576113851568</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"timeCreated"</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"2019-12-12 01:24:11"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用<strong>deamontools</strong>和<strong>supervisor</strong>等将<code>php consumer.php</code>变为常驻内存的进程。</p><h4 id="监控-beanstalkd-状态"><a href="#监控-beanstalkd-状态" class="headerlink" title="监控 beanstalkd 状态"></a>监控 beanstalkd 状态</h4><p>创建一个 heartbeat 来检查与服务器的连接状态</p><p>heartbeat.php</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&lt;?php/** * 心跳检查脚本：定期在定时任务系统（crontab、MySQL Event Scheduler、Elastic-Job）上运行并收集与服务器连接状态信息， * 如果连接不是活的状态，则可以发送消息报警（sms、email） */if (PHP_SAPI !== 'cli') {    echo 'Warning: should be invoked via the CLI version of PHP, not the '.PHP_SAPI.' SAPI'.PHP_EOL;}require_once('./vendor/autoload.php');use Pheanstalk\Pheanstalk;$pheanstalk  = new Pheanstalk('127.0.0.1', 11300);$isAlive = $pheanstalk-&gt;getConnection()-&gt;isServiceListening();var_dump($isAlive);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 heartbeat.php</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ php heartbeat.phpbool(true)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-beanstalkd-管理工具"><a href="#4-beanstalkd-管理工具" class="headerlink" title="4. beanstalkd 管理工具"></a>4. beanstalkd 管理工具</h2><p>Tools：<a href="https://github.com/beanstalkd/beanstalkd/wiki/Tools">https://github.com/beanstalkd/beanstalkd/wiki/Tools</a></p><p>笔者经常使用的两款工具：</p><p>web 界面：<a href="https://github.com/ptrofimov/beanstalk_console">https://github.com/ptrofimov/beanstalk_console</a></p><p>命令行：<a href="https://github.com/src-d/beanstool">https://github.com/src-d/beanstool</a></p><p>对 beanstalkd 的操作也可以使用<code>telnet</code>，比如 <code>telnet 127.0.0.1 11300</code>。然后便可以执行 beanstalkd 的各命令，如 <code>stats</code> 查看信息，<code>use</code>, <code>put</code>, <code>watch</code> 等等。</p><p><code>telnet</code>对beanstalkd的操作：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ telnet 127.0.0.1 11300statsOK 929---current-jobs-urgent: 0current-jobs-ready: 0current-jobs-reserved: 0current-jobs-delayed: 0current-jobs-buried: 0...list-tubesOK 23---- default- syslog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-Beanstalkd-使用总结"><a href="#5-Beanstalkd-使用总结" class="headerlink" title="5. Beanstalkd 使用总结"></a>5. Beanstalkd 使用总结</h2><ul><li><p>如果需要对<code>job</code>有<strong>持久化</strong>的需要，在启动beanstalkd时可以使用<code>-b</code>参数来开启<code>binlog</code>（二进制日志）， 通过<code>binlog</code>可以将<code>job</code>及其状态记录到文件里，如果断电，则可以使用相同的选项重新启动beanstalkd，它将读取<code>binlog</code>来恢复之前的<code>job</code>及状态</p></li><li><p><code>put</code>前先要<code>use tube xxxtube</code>，这样<code>put</code>的时候就会把<code>job</code>放到指定名称的<code>tube</code>中，否则会放到一个<code>default</code>的<code>tube</code>中</p></li><li><p><code>reserve</code>或<code>reserve-with-timeout</code>前先要<code>watch xxxtube</code>，可以同时监控多个<code>tube</code>，这样可以同时取几个队列的任务。但是，千万要小心，如果在一个进程中，不小心<code>watch</code>到了多个<code>tube</code>，那么有时候会取错任务，一般取<code>job</code>的步骤为：<code>useTube xxxtube -&gt; watch xxxtube -&gt; ignore default -&gt; reserve</code></p></li><li><p><code>job</code>处理完成，应该<code>delete</code>删除掉，或者<code>release</code>再放回队列，或者<code>bury</code>把它埋葬掉，这个取决于你的设计</p></li></ul><h2 id="6-Beanstalkd-不足"><a href="#6-Beanstalkd-不足" class="headerlink" title="6. Beanstalkd 不足"></a>6. Beanstalkd 不足</h2><ul><li><p>无最大内存控制，如果有消息堆积或者业务使用方式有误，而导致内存暴涨拖垮机器</p></li><li><p>跟<code>Memcached</code>类似，没有<code>master-slave</code>故障切换机制，需要自己解决单点问题</p></li></ul><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul><li><a href="https://beanstalkd.github.io/">beanstalkd 官网</a></li><li><a href="https://github.com/beanstalkd/beanstalkd/wiki/Client-Libraries">Beanstalkd 客户端</a></li><li><a href="https://github.com/beanstalkd/beanstalkd/wiki/FAQ">beanstalkd FAQ</a></li><li><a href="https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.zh-CN.md">Beanstalkd 中文协议</a></li><li><a href="https://github.com/pheanstalk/pheanstalk">pheanstalk</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 多进程编程</title>
      <link href="/2021/06/29/php-duo-jin-cheng-bian-cheng/"/>
      <url>/2021/06/29/php-duo-jin-cheng-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-多进程编程"><a href="#PHP-多进程编程" class="headerlink" title="PHP 多进程编程"></a>PHP 多进程编程</h1><hr><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>想完成某个耗时的任务，又觉得一个进程太慢，那么，试试用多进程来搞吧。这篇文章将会介绍一下<code>PHP</code>多进程的基本知识，如何创建多进程以及基本的信号控制。</p><h2 id="1-基本概念与环境准备"><a href="#1-基本概念与环境准备" class="headerlink" title="1. 基本概念与环境准备"></a>1. 基本概念与环境准备</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>程序和进程</p><blockquote><p>程序（program）是一个存储在磁盘上某个目录中的可执行文件。</p><p>程序的执行实例被称为进程（process）。</p></blockquote></li><li><p>进程相关概念</p></li></ul><p>1）进程ID</p><p>进程标识符（<code>PID</code>）是大多数操作系统的内核用于唯一标识进程的一个数值。这一数值可以作为许多函数调用的参数，以使调整进程优先级、杀死进程之类的进程控制行为成为可能。</p><p>在<code>UNIX</code>里，除了<code>进程0</code>（即PID=0的交换进程，Swapper Process）以外的所有进程都是由其他进程使用系统调用<code>fork</code>创建的，这里调用<code>fork</code>创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程，因而除了<code>进程0</code>以外的进程都只有一个父进程，但一个进程可以有多个子进程。</p><p> 0号进程是系统引导时创建的一个特殊进程，在其调用<code> fork</code>创建出一个子进程（即PID=1的进程1，又称 init）后，<code> 进程0</code>就转为交换进程（有时也被称为空闲进程），而<code> 进程1</code>（init进程）就是系统里其他所有进程的祖先。</p><p>2）调用进程的父进程ID</p><p>3）调用进程的实际用户ID</p><p>4）调用进程的有效用户ID</p><p>5）调用进程的实际组ID</p><p>6）调用进程的有效组ID</p><p>7）进程的优先级</p><p>例如修改bash进程的优先级</p><ul><li>获取bash进程的进程ID<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[dendi875@localhost ~]$ echo $$3224<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>top查看进程的优先级</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">top -d -2 -p &lt;pid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>top状态下按<strong>r</strong>输入进程ID后按回车，然后再输入<code>nice</code>值</li></ul><p>8）进程状态</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/process-status.png" alt="process-status"></p><p>9）进程组</p><ul><li>进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID。进程组ID类似进程ID，它是一个正整数。</li><li>每个进程组有一个组长进程。组长进程的进程ID等于其进程ID。</li></ul><p>10）会话</p><ul><li>会话（session）是一个或多个进程组的集合。</li><li>如果调用进程不是一个组长进程则可以使用<code>setsid</code>来创建一个新会话。具体会发生3件事<ul><li>该进程变成新会话的<strong>会话首进程</strong>（会话首进程是创建该会话的进程）。此时，该进程是新会话中的唯一进程。</li><li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li><li>该进程脱离控制终端。</li></ul></li></ul><p>11）控制终端</p><ul><li>一个会话可以有一个<strong>控制终端</strong>。本地终端（例如：tty1）或远程终端（例如：/pts/0）。</li><li>一个会话中的几个进程组可被分成一个前台进程组（foreground process group）以及一个或多个后台进程组（background process group）。</li><li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。</li></ul><p>12）和信号相关的信息</p><ul><li><code>Ctrl+C</code> 发送<code>SIGINT</code>信号，终止进程</li><li><code>Ctrl+\</code> 发送<code>SIGQUIT</code>信号，终止进程并产生<strong>coredump</strong></li><li>关闭<code>session</code>，发送<code>SIGHUP</code>信号</li><li>浮点异常时产生<code>SIGFPE</code>信号，比如除以0</li><li>段错误时产生<code>SIGSEGV</code>信号</li></ul><p>相关的<code>linux</code>命令</p><ul><li>进程相关</li></ul><pre class="line-numbers language-none"><code class="language-none">ps -elfps auxps ajxfpstree -Auptop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>线程相关</p><pre class="line-numbers language-none"><code class="language-none">ps -eLfps -Lw &lt;pid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>信号相关</p><pre class="line-numbers language-none"><code class="language-none">kill -lman 7 signalulimit -aman 5 coreman 5 limits.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>和终端终端相关</p><pre class="line-numbers language-none"><code class="language-none">stty --helpbgfgkill -&lt;signo&gt; &lt;%jobid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p><code>php</code>多进程主要是在<code>CLI</code>（命令行模式）下应用。</p></li><li><p> <code>php</code>多进程需要安装<code>pcntl</code>（process control）和<code>posix</code>扩展（windows不支持）。</p></li></ul><p>确认扩展是否都有安装：</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ~]# php -m | grep -E 'pcntl|posix'pcntlposix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译时<code>pcntl</code>扩展默认是不安装的，记得编译配置时加上<code>--enable-pcntl</code>参数；<code>posix</code>扩展默认安装，只要你编译时没有加上<code>--disable-posix</code>。</p><h2 id="2-主要函数详解"><a href="#2-主要函数详解" class="headerlink" title="2. 主要函数详解"></a>2. 主要函数详解</h2><h3 id="pcntl-fork-创建子进程"><a href="#pcntl-fork-创建子进程" class="headerlink" title="pcntl_fork() 创建子进程"></a>pcntl_fork() 创建子进程</h3><p>例子1：创建一个子进程 fork1.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"11111111111111111111\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//  返回值为-1,创建失败</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'could not fork'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 子进程中</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I'm child pid：%d ppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 父进程中</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I'm parent pid：%d ppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"2222222222222222222\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cli" data-language="cli"><div class="caption"><span>```下运行结果为：</span></div><code class="language-cli">```ssh[dendi875@localhost process]$ php fork1.php11111111111111111111I'm parent pid：7526 ppid：27892222222222222222222I'm child pid：7527 ppid：75262222222222222222222<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码说明<code>pcntl_fork()</code>函数调用成功后，在父进程中会返回子进程的<code>PID</code>，而在子进程中返回的是<code>0</code>。</p><p>例子2：创建多个子进程 fork2.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** *循环创建多个进程 */</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//  返回值为-1，创建失败</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'could not fork'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 子进程中</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I'm %d child pid：%d ppid：%d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 父进程中</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I'm %d parent pid：%d ppid：%d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cli" data-language="cli"><div class="caption"><span>```下运行结果为：</span></div><code class="language-cli">```ssh[dendi875@localhost process]$ php fork2.phpI'm 0 parent pid：7785 ppid：2789I'm 1 parent pid：7785 ppid：2789I'm 2 parent pid：7785 ppid：2789I'm 2 child pid：7788 ppid：7785I'm 1 child pid：7787 ppid：7785I'm 2 parent pid：7787 ppid：7785I'm 0 child pid：7786 ppid：7785I'm 1 parent pid：7786 ppid：7785I'm 2 parent pid：7786 ppid：7785I'm 2 child pid：7789 ppid：7787[dendi875@localhost process]$ I'm 1 child pid：7790 ppid：7786I'm 2 parent pid：7790 ppid：7786I'm 2 child pid：7791 ppid：7786I'm 2 child pid：7792 ppid：7790<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析为什么会出现8个进程，printf了14次？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/fork.png" alt="fork"></p><p>例子3：循环创建多个子进程改进版 fork3.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** *循环创建多个进程 */</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//  返回值为-1，创建失败</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'could not fork'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 子进程中</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I'm %d child pid：%d ppid：%d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 父进程中</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I'm %d parent pid：%d ppid：%d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cli" data-language="cli"><div class="caption"><span>```下运行结果为</span></div><code class="language-cli">```shell[dendi875@localhost process]$ php fork3.phpI'm 0 parent pid：7776 ppid：2789I'm 1 parent pid：7776 ppid：2789I'm 2 parent pid：7776 ppid：2789I'm 2 child pid：7779 ppid：7776I'm 1 child pid：7778 ppid：7776I'm 0 child pid：7777 ppid：7776<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在循环中创建子进程需要注意以下两点：</p><p>1）子进程代码中要<code>exit</code>防止子进程再<code>fork</code>子进程，进入子进程的循环把系统的资源耗尽。</p><p>2）父进程代码中不要<code>exit</code>否则会终止多进程。</p><h3 id="pcntl-signal-注册信号处理函数和pcntl-signal-dispatch-检测是否有有信号未处理"><a href="#pcntl-signal-注册信号处理函数和pcntl-signal-dispatch-检测是否有有信号未处理" class="headerlink" title="pcntl_signal 注册信号处理函数和pcntl_signal_dispatch 检测是否有有信号未处理"></a>pcntl_signal 注册信号处理函数和pcntl_signal_dispatch 检测是否有有信号未处理</h3><p>例子：signal.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function-definition function">signalHandler</span><span class="token punctuation">(</span><span class="token variable">$signo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token variable">$signo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token constant">SIGINT</span><span class="token punctuation">:</span>            <span class="token comment">// 处理按`Ctrl-C`时发送的SIGINT（2）信号</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"handle signal SIGINT （%d）\n"</span><span class="token punctuation">,</span> <span class="token variable">$signo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token constant">SIGHUP</span><span class="token punctuation">:</span>            <span class="token comment">// 处理关闭`session`时发送的SIGHUP（1）信号</span>            <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"handle signal SIGHUP （%d）\n"</span><span class="token punctuation">,</span> <span class="token variable">$signo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'t.log'</span><span class="token punctuation">,</span> <span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token constant">SIGTERM</span><span class="token punctuation">:</span>            <span class="token comment">// 处理`kill`命令默认发送的SIGTERM（15）信号</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"handle signal SIGTERM （%d）\n"</span><span class="token punctuation">,</span> <span class="token variable">$signo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token comment">// 处理其它信号</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 注册一个信号处理器，当接收到SIGINT、SIGHUP、SIGTERM信号时调用signalHandler函数</span><span class="token function">pcntl_signal</span><span class="token punctuation">(</span><span class="token constant">SIGINT</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'signalHandler'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pcntl_signal</span><span class="token punctuation">(</span><span class="token constant">SIGHUP</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'signalHandler'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pcntl_signal</span><span class="token punctuation">(</span><span class="token constant">SIGTERM</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'signalHandler'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">pcntl_signal_dispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检测是否有末决信号待处理，调用相应的信号处理函数</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"hello, %d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li><code>pcntl_signal()</code>函数仅仅是注册信号和它的处理方法，检测信号并调用其处理方法的函数是<code>pcntl_signal_dispatch()</code>。</li><li>9号信号（<strong>SIGKILL</strong>）和19号信号（<strong>SIGSTOP</strong>）不能被捕捉、不能被忽略、不能被阻塞。</li></ul><h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul><li><p>所谓孤儿进程，顾名思义，和现实生活中的孤儿有点类似，当一个进程的<strong>父进程结束</strong>时，但是它自己还没有结束，那么这个进程将会成为孤儿进程。最后孤儿进程将会被<code>init进程</code>（进程号为1）的进程收养，当然在子进程结束时也会由init进程完成对它的状态收集工作，因此一般来说，孤儿进程并不会有什么危害。</p></li><li><p>孤儿进程实例：orphan.php</p></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function-definition function">pr_ids</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"%s：pid = %d, ppid = %d, pgid = %d, sid = %d\n"</span><span class="token punctuation">,</span>        <span class="token variable">$name</span><span class="token punctuation">,</span> <span class="token variable">$pid</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getpgid</span><span class="token punctuation">(</span><span class="token variable">$pid</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getsid</span><span class="token punctuation">(</span><span class="token variable">$pid</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">/* 子进程中 */</span>        <span class="token function">pr_ids</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 睡眠3s，保证父进程先退出，子进程成为孤儿进程 */</span>        <span class="token function">pr_ids</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"now child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 父进程睡眠1s，保证子进程先运行     * 在子进程还没有成为孤儿进程前打印父进程ID和子进程成为孤儿进程后打印的父进程ID做对比     */</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pr_ids</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"parent process is exited.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost process]# php orphan.phpchild：pid = 29615, ppid = 29614, pgid = 29614, sid = 7937parent：pid = 29614, ppid = 21998, pgid = 29614, sid = 7937parent process is exited.[root@localhost process]# now child：pid = 29615, ppid = 1, pgid = 29614, sid = 7937<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上例子中，在<code>run</code>函数中，创建子进程，然后让父进程睡眠1s，让子进程先打印出其进程<code> id（pid）</code>以及父进程<code> id（ppid）</code>；随后子进程睡眠3s（此时会调度到父进程运行直结束），目的是让<strong>父进程先于子进程结束</strong>，让子进程有个孤儿的状态；最后子进程再打印出其进程<code>id(pid)</code>以及父进程<code>id(ppid)</code>；观察两次打印 其父进程<code>id(ppid)</code>的区别。</p><p>从运行结果来看：当其父进程结束后，子进程成为了孤儿进程，其父进程<code>id(ppid)</code>为1，也就是说，<code>init进程</code>成为该子进程的父进程了。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><blockquote><p>当一个进程正常或异步终止时，内核就向其父进程发送 <code>SIGCHLD</code>信号。因为子进程终止是个异步事件（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。对于这种信号的系统默认动作是忽略它。–APUE</p></blockquote><ul><li>僵尸进程实例：zombie.c</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** * 僵尸进程实例 */</span><span class="token keyword">function</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">/* 子进程中 */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I am child process pid：%d\tppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"child process is exited.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/* 子进程正常退出 */</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I am parent process pid：%d\tppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行查看</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">root@vultr:/data1/www/test/php/process# php zombie.phpI am parent process pid：25210  ppid：24032I am child process pid：25211   ppid：25210child process is exited.I am parent process pid：25210  ppid：24032I am parent process pid：25210  ppid：24032...（省略）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再打开一个终端查看进程状态</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">root@vultr:~# ps -elf...（省略）0 S root     25312 24032  0  80   0 - 19076 hrtime 03:07 pts/0    00:00:00 php zombie.php1 Z root     25313 25312  0  80   0 -     0 -      03:07 pts/0    00:00:00 [php] &lt;defunct&gt;...（省略）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>僵尸进程是指：一个进程使用<code>fork</code>创建子进程，如果<strong>子进程退出</strong>，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么子进程的某些信息如进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p><p>我们详细理解下，在<code>UNIX/Linux</code>中，正常情况下，子进程是通过父进程<code>fork</code> 创建的。子进程和父进程的运行是一个异步过程，理论上父进程无法知道子进程的运行状态。但知道子进程运行状态是一个很合理的需求，所以<code>UNIX</code> 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是: 在每个进程退出的时候，内核释放该进程的一部分资源，包括<strong>打开的文件</strong>、<strong>占用的内存</strong>等，同时仍然为其保留一定的信息（包括<strong>进程号</strong>，<strong>退出状态</strong>，<strong>运行时间</strong>等）。父进程可以通过<code>wait()/waitpid()</code>来获取这些信息，然后操作系统才释放。</p><p>如果父进程不调用<code>wait()/waitpid()</code> 的话，那么保留的信息就不会释放，其进程号就会一直被占用，就像僵尸一样，所以把这些进程称为僵尸进程。</p><h3 id="pcntl-waitpid-回收僵尸进程"><a href="#pcntl-waitpid-回收僵尸进程" class="headerlink" title="pcntl_waitpid 回收僵尸进程"></a>pcntl_waitpid 回收僵尸进程</h3><p>例子1：<code>waitpid</code> 阻塞/非阻塞回收指定的子进程 waitpid.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** * 使用waitpid阻塞/非阻塞回收指定的子进程 */</span><span class="token comment">/** * 打印进程退出状态 */</span><span class="token keyword">function</span> <span class="token function-definition function">pr_exit</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifexited</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"normal termination, exit status = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wexitstatus</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifsignaled</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abnormal termination, signal number = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wtermsig</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifstopped</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"child stoped, signal number = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wstopsig</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">/* 子进程中 */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I am child process pid：%d\tppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"child process is exited.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$status</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I am parent process pid：%d\tppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//$wid = pcntl_waitpid($pid, $status, 0);</span>        <span class="token variable">$wid</span> <span class="token operator">=</span> <span class="token function">pcntl_waitpid</span><span class="token punctuation">(</span><span class="token variable">$pid</span><span class="token punctuation">,</span> <span class="token variable">$status</span><span class="token punctuation">,</span> <span class="token constant">WNOHANG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$wid</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"waitpid error：%s\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_strerror</span><span class="token punctuation">(</span><span class="token function">pcntl_errno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$wid</span> <span class="token operator">==</span> <span class="token variable">$pid</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">pr_exit</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"wait for child wid = %d\n"</span><span class="token punctuation">,</span> <span class="token variable">$wid</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子2：waitpid阻塞/非阻塞回收多个子进程实例 waitpid2.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** * waitpid阻塞/非阻塞回收多个子进程实例 */</span><span class="token comment">/** * 打印进程退出状态 */</span><span class="token keyword">function</span> <span class="token function-definition function">pr_exit</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifexited</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"normal termination, exit status = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wexitstatus</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifsignaled</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abnormal termination, signal number = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wtermsig</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifstopped</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"child stoped, signal number = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wstopsig</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$status</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>    <span class="token variable">$childs</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">/* 子进程中 */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I am child process pid：%d\tppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// sleep($i+1);  /* 非阻塞时打开注释 */</span>            <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">/* 父进程中 */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"I am parent process pid：%d\tppid：%d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">posix_getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$childs</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$pid</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$childs</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$childs</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=&gt;</span> <span class="token variable">$pid</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$wid</span> <span class="token operator">=</span> <span class="token function">pcntl_waitpid</span><span class="token punctuation">(</span><span class="token variable">$pid</span><span class="token punctuation">,</span> <span class="token variable">$status</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/* 阻塞*/</span>            <span class="token comment">// $wid = pcntl_waitpid($pid, $status, WNOHANG);  /* 非阻塞 */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$wid</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"waitpid error：%s\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_strerror</span><span class="token punctuation">(</span><span class="token function">pcntl_errno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$wid</span> <span class="token operator">==</span> <span class="token variable">$pid</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">unset</span><span class="token punctuation">(</span><span class="token variable">$childs</span><span class="token punctuation">[</span><span class="token variable">$key</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">pr_exit</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"wait for child wid = %d\n"</span><span class="token punctuation">,</span> <span class="token variable">$wid</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码输出：</p><pre class="line-numbers language-none"><code class="language-none">[root@localhost process]# ./wait-nohang.phpparent  8288    7870    1542632609.5141wait return is 0parent  8288    7870    1542632609.5142wait return is 0parent  8288    7870    1542632609.5144wait return is 0child   8291    8288    1542632609.5172child   8290    8288    1542632609.5174child   8289    8288    1542632609.5178<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子3：使用信号处理函数来回收僵尸进程 sigchld.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** * 使用信号处理函数来回收僵尸进程 */</span><span class="token comment">/** * 打印进程退出状态 */</span><span class="token keyword">function</span> <span class="token function-definition function">pr_exit</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifexited</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"normal termination, exit status = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wexitstatus</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifsignaled</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"abnormal termination, signal number = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wtermsig</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pcntl_wifstopped</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"child stoped, signal number = %d\n"</span><span class="token punctuation">,</span> <span class="token function">pcntl_wstopsig</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * SIGCHLD 信号处理函数 */</span><span class="token keyword">function</span> <span class="token function-definition function">sig_chld</span><span class="token punctuation">(</span><span class="token variable">$signo</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$status</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">$status</span><span class="token punctuation">,</span> <span class="token constant">WNOHANG</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pr_exit</span><span class="token punctuation">(</span><span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">/* 子进程中 */</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/* 10个子进程 */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"child ID %d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//posix_kill(posix_getpid(), SIGABRT);</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">/* 一个父进程 */</span>        <span class="token comment">// 安装 SIGCHLD 信号处理函数</span>        <span class="token function">pcntl_signal</span><span class="token punctuation">(</span><span class="token constant">SIGCHLD</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'sig_chld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">pcntl_signal_dispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 检测是否有未处理的信号 */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"parent ID %d\n"</span><span class="token punctuation">,</span> <span class="token function">posix_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：</p><p>1）<code>pcntl_waitpid(-1, $status, 0)</code>行为等价于函数<code>pcntl_wait($status)</code></p><p>2）多理解<code>pcntl_waitpid</code>函数的<code>pid</code>的4种情况（&lt; -1, -1, 0, &gt; 0）及3种返回值（0, &gt; 0, -1）。</p><p>这里要理解多进程程序中父进程阻塞与非阻塞的区别</p><ul><li>阻塞： 父进程一直等待，直到收到一个子进程结束的信号再执行。</li><li>非阻塞：父进程和子进程同时执行，不用等子进程执行完。在子进程退出后，再回收。</li></ul><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><blockquote><p>守护进程（daemon）是一种生存期很长的一种进程。它们通常是在系统开机时启动，在系统关闭时才终止。它们脱离控制终端在后台长期运行为我们提供某种服务。守护进程程序的名称通常以字母“d”结尾，例如<strong>syslogd</strong>就是指管理系统日志的守护进程。</p></blockquote><p>创建一个守护进程实例</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** * 创建一个守护进程 */</span><span class="token keyword">function</span> <span class="token function-definition function">daemonize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/**     *重新设置文件权限掩码     */</span>    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 调用fork创建子进程，父进程退出，保证了子进程不是一个组长进程，这是执行setsid调用的先决条件     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">/* 父进程中 */</span>        <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 创建一个会话，使进程成为会话首进程并脱离控制终端     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">posix_setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"setsid error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 再次fork避免在System V的系统中，重新获取对终端的控制     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pid</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 改变当前工作目录     */</span>    <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function-definition function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">daemonize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建守护进程步骤：</p><p>1）重新设置文件权限掩码。<strong>umask</strong> 函数，防止使用继承过来的掩码来创建文件可能会被设置为拒绝某些权限</p><p>2）调用<strong>fork</strong>创建子进程，父进程退出。保证了子进程不是一个组长进程，这是执行<strong>setsid</strong>调用的先决条件</p><p>3）调用setsid创建一个新的会话。目的是使调用进程：</p><ul><li><p>成为新会话的首进程</p></li><li><p>成为一个新进程组的组长进程</p></li><li><p>脱离控制终端</p></li></ul><p>4）调用<strong>chdir</strong>更改当前工作目录，一般为根目录。防止占用可卸载的文件系统</p><p>5）关闭所有的文件描述符。从父进程继承过来的文件描述符不会再被用到，如果不关闭就浪费了系统资源</p><p>6）使0、1、2文件描述符指向<code>/dev/null</code>。目的是使任何一个试图从标准输入读、写到标准输出、写到标准错误的程序都不会产生效果，因为守护进程并不与终端设备相关联，所以其输出无处显示，也无处从交互式用户那里接收输入。</p><h2 id="3-如何让挂掉的服务自动启动"><a href="#3-如何让挂掉的服务自动启动" class="headerlink" title="3. 如何让挂掉的服务自动启动"></a>3. 如何让挂掉的服务自动启动</h2><ul><li> <code>nohup</code>与<code>&amp;</code>的区别</li></ul><p>测试代码如下 hello.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"hello, %d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>使用 <code>php hello.php</code>前台运行，效果如下</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost process]# php hello.phphello, 0hello, 1hello, 2hello, 3^C[root@localhost process]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时键入<code>Ctrl-C</code>，程序会收到一个<code>SIGINT</code>信号，如果不做特殊处理，程序的默认行为是终止。</p></li><li><p>使用<code>php hello.php &amp;</code>后台运行程序，效果如下</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost process]# php hello.php &amp;[2] 31540[root@localhost process]# hello, 0hello, 1^C[root@localhost process]# hello, 2hello, 3^C[root@localhost process]# hello, 4hello, 5hello, 6hello, 7hello, 8^C[root@localhost process]# hello, 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ~]# ps aux | grep helloroot     31540  0.1  0.7  35964  7776 pts/0    S    17:33   0:00 php hello.phproot     31544  0.0  0.0   5976   748 pts/1    S+   17:33   0:00 grep --color=auto hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到首先会在终端显示进程号31540，键入<code>Ctrl-C</code>，发送<code>SIGINT</code>信号，<strong>程序会继续运行</strong>。<code>ps</code>查看进程的确在运行。</p><p>此时关掉<code>session</code>，程序会收到一个<code>SIGHUP</code>信号，此时会怎么样？</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ~]# ps aux | grep helloroot     31792  0.0  0.0   5976   748 pts/1    S+   18:07   0:00 grep --color=auto hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-ps" data-language="ps"><div class="caption"><span>```再次确认，可以看到关闭``` session ```之后，进程号是31540的``` hello.php ```的进程也关闭了。</span></div><code class="language-ps">* 使用``` nohup php hello.php ```效果是怎么样？``` ssh[root@localhost process]# nohup php hello.phpnohup: 忽略输入并把输出追加到"nohup.out"[root@localhost ~]# ps aux | grep hello.phproot     31835  0.1  0.7  35964  7776 pts/0    S+   18:10   0:00 php hello.phproot     31863  0.0  0.0   5976   752 pts/1    S+   18:11   0:00 grep --color=auto hello.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>nohup</code>运行程序后，用<code>ps</code>查看进程号是31835。此时关掉<code>session</code>，程序会收到一个<code>SIGHUP</code>信号，程序会不会关闭呢？</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ~]# ps aux | grep hello.phproot     31835  0.0  0.7  35964  7776 ?        S    18:10   0:00 php hello.phproot     31881  0.0  0.0   5976   756 pts/1    S+   18:13   0:00 grep --color=auto hello.php[root@localhost ~]# ps aux | grep hello.phproot     31835  0.0  0.7  35964  7776 ?        S    18:10   0:00 php hello.phproot     31883  0.0  0.0   5976   752 pts/1    S+   18:13   0:00 grep --color=auto hello.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关掉<code>session</code>后，再次<code>ps</code>查看，<code>PID</code>为31835的进程还在。只能通过<code>kill</code>杀掉。</p><ul><li>测试下<code>nohup php hello.php</code>后按<code>Ctrl-C</code>会发生什么？</li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost process]# nohup php hello.phpnohup: 忽略输入并把输出追加到"nohup.out"^C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到键入<code>Ctrl-C</code>，程序收到<code>SIGINT</code>信号后，程序关闭了。</p><ul><li>最后测试下<code>nohup</code>和<code>&amp;</code>，同时使用，即<code>nohup php hello.php &amp;</code>会怎么样？</li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost process]# nohup php hello.php &amp;[1] 32004[root@localhost process]# nohup: 忽略输入并把输出追加到"nohup.out"^C[root@localhost process]# ^C[root@localhost process]# ^C[root@localhost process]# ps aux | grep hello.phproot     32004  0.0  0.7  35964  7776 pts/0    S    18:27   0:00 php hello.phproot     32015  0.0  0.0   5976   780 pts/0    S+   18:28   0:00 grep --color=auto hello.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时键入<code>Ctrl-C</code>，发送<code>SIGINT</code>信号，该进程还在。<br>此时关闭<code>session</code>，发送<code>SIGHUP</code>信号，再来看看进程还在不在？</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ~]# ps aux | grep hello.phproot     32004  0.1  0.7  35964  7776 ?        S    18:27   0:00 php hello.phproot     32053  0.0  0.0   5976   756 pts/1    S+   18:29   0:00 grep --color=auto hello.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到关闭<code>session</code>，后进程还在，现在也只能使用<code>kill</code>来杀掉。</p><p>结论<br>使用<code>&amp;</code>后台运行程序：</p><blockquote><p>使用<code>Ctrl-C</code>发送<code>SIGINT</code>信号，进程免疫。</p><p>关闭<code>session</code>发送<code>SIGHUP</code>信号，进程终止。</p></blockquote><p>使用<code>nohup</code>运行程序：</p><blockquote><p>使用<code>Ctrl-C</code>发送<code>SIGINT</code>信号，进程终止。</p><p>关闭<code>session</code>发送<code>SIGHUP</code>信号，进程免疫。</p></blockquote><p>使用<code>&amp;nohup</code>和<code>&amp;</code>来配合启动程序：</p><blockquote><p>同时免疫<code>SIGINT</code>和<code>SIGHUP</code>信号</p></blockquote><p>思考：如果使用了<code>nohup</code>和<code>&amp;</code>启动程序后，程序因异常情况被<code>kill</code>掉，如何让程序自动启动？</p><h2 id="4-进程的守护神daemontools和supervisor"><a href="#4-进程的守护神daemontools和supervisor" class="headerlink" title="4. 进程的守护神daemontools和supervisor"></a>4. 进程的守护神daemontools和supervisor</h2><p>daemontools：<a href="https://github.com/dendi875/Linux/blob/master/daemontools.md">https://github.com/dendi875/Linux/blob/master/daemontools.md</a></p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul><li><a href="https://book.douban.com/subject/1788421/">APUE</a></li><li><a href="https://www.php.net/manual/zh/book.posix.php">PHP：POSIX</a></li><li><a href="https://www.php.net/manual/zh/book.pcntl.php">PHP：PCNTL</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的 4 个阶段的撤销更改</title>
      <link href="/2021/06/29/git-de-4-ge-jie-duan-de-che-xiao-geng-gai/"/>
      <url>/2021/06/29/git-de-4-ge-jie-duan-de-che-xiao-geng-gai/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-的-4-个阶段的撤销更改"><a href="#Git-的-4-个阶段的撤销更改" class="headerlink" title="Git 的 4 个阶段的撤销更改"></a>Git 的 4 个阶段的撤销更改</h1><blockquote><p>原文出处：<a href="https://www.fengerzh.com/git-reset/">张京</a></p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/63918611gy1fltan48ktfj21hm12y7f5.jpg" alt="img"></p><p>虽然git诞生距今已有12年之久，网上各种关于git的介绍文章数不胜数，但是依然有很多人（包括我自己在内）对于它的功能不能完全掌握。以下的介绍只是基于我个人对于git的理解，并且可能生编硬造了一些不完全符合git说法的词语。目的只是为了让git通俗化，使初学者也能大概了解如何快速上手git。同时，下面所有讨论，我们都假设只使用一个分支，也就是主分支master的情况，虽然这种作法并不符合git规范，但是现实情况中绝大部分用户是直接在master分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签tag的操作，只讲在最简单的主分支上如何回退。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="3个步骤"><a href="#3个步骤" class="headerlink" title="3个步骤"></a>3个步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/63918611gy1fltan4vu1cj20m80463yo.jpg" alt="img"></p><p>正常情况下，我们的工作流就是3个步骤，对应上图中的3个箭头线：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git add .git commit -m "comment"git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><code>git add .</code> 把所有文件放入<code>暂存区</code>；</li><li><code>git commit</code> 把所有文件从<code>暂存区</code>提交进<code>本地仓库</code>；</li><li><code>git push</code> 把所有文件从<code>本地仓库</code>推送进<code>远程仓库</code>。</li></ol><h3 id="4个区"><a href="#4个区" class="headerlink" title="4个区"></a>4个区</h3><p>git之所以令人费解，主要是它相比于svn等等传统的版本管理工具，多引入了一个<strong>暂存区</strong>(Stage)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么4个区就够了：</p><ul><li>工作区(Working Area)</li><li>暂存区(Stage)</li><li>本地仓库(Local Repository)</li><li>远程仓库(Remote Repository)</li></ul><h3 id="5种状态"><a href="#5种状态" class="headerlink" title="5种状态"></a>5种状态</h3><p>以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。以下我们把这5种状态分别命名为：</p><ul><li>未修改(Origin)</li><li>已修改(Modified)</li><li>已暂存(Staged)</li><li>已提交(Committed)</li><li>已推送(Pushed)</li></ul><h2 id="检查修改"><a href="#检查修改" class="headerlink" title="检查修改"></a>检查修改</h2><p>了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这3个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是diff，只是参数有所不同。</p><h3 id="已修改，未暂存"><a href="#已修改，未暂存" class="headerlink" title="已修改，未暂存"></a>已修改，未暂存</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做<code>git add .</code>之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/63918611gy1fltan5a4xuj20fi07z3zc.jpg" alt="img"></p><p>我们在文件开头的第2行胡乱加了4个数字<code>1234</code>，存盘，这时文件进入了已修改状态，但是还没有进入<code>暂存区</code>，我们运行<code>git diff</code>，结果如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md&lt;a href='http://www.jobbole.com/members/li754132448'&gt;@@&lt;/a&gt; -1,5 +1,5 &lt;a href='http://www.jobbole.com/members/li754132448'&gt;@@&lt;/a&gt; ----layout: main+1234layout: main color: black ---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git diff</code>的结果告诉我们哪些文件已经做了哪些修改。</p><h3 id="已暂存，未提交"><a href="#已暂存，未提交" class="headerlink" title="已暂存，未提交"></a>已暂存，未提交</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff --cached<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在我们把修改放入<code>暂存区</code>看一下。先执行<code>git add .</code>，然后执行<code>git diff</code>，你会发现没有任何结果：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/63918611gy1fltan5m82pj20ag01rt8l.jpg" alt="img"></p><p>这说明<code>git diff</code>这个命令只检查我们的<code>工作区</code>和<code>暂存区</code>之间的差异，如果我们想看到<code>暂存区</code>和<code>本地仓库</code>之间的差异，就需要加一个参数<code>git diff --cached</code>：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md&lt;a href='http://www.jobbole.com/members/li754132448'&gt;@@&lt;/a&gt; -1,5 +1,5 &lt;a href='http://www.jobbole.com/members/li754132448'&gt;@@&lt;/a&gt; ----layout: main+1234layout: main color: black ---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候我们看到的差异是<code>暂存区</code>和<code>本地仓库</code>之间的差异。</p><h3 id="已提交，未推送"><a href="#已提交，未推送" class="headerlink" title="已提交，未推送"></a>已提交，未推送</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff master origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们把修改从<code>暂存区</code>提交到<code>本地仓库</code>，再看一下差异。先执行<code>git commit</code>，然后再执行<code>git diff --cached</code>，没有差异，执行<code>git diff master origin/master</code>，可以看到差异：</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/63918611gy1fltan637jhj20en076aas.jpg" alt="img"></p><p>在这里，<code>master</code>就是你的本地仓库，而<code>origin/master</code>就是你的远程仓库，<code>master</code>是主分支的意思，因为我们都在主分支上工作，所以这里两边都是<code>master</code>，而<code>origin</code>就代表远程。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。</p><h3 id="已修改，未暂存-1"><a href="#已修改，未暂存-1" class="headerlink" title="已修改，未暂存"></a>已修改，未暂存</h3><p>如果我们只是在编辑器里修改了文件，但还没有执行<code>git add .</code>，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git reset --hard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来进行撤销操作。</p><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/63918611gy1fltan6hur7j20c9075jrr.jpg" alt="img"></p><p>可以看到，在执行完<code>git checkout .</code>之后，修改已被撤销，<code>git diff</code>没有任何内容了。</p><blockquote><p><strong>一对反义词</strong> <code>git add .</code>的反义词是<code>git checkout .</code>。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行<code>git add .</code>，如果你想向后退一步，撤销刚才的修改，就执行<code>git checkout .</code>。</p></blockquote><h3 id="已暂存，未提交-1"><a href="#已暂存，未提交-1" class="headerlink" title="已暂存，未提交"></a>已暂存，未提交</h3><p>你已经执行了<code>git add .</code>，但还没有执行<code>git commit -m "comment"</code>。这时候你意识到了错误，想要撤销，你可以执行：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git resetgit checkout .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git reset --hard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>git reset</code>只是把修改退回到了<code>git add .</code>之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行<code>git checkout .</code>。</p><p>或许你已经注意到了，以上两个步骤都可以用同一个命令<code>git reset --hard</code>来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。</p><h3 id="已提交，未推送-1"><a href="#已提交，未推送-1" class="headerlink" title="已提交，未推送"></a>已提交，未推送</h3><p>你的手太快，你既执行了<code>git add .</code>，又执行了<code>git commit</code>，这时候你的代码已经进入了你的本地仓库，然而你后悔了，怎么办？不要着急，还有办法。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git reset --hard origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还是这个<code>git reset --hard</code>命令，只不过这次多了一个参数<code>origin/master</code>，正如我们上面讲过的，<code>origin/master</code>代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。</p><h3 id="已推送"><a href="#已推送" class="headerlink" title="已推送"></a>已推送</h3><p>很不幸，你的手实在是太快了，你既<code>git add</code>了，又<code>git commit</code>了，并且还<code>git push</code>了，这时你的代码已经进入远程仓库。如果你想恢复的话，还好，由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git reset --hard HEAD^git push -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/63918611gy1fltan6vs0lj20di04d0td.jpg" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上4种状态的撤销我们都用到了同一个命令<code>git reset --hard</code>，前2种状态的用法甚至完全一样，所以只要掌握了<code>git reset --hard</code>这个命令的用法，从此你再也不用担心提交错误了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.fengerzh.com/git-reset/">原文</a></li><li><a href="https://segmentfault.com/a/1190000011910766">独孤求败：Git中的各种后悔药</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 学习研究</title>
      <link href="/2021/06/29/elasticsearch-xue-xi-yan-jiu/"/>
      <url>/2021/06/29/elasticsearch-xue-xi-yan-jiu/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch-学习研究"><a href="#Elasticsearch-学习研究" class="headerlink" title="Elasticsearch 学习研究"></a>Elasticsearch 学习研究</h1><hr><h2 id="1-Elasticsearch-介绍"><a href="#1-Elasticsearch-介绍" class="headerlink" title="1. Elasticsearch 介绍"></a>1. Elasticsearch 介绍</h2><p>Elasticsearch（ES）是基于文本搜索库<a href="https://lucene.apache.org/">Lucene</a>构建的高度可扩展的分布式开源搜索和分析引擎。</p><p>如果有足够的计算机，ES集群通常可以跨非常大的数据集执行搜索和聚合查询。<br>如果你希望对一组文本文档进行传统的全文本搜索（类似于 Google 搜索），则ES很适合，</p><p>Elasticsearch 主要用于搜索和日志分析，也是当今最流行的日志分析平台（ELK）（Elasticsearch，Logstash和Kibana）的核心。它在处理大数据（如：系统日志，网络流量）时非常有用。</p><h2 id="2-Elasticsearch-中的重要概念"><a href="#2-Elasticsearch-中的重要概念" class="headerlink" title="2. Elasticsearch 中的重要概念"></a>2. Elasticsearch 中的重要概念</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/Elasticsearch.png" alt="Elasticsearch"></p><h3 id="2-1-Cluster（集群）"><a href="#2-1-Cluster（集群）" class="headerlink" title="2.1 Cluster（集群）"></a>2.1 Cluster（集群）</h3><p>cluster是一个或一组服务器（节点）的集合，这些节点一起协同保存你的数据，并在所有节点之间为你提供索引和搜索功能。cluster具有唯一名称标识（默认是elasticsearch），你只需要指定集群标识名，启动的时候，凡是集群是这个名字的节点都会默认加到同一个集群中，选举master节点和节点管理都是自动完成的。当然一个节点也可以组成一个集群。</p><h3 id="2-2-Node（节点）"><a href="#2-2-Node（节点）" class="headerlink" title="2.2 Node（节点）"></a>2.2 Node（节点）</h3><p>node是参与到cluster的单个服务器节点，具有唯一标识名，可加入到指定的cluster中。 单个es实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><h3 id="2-3-Index（索引）"><a href="#2-3-Index（索引）" class="headerlink" title="2.3 Index（索引）"></a>2.3 Index（索引）</h3><p>Index是一类文档的集合。例如，你可以为用户数据创建一个索引，为商品数据创建另一个索引，为订单数据创建另一个索引。es 数据管理的顶层单位就叫做 Index（索引），相当于传统数据库中的数据库。每个 Index （即数据库）的名字必须是小写。</p><p>es数据的索引、搜索和分析都是基于索引完成的。每个Index包含多个shard，默认是5个，分散在不同的node上。当索引创建完成的时候，主分片的数量就固定了，但是复制分片的数量可以随时调整。</p><p>在单个cluster中，你可以创建任意个Index。</p><p>下面的命令可以查看当前节点的所有 Index。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X GET 'http://localhost:9200/_cat/indices?v' -d ''health status index  pri rep docs.count docs.deleted store.size pri.store.sizeyellow open   orders   5   1          0            0       650b           650b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-4-Type（类型）"><a href="#2-4-Type（类型）" class="headerlink" title="2.4 Type（类型）"></a>2.4 Type（类型）</h3><p>Type是 Index 中数据的 ，在索引中，你可以定义一个或多个类型。它是索引中虚拟逻辑的分组，用来过滤    Document ，相当于传统数据库的表。</p><p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个 Type 是字符串，在另 Type 是数值。这是与关系型数据库的表的一个<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/mapping.html">区别</a>。</p><p>举例来说，在一个商城系统中，你可以定义一个订单的 type（orders_order），可以定义一个商品的 type（orders_product），还可以定义一个日志的 type（orders_log）。</p><p>下面的命令可以列出每个 Index 所包含的 Type。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl 'http://localhost:9200/_mapping?pretty=true'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-Document（文档）"><a href="#2-5-Document（文档）" class="headerlink" title="2.5 Document（文档）"></a>2.5 Document（文档）</h3><p>Document是es数据可被索引化的基本的存储单元，需要存储在Type中，相当于传统数据库的行记录。</p><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p><p>Document 使用 JSON 格式表示，下面是一个例子。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">{  "name": "张三",  "title": "工程师",  "desc": "数据库管理"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-Shard（分片）"><a href="#2-6-Shard（分片）" class="headerlink" title="2.6 Shard（分片）"></a>2.6 Shard（分片）</h3><p>一个索引可能会存储大量的数据，进而会让单个节点超出硬件能承受范围。举例来说，存储了10亿文档的单个节点，会占用1TB磁盘空间，并且会导致查询的时候速度很慢。</p><p>为了解决这个问题，Elasticsearch 提供了分片，也就是将index细分为多个碎片的功能。当你创建index的时候，你可以简单地指定你想要的分片数量。每一个分片具有和 index 完全相同的功能。</p><p>碎片最主要的两个作用是：</p><ul><li>它允许你水平地切割你的容量体积</li><li>它允许你并行地分发作业，提高系统的性能</li></ul><p>默认在创建索引时会创建5个分片，这个数量可以修改。分片的数量只能在创建索引的时候指定，不能在后期修改。</p><h3 id="2-7-Replicas（副本）"><a href="#2-7-Replicas（副本）" class="headerlink" title="2.7 Replicas（副本）"></a>2.7 Replicas（副本）</h3><p>因为各种原因，所以数据丢失等问题会时有发生，碎片也可能会丢失，为了防止这个问题，所以你可以将一个或多个索引碎片复制到所谓的复制碎片，简称为副本。</p><p>副本最主要的两个作用是：</p><ul><li>它提供了高可用性，以防碎片/节点失败。基于这点，所以副本的永远不要和原始碎片分布在同一个节点上</li><li>它可以扩展系统的吞吐量，因为搜索可以在所有副本上执行</li></ul><p>默认情况下，Elasticsearch为每个索引分配了5个主碎片和1个副本，这意味着在你的集群中，如果至少有两个节点，那么每个索引将有5个主碎片和5个复制碎片，每个索引总共10个碎片。</p><p>将Elasticsearch和传统关系型数据库Mysql做一下类比：</p><table><thead><tr><th>MySQL</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>Database（数据库）</td><td>Index（索引）</td></tr><tr><td>Table（表）</td><td>Type（类型）</td></tr><tr><td>Row（行）</td><td>Document（文档）</td></tr><tr><td>Column（列）</td><td>Field（字段）</td></tr><tr><td>Schema（方案）</td><td>Mapping（映射）</td></tr><tr><td>Index（索引）</td><td>Everything Indexed by default（默认情况下所有字段都被索引）</td></tr><tr><td>SQL（结构化查询语言）</td><td>Query DSL（查询专用语言）</td></tr></tbody></table><h2 id="3-Elasticsearch-安装和配置"><a href="#3-Elasticsearch-安装和配置" class="headerlink" title="3. Elasticsearch 安装和配置"></a>3. Elasticsearch 安装和配置</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>Elasticsearch 至少需要 Java 7  环境。如果你的机器还没安装 Java，可以参考<a href="https://www.liquidweb.com/kb/install-java-8-on-centos-7/">这篇文章</a>。</p><p>安装完 Java，就可以跟着<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/_installation.html#_installation">官方文档</a>安装 Elasticsearch。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># cd /usr/local/software/# curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.3.tar.gz# # tar -zxvf elasticsearch-5.5.3.tar.gz  -C /usr/local/# # cd /usr/local/elasticsearch-5.5.3/# ./bin/elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果这时报错”Exception in thread “main” java.lang.RuntimeException: don’t run elasticsearch as root.”，表示不能以超级用户root启动es，我们新建一个用户：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># useradd es# passwd es# chown -R es:es /usr/local/elasticsearch-5.5.3/# su - es$ /usr/local/elasticsearch-5.5.3/bin/elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果这时报错“max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]”，这表示文件描述符太少了，我们需要设置文件描述数量：</p><p>查看<code>es</code>用户硬限制：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ulimit -Hn4096<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开<code>/etc/security/limits.conf</code>增加一行：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">es  - nofile  65536<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出<code>es</code>用户，再重新看硬限制：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ulimit -Hn65536<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果一切正常，es 就会在默认的9200端口运行。开启另一个终端查看es进程和端口：</p><pre class="line-numbers language-none"><code class="language-none"># ps -ef | grep elastices        1753  1726  8 18:14 pts/1    00:00:02 /bin/java -Xms2g -Xmx2g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -server -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -Djdk.io.permissionsUseCanonicalPath=true -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Dlog4j.skipJansi=true -XX:+HeapDumpOnOutOfMemoryError -Des.path.home=/usr/local/elasticsearch-5.5.3 -cp /usr/local/elasticsearch-5.5.3/lib/* org.elasticsearch.bootstrap.Elasticsearchroot      1793  1596  0 18:14 pts/0    00:00:00 grep --color=auto elastic# netstat -tlunp | grep 9200tcp6       0      0 127.0.0.1:9200          :::*                    LISTEN      1753/java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到es已经正常启动，除了查看es进程和端口外，我们还可以执行：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># curl 'http://localhost:9200'{  "name" : "Onl1EgV",  "cluster_name" : "elasticsearch",  "cluster_uuid" : "P3CrVh_BTO-1EVzJlyWXKg",  "version" : {    "number" : "5.5.3",    "build_hash" : "9305a5e",    "build_date" : "2017-09-07T15:56:59.599Z",    "build_snapshot" : false,    "lucene_version" : "6.6.0"  },  "tagline" : "You Know, for Search"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，请求9200端口，es 返回一个 JSON 对象，包含当前节点、集群、版本等信息。</p><p>以上es的运行方式可以通过<code>CTRL+C</code>或关闭窗口来停止运行，平时我们可以通过守护进程的方式在后台启动es：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ ./bin/elasticsearch -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是后台启动后想要停止es，可以通过<code>ps -ef | grep elastic</code>找到es进程PID，然后<code>kill</code>掉就行</p><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h3><p>认情况下，es 只允许本机访问，如果需要远程访问，可以修改 es 安装目录的<em>ES_HOME/config/elasticsearch.yml</em>文件，去掉<strong>network.host</strong>的注释，将它的值改成<code>0.0.0.0</code>，然后重新启动 es。</p><p>如果远程还不能访问可能需要检查下<strong>防火墙</strong>和<strong>SELinux</strong>的设置。</p><p>其它配置项的解释可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/settings.html">官方页面</a></p><h2 id="4-Elasticsearch-插件"><a href="#4-Elasticsearch-插件" class="headerlink" title="4. Elasticsearch 插件"></a>4. Elasticsearch 插件</h2><h3 id="4-1-IK-中文分词插件"><a href="#4-1-IK-中文分词插件" class="headerlink" title="4.1 IK 中文分词插件"></a>4.1 IK 中文分词插件</h3><p>es 内置的分词器对中文不友好，会把中文分成单个字来进行全文检索，不能达到想要的结果，ik 可以进行友好的分词及自定义分词。</p><p>内置的分词器对中文会一个一个拆分，如下面是内置分词器的效果：</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">$ curl -H 'Content-Type: application/json'  -X GET 'localhost:9200/_analyze?pretty' -d '&gt; {&gt; "analyzer": "default",&gt; "text":"今天天气真好"&gt; }&gt; '{  "tokens" : [    {      "token" : "今",      "start_offset" : 0,      "end_offset" : 1,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 0    },    {      "token" : "天",      "start_offset" : 1,      "end_offset" : 2,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 1    },    {      "token" : "天",      "start_offset" : 2,      "end_offset" : 3,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 2    },    {      "token" : "气",      "start_offset" : 3,      "end_offset" : 4,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 3    },    {      "token" : "真",      "start_offset" : 4,      "end_offset" : 5,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 4    },    {      "token" : "好",      "start_offset" : 5,      "end_offset" : 6,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 5    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，安装中文分词插件。这里使用的是<a href="https://github.com/medcl/elasticsearch-analysis-ik/">ik</a></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[es@localhost elasticsearch-5.5.3]$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.3/elasticsearch-analysis-ik-5.5.3.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着，重新启动 Elastic，就会自动加载这个新安装的插件。</p><p>IK支持两种分词模式：</p><ul><li>ik_max_word: 会将文本做最细粒度的拆分，会穷尽各种可能的组合</li><li>ik_smart: 会做最粗粒度的拆分</li></ul><p>接下来，我们看看 IK 分词效果和自带的有什么不同。</p><p>先试一下<code>ik_smart</code>的效果：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"> curl -H 'Content-Type: application/json'  -X GET 'localhost:9200/_analyze?pretty' -d '&gt; {&gt; "analyzer": "ik_smart",&gt; "text":"今天天气真好"&gt; }&gt; '{  "tokens" : [    {      "token" : "今天天气",      "start_offset" : 0,      "end_offset" : 4,      "type" : "CN_WORD",      "position" : 0    },    {      "token" : "真好",      "start_offset" : 4,      "end_offset" : 6,      "type" : "CN_WORD",      "position" : 1    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再试一下<code>ik_max_word</code>的效果：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">{  "tokens" : [    {      "token" : "今天天气",      "start_offset" : 0,      "end_offset" : 4,      "type" : "CN_WORD",      "position" : 0    },    {      "token" : "今天",      "start_offset" : 0,      "end_offset" : 2,      "type" : "CN_WORD",      "position" : 1    },    {      "token" : "天天",      "start_offset" : 1,      "end_offset" : 3,      "type" : "CN_WORD",      "position" : 2    },    {      "token" : "天气",      "start_offset" : 2,      "end_offset" : 4,      "type" : "CN_WORD",      "position" : 3    },    {      "token" : "真好",      "start_offset" : 4,      "end_offset" : 6,      "type" : "CN_WORD",      "position" : 4    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置mapping默认分词器：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">curl -X PUT 'localhost:9200/userdoors' -d '{  "mappings": {    "person": {      "properties": {        "name": {          "type": "text",          "analyzer": "ik_max_word",          "search_analyzer": "ik_max_word"        },        "title": {          "type": "text",          "analyzer": "ik_max_word",          "search_analyzer": "ik_max_word"        },        "desc": {          "type": "text",          "analyzer": "ik_max_word",          "search_analyzer": "ik_max_word"        }      }    }  }}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>面代码中，首先新建一个名称为<code>userdoor</code>的Index，里面有一个名称为<code>person</code>的 Type。person有三个字段<code>name</code>、<code>title</code>、<code>desc</code>。</p><p><strong>注意：</strong> 这里设置<code>search_analyzer</code>与<code>analyzer</code> 相同是为了确保搜索时和索引时使用相同的分词器，以确保查询中的术语与反向索引中的术语具有相同的格式。如果不设置<code>search_analyzer</code>，则 <code>search_analyzer</code> 与 <code>analyzer</code> 相同。详细请查阅官网<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/search-analyzer.html">搜索分析器</a></p><h3 id="4-2-head-插件"><a href="#4-2-head-插件" class="headerlink" title="4.2 head 插件"></a>4.2 head 插件</h3><h2 id="5-Elasticsearch-REST-APIs-的使用"><a href="#5-Elasticsearch-REST-APIs-的使用" class="headerlink" title="5. Elasticsearch REST APIs 的使用"></a>5. Elasticsearch REST APIs 的使用</h2><h3 id="5-1-Indices-APIs（索引API）"><a href="#5-1-Indices-APIs（索引API）" class="headerlink" title="5.1 Indices APIs（索引API）"></a>5.1 Indices APIs（索引API）</h3><p>索引API用于对索引进行各种管理，如：创建索引、删除索引、获取索引等，还包括，索引设置，别名管理，映射管理，状态管理等。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>新建 Index，可以直接向 es 服务器发出 PUT 请求。下面的例子是新建一个名叫orders的 Index。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X PUT 'http://localhost:9200/orders' -d ''{"acknowledged":true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>服务器返回一个 JSON 对象，里面的<code>acknowledged</code>字段表示操作成功。</p><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>我们发出 DELETE 请求，删除这个 Index。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X DELETE 'http://localhost:9200/orders'{"acknowledged":true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-2-Document-APIs（文档API）"><a href="#5-2-Document-APIs（文档API）" class="headerlink" title="5.2 Document APIs（文档API）"></a>5.2 Document APIs（文档API）</h3><h4 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h4><p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向<code>/userdoor/person</code>发送请求，就可以新增一条人员记录。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X PUT 'localhost:9200/userdoor/person/1?pretty=true' -d '&gt; {&gt;   "name": "张三",&gt;   "title": "工程师",&gt;   "desc": "数据库管理"&gt; }'{  "_index" : "userdoor",  "_type" : "person",  "_id" : "1",  "_version" : 4,  "result" : "created",  "_shards" : {    "total" : 2,    "successful" : 1,    "failed" : 0  },  "created" : true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后的1是该条记录的 <code>Id</code>。它不一定是数字，任意字符串（比如abc）都可以。<strong>URL</strong> 的参数<code>pretty=true</code>表示以易读的格式返回。</p><p>新增记录的时候，也可以不指定 <code>Id</code>，让<code>es</code>自动生成唯一的<code>Id</code>这时要改成 <strong>POST</strong> 请求。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X POST 'localhost:9200/userdoor/person?pretty' -d '&gt; {&gt;   "name": "李四",&gt;   "title": "工程师",&gt;   "desc": "运维管理"&gt; }'{  "_index" : "userdoor",  "_type" : "person",  "_id" : "AW8ETT-SDmqcpvuz_i-w",  "_version" : 1,  "result" : "created",  "_shards" : {    "total" : 2,    "successful" : 1,    "failed" : 0  },  "created" : true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，如果没有先创建 Index（这个例子是userdoor），直接执行上面的命令，es 也不会报错，而是直接生成指定的 Index。</p><h4 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h4><p>向/Index/Type/Id发出 GET 请求，就可以查看这条记录。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X GET 'localhost:9200/userdoor/person/1?pretty=true'{  "_index" : "userdoor",  "_type" : "person",  "_id" : "1",  "_version" : 4,  "found" : true,  "_source" : {    "name" : "张三",    "title" : "工程师",    "desc" : "数据库管理"  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><p>更新记录就是使用 PUT 请求，重新发送一次数据。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X PUT 'localhost:9200/userdoor/person/1?pretty' -d '&gt; {&gt;   "name": "张三",&gt;   "title": "工程师",&gt;   "desc": "数据库管理，软件开发"&gt; }'{  "_index" : "userdoor",  "_type" : "person",  "_id" : "1",  "_version" : 5,  "result" : "updated",  "_shards" : {    "total" : 2,    "successful" : 1,    "failed" : 0  },  "created" : false}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl -X DELETE 'localhost:9200/userdoor/person/1?pretty' -d ''<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-3-Search-APIs（搜索API）"><a href="#5-3-Search-APIs（搜索API）" class="headerlink" title="5.3 Search APIs（搜索API）"></a>5.3 Search APIs（搜索API）</h3><h4 id="查询所有文档"><a href="#查询所有文档" class="headerlink" title="查询所有文档"></a>查询所有文档</h4><p>使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl 'localhost:9200/userdoor/person/_search?pretty'{  "took" : 185,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 2,    "max_score" : 1.0,    "hits" : [      {        "_index" : "userdoor",        "_type" : "person",        "_id" : "AW8ETT-SDmqcpvuz_i-w",        "_score" : 1.0,        "_source" : {          "name" : "李四",          "title" : "工程师",          "desc" : "运维管理"        }      },      {        "_index" : "userdoor",        "_type" : "person",        "_id" : "1",        "_score" : 1.0,        "_source" : {          "name" : "张三",          "title" : "工程师",          "desc" : "数据库管理，软件开发"        }      }    ]  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，返回结果的 <code>took</code>字段表示该操作的耗时（单位为毫秒），<code>timed_out</code>字段表示是否超时，<code>hits</code>字段表示命中的记录，里面子字段的含义如下。</p><ul><li>total：返回记录数，本例是2条。</li><li>max_score：最高的匹配程度，本例是1.0。</li><li>hits：返回的记录组成的数组。</li></ul><p>返回的记录中，每条记录都有一个<code>_score</code>字段，表示匹配的程序，默认是按照这个字段降序排列。</p><h3 id="5-4-Query-DSL"><a href="#5-4-Query-DSL" class="headerlink" title="5.4 Query DSL"></a>5.4 Query DSL</h3><p>Elastic 的查询非常特别，使用自己的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html">查询语法</a>，要求 GET 请求带有数据体。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ curl 'localhost:9200/userdoor/person/_search?pretty'  -d '&gt; {&gt;   "query" : { "match" : { "desc" : "软件" }}&gt; }'{  "took" : 27,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 1,    "max_score" : 0.28582606,    "hits" : [      {        "_index" : "userdoor",        "_type" : "person",        "_id" : "1",        "_score" : 0.28582606,        "_source" : {          "name" : "张三",          "title" : "工程师",          "desc" : "数据库管理，软件开发"        }      }    ]  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-match-query.html">Match 查询</a> ，指定的匹配条件是<code>desc</code>字段里面包含”软件”这个词</p><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">Elasticsearch 官方手册</a></li><li><a href="https://github.com/mobz/elasticsearch-head">elasticsearch-head</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用openssl自建CA和颁发多域名通配符证书</title>
      <link href="/2021/06/29/shi-yong-openssl-zi-jian-ca-he-ban-fa-duo-yu-ming-tong-pei-fu-zheng-shu/"/>
      <url>/2021/06/29/shi-yong-openssl-zi-jian-ca-he-ban-fa-duo-yu-ming-tong-pei-fu-zheng-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="使用openssl自建CA和颁发多域名通配符证书"><a href="#使用openssl自建CA和颁发多域名通配符证书" class="headerlink" title="使用openssl自建CA和颁发多域名通配符证书"></a>使用openssl自建CA和颁发多域名通配符证书</h1><hr><h2 id="常见的证书分类"><a href="#常见的证书分类" class="headerlink" title="常见的证书分类"></a>常见的证书分类</h2><ol><li><p>单域名ssl证书</p><p> 只保护一个域名，例如如果想要保护<a href="http://www.test.com,a.demo.com,b.example.com;每个域名分别需要一个证书./">www.test.com，a.demo.com，b.example.com；每个域名分别需要一个证书。</a></p></li><li><p>多域名ssl证书</p><p> 可以同时保护多个域名，例如同时保护<a href="http://www.test.com,a.demo.com,b.example.com等,但每一个品牌的多域名证书保护的域名数量不一样./">www.test.com，a.demo.com，b.example.com等，但每一个品牌的多域名证书保护的域名数量不一样。</a></p></li><li><p>通配符ssl证书</p><p> <strong>可以保护主域名本身及下一级的所有子域名，但不支持无限级子域名。</strong>例如*.test.com证书可以保护a.test.com，b.test.com，c.test.com但无法保护x.y.test.com。</p></li><li><p>多域名通配符ssl证书</p><p> 可以保护多个域名以及每个域名的所有二级域名，相当于将多个通配符证书合并为一个证书，例如一个多域名通配符证书可以保护test.com和demo.com，同时也能保护test.com及demo.com的所有二级域名。</p></li></ol><h2 id="制作多域名通配符ssl证书"><a href="#制作多域名通配符ssl证书" class="headerlink" title="制作多域名通配符ssl证书"></a>制作多域名通配符ssl证书</h2><h3 id="1-CA服务器配置"><a href="#1-CA服务器配置" class="headerlink" title="1. CA服务器配置"></a>1. CA服务器配置</h3><p>1.1. 在CA目录下创建两个初始文件：</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ~]# cd /etc/pki/CA/[root@localhost CA]# touch index.txt serial[root@localhost CA]# echo 01 &gt; serial<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>1.2.  生成CA证书的RSA私钥</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost CA]# openssl genrsa -out private/ca.key 2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-out private/ca.key</code>是私钥存放的目录和文件名，2048指密钥长度</li><li>这里注意，公钥是按某种格式从私钥中提取出来的、公钥和私钥是成对的、生成私钥也就有了公钥</li></ul><p>1.3. 通过私钥提取公钥(这不是必要的步骤)</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost CA]# openssl rsa -in private/ca.key -pubout -out private/pub.key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.4. 利用CA的RSA密钥生成CA证书请求并对CA证书请求进行自签名，得到CA证书(X.509结构)</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">openssl req -new -sha256 -x509 -days 3650 -key private/ca.key -out cacert.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>签发机构名示例如下</li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:ShangHaiLocality Name (eg, city) [Default City]:ShangHaiOrganization Name (eg, company) [Default Company Ltd]:GuanaitongOrganizational Unit Name (eg, section) []:PHPCommon Name (eg, your name or your server's hostname) []:Test Root CAEmail Address []:quan.zhang@guanaitong.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>可以使用<code>-subj</code>在非交互式下来代替请求字段信息</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">openssl req -new \            -sha256 \            -x509 \            -days 3650 \            -key private/ca.key \            -subj "/C=CN/ST=ShangHai/L=ShangHai/O=Guanaitong/OU=PHP/CN=Test Root CA/emailAddress=quan.zhang@guanaitong.com" \            -out cacert.crt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>cacert.crt</code>就是得到的CA证书</p></li></ul><hr><h3 id="2-Web服务器配置-以nginx为例"><a href="#2-Web服务器配置-以nginx为例" class="headerlink" title="2. Web服务器配置(以nginx为例)"></a>2. Web服务器配置(以nginx为例)</h3><p>2.1 建立存放服务器私钥和证书的目录</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost CA]# cd /usr/local/nginx/conf/[root@localhost conf]# mkdir ssl &amp;&amp; cd ssl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.2 生成服务器证书用的RSA私钥</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ssl]# openssl genrsa -out nginx.key 2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.3 利用生成好的私钥生成服务器证书签名请求文件</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ssl]# openssl req -new -sha256 -key nginx.key -out nginx.csr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>签名请求内容示例如下：</li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:ShangHaiLocality Name (eg, city) [Default City]:ShangHaiOrganization Name (eg, company) [Default Company Ltd]:GuanaitongOrganizational Unit Name (eg, section) []:PHPCommon Name (eg, your name or your server's hostname) []:Test InternalEmail Address []:Please enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:An optional company name []:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以使用<code>-subj</code>在非交互式下来代替请求字段信息<pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">openssl req -new \            -sha256 \            -key nginx.key \            -subj "/C=CN/ST=ShangHai/L=ShangHai/O=Guanaitong/OU=PHP/CN=Test Internal" \            -out nginx.csr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>2.4 使用CA根证书对“服务器证书签名请求文件”进行签名，生成带SAN扩展证书</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">openssl x509 -req -sha256 \             -in nginx.csr \             -CA /etc/pki/CA/cacert.crt \             -CAkey /etc/pki/CA/private/ca.key \             -CAcreateserial \             -days 3650 \             -extfile v3.ext \             -out nginx.crt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>-extfile：指定当前创建的证书的扩展文件<br>-extensions section：指定当前创建的证书使用配置文件中的哪个section作为扩展属性。</p></blockquote><ul><li>v3.ext内容示例如下</li></ul><pre class="line-numbers language-none"><code class="language-none">subjectAltName = @alt_names[alt_names]DNS.1 = www.testvm.devDNS.2 = *.demo.dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>这里使用<code>openssl</code>的<code>SubjectAlternativeName(SAN)</code>实现一个CA证书对多个通配符域名进行签名保护。</p></li><li><p>ssl目录内容</p></li></ul><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">ssl├── nginx.crt   #服务器证书├── nginx.csr   #证书签名请求文件├── nginx.key   #服务器私钥└── v3.ext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看CSR和CRT文件细节<pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ssl]# openssl req -noout -text -in nginx.csr[root@localhost ssl]# openssl x509 -noout -text -in nginx.crt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="3-nginx配置ssl加密"><a href="#3-nginx配置ssl加密" class="headerlink" title="3. nginx配置ssl加密"></a>3. nginx配置ssl加密</h3><p>3.1 默认nginx是没有安装ssl模块的，需要编译安装nginx时加入<code>--with-http_ssl_module</code>选项</p><p>3.2 nginx配置文件的server指令添加如下配置</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">server { listen       80; listen       443 ssl; server_name www.testvm.dev; ssl_certificate   /usr/local/nginx/conf/ssl/nginx.crt; ssl_certificate_key /usr/local/nginx/conf/ssl/nginx.key; root   /data1/www/test; index  index.php index.html index.htm; location ~ \.php$ {     fastcgi_pass   127.0.0.1:9000;     fastcgi_index  index.php;     fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;     include        fastcgi_params;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.3 重新加载nginx配置</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost ssl]# /usr/local/nginx/sbin/nginx -t[root@localhost ssl]# /usr/local/nginx/sbin/nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-浏览器导入自己制做的CA证书"><a href="#4-浏览器导入自己制做的CA证书" class="headerlink" title="4. 浏览器导入自己制做的CA证书"></a>4. 浏览器导入自己制做的CA证书</h3><h3 id="5-为linux系统添加根证书"><a href="#5-为linux系统添加根证书" class="headerlink" title="5. 为linux系统添加根证书"></a>5. 为linux系统添加根证书</h3><ul><li>我们来看下这种情况假设<code>/data1/www/test/index.php</code>文件内容如下：</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">echo</span> <span class="token string single-quoted-string">'success'</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# curl https://www.testvm.dev/index.phpcurl: (60) Peer certificate cannot be authenticated with known CA certificatesMore details here: http://curl.haxx.se/docs/sslcerts.htmlcurl performs SSL certificate verification by default, using a "bundle" of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn't adequate, you can specify an alternate file using the --cacert option.If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL).If you'd like to turn off curl's verification of the certificate, use the -k (or --insecure) option.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# curl https://www.baidu.com&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt; (剩余内容省略)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>当我们访问我们自己站点时（<code>curl https://www.testvm.dev</code>）提示我们curl在linux的证书信任集里没有找到根证书，你可以使用<code>curl --insecure</code>来不验证证书的可靠性，这只能保证数据是加密传输的但无法保证对方是我们要访问的服务。使用<code>curl --cacert cacert.pem</code>可以手动指定根证书路径。为什么访问百度的<code>https</code>站点时就能正确返回内容？</p><ul><li>因为为百度站点签署的CA证书已经内置在操作系统中了，curl 访问https站点时会自动去获取操作系统内置的证书，而我们自已签名的CA证书没有导入到操作系统中，所以会获取不到内容。</li></ul></li></ul><ul><li>把自己制作的CA证书导入到操作系统中</li></ul><blockquote><p>Ubuntu, Debian系列</p></blockquote><p>0.内置的证书集在这个文件里<code>/etc/ssl/certs/ca-certificates.crt</code></p><p>1.将自己制作的CA证书复制到<code>/usr/local/share/ca-certificates/</code>目录下</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# cp /etc/pki/CA/cacert.crt  /usr/local/share/ca-certificates/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.更新操作系统CA证书库</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# update-ca-certificates<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.更多的命令行参数及说明， 请查看: <code>man update-ca-certificates</code></p><blockquote><p>Centos系列</p></blockquote><p>0.内置的证书集在这个文件里<code>/etc/pki/tls/cert.pem</code></p><p>1.安装根证书管理包软件</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# yum install ca-certificates<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.打开根证书动态配置开关</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# update-ca-trust force-enable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.将自己制作的CA证书复制到<code>/etc/pki/ca-trust/source/anchors/</code>目录下</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# cp /etc/pki/CA/cacert.crt /etc/pki/ca-trust/source/anchors/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.更新操作系统CA证书库</p><pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost test]# update-ca-trust extract<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.更多的命令行参数及说明， 请查看: <code>man update-ca-trust</code></p><ul><li>最后验证下是否成功<pre class="line-numbers language-ssh" data-language="ssh"><code class="language-ssh">[root@localhost logs]# curl https://www.testvm.dev/index.phpsuccess<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="一点扩展知识"><a href="#一点扩展知识" class="headerlink" title="一点扩展知识"></a>一点扩展知识</h3><ul><li><p>我们在使用PHP开发程序时会使用到<code>file_get_contents</code>函数、<code>curl</code>库来获取https站点数据时，如果需要对证书做信任，那么就可以把自己制作的CA证书导入到操作系统中，然后就不需要手动指定证书参数或者修改 php.ini <code> openssl.cafile或openssl.capath</code>选项，就能很爽的直接<code>file_get_contents('https://www.testvm.dev/index.php')</code>来使用了。</p></li><li><p>注意导入证书后那些在导入证书前就已经运行的服务需要将相应服务重启后才能使用系统新的证书，例如重启<code>php-fpm</code></p></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果是自己做的CA，浏览器要导入CA证书(导入CA证书，意味着将信任这个CA签署的所有证书)。而商业的ssl证书颁发机构如VeriSign、Wosign、StartSSL签发的证书，浏览器已经内置并信任了这些根证书。</li><li>如果对于一般的应用，管理员只需生成“证书请求”（后缀大多为.csr），它包含你的服务器名称(域名)和公钥，然后把这份请求交给诸如verisign等有CA服务公司，你的证书请求经验证后，CA用它的私钥签名，形成正式的证书发还给你。管理员再在web server上导入这个证书就行了。</li></ul><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><ul><li>Chrome 58及以上版本要使用OpenSSL创建带有SAN(subjectAlternativeName，主题备用名称)的证书，不然chrome会报 <strong>NET::ERR_CERT_COMMON_NAME_INVALID</strong></li><li>生成证书时要使用<strong>sha256</strong>加密不然chrome会报弱的签名</li><li>注意浏览器缓存，<strong>cookie</strong></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></li><li><a href="http://apetec.com/support/generatesan-csr.htm">http://apetec.com/support/generatesan-csr.htm</a></li><li><a href="http://liaoph.com/openssl-san/">http://liaoph.com/openssl-san/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的守护神-daemontools</title>
      <link href="/2021/06/29/jin-cheng-de-shou-hu-shen-daemontools/"/>
      <url>/2021/06/29/jin-cheng-de-shou-hu-shen-daemontools/</url>
      
        <content type="html"><![CDATA[<h1 id="进程的守护神-daemontools"><a href="#进程的守护神-daemontools" class="headerlink" title="进程的守护神 - daemontools"></a>进程的守护神 - daemontools</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在日常的开发中可能需要写一些<code>常驻内存的程序</code>，<code>常驻内存的程序</code>和<code>守护进程</code>程序是不一样的，<code>守护进程</code>的实现步骤稍微麻烦点，感兴趣的读者可以参考我用<code>C</code>实现的一个守护进程<a href="https://github.com/dendi875/APUE/blob/master/Chapter-13-Daemon%20Processes/daemonize.c">daemonize.c</a>，我们重点关注下<code>常驻内存的程序</code>，<br>以<code>PHP</code>为例来说<code>常驻内存的程序</code>实现一般是这样的：</p><p>首先使用<code>while (1) {}</code>结构使程序无限循环，并且在程序内部对各种可能出现的异常进行捕捉处理，目的是防止程序意外退出。</p><p>hello.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// dostuff();</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"hello, %d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> <span class="token variable">$e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// exception handling</span>    <span class="token punctuation">}</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，通过命令行把它放到后台执行，例如：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ nohup php hello.php &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但这种实现方式是有一定的缺陷的，那就是当<code>PHP</code>执行过程中遇到错误的时候，就会退出程序，不官你程序中使用多少层<code>while (1) {}</code>，也不管你使用<code>try...catch</code>多少<code>Exception</code>，你还是阻止不了程序的意外退出（比如程序产生奇怪的<code>coredump</code>或者<code>kill</code>时手误杀错了程序）。如果这个常驻内存的程序是一个队列消费者程序，那么这种缺陷是很致命的，因为在流量高峰时如果程序一旦意外退出没有即时恢复，那么将导致队列中的消息一直堆积无法被消费掉，从而影响正常业务流程。再严重点，如果队列没有最大内存限制的策略，那么消息的堆积将会导致内存使用暴涨从而拖垮机器。怎么办？你可以用<code>crontab</code>脚本每分钟监视你的程序，看到没有在执行就启动起来。当然，还有更好的办法就是使用成熟的进程管理工具，它会监控你的程序，一旦发现进程退出了，立刻启动起来。<code>Linux</code>下对常驻内存的进程的管理通常使用<code>Daemontools</code>和<code>Supervisor</code> 这两个工具。今天我们就来研究学习下<code>Daemontools</code></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>daemontools</code>是用于管理<code>UNIX</code>服务的工具的集合，它分为三类工具：</p><ul><li>常驻进程管理工具</li></ul><p><a href="http://cr.yp.to/daemontools/svscanboot.html">The svscanboot program</a></p><p><a href="http://cr.yp.to/daemontools/svscan.html">The svscan program</a></p><p><a href="http://cr.yp.to/daemontools/supervise.html">The supervise program</a></p><p><a href="http://cr.yp.to/daemontools/svc.html">The svc program</a></p><p><a href="http://cr.yp.to/daemontools/svok.html">The svok program</a></p><p><a href="http://cr.yp.to/daemontools/svstat.html">The svstat program</a></p><p><a href="http://cr.yp.to/daemontools/fghack.html">The fghack program</a></p><p><a href="http://cr.yp.to/daemontools/pgrphack.html">The pgrphack program</a></p><ul><li>日志管理工具</li></ul><p><a href="http://cr.yp.to/daemontools/readproctitle.html">The readproctitle program</a></p><p><a href="http://cr.yp.to/daemontools/multilog.html">The multilog program</a></p><p><a href="http://cr.yp.to/daemontools/tai64n.html">The tai64n program</a></p><p><a href="http://cr.yp.to/daemontools/tai64nlocal.html">The tai64nlocal program</a></p><ul><li>环境管理工具</li></ul><p><a href="http://cr.yp.to/daemontools/setuidgid.html">The setuidgid program</a></p><p><a href="http://cr.yp.to/daemontools/envuidgid.html">The envuidgid program</a></p><p><a href="http://cr.yp.to/daemontools/envdir.html">The envdir program</a></p><p><a href="http://cr.yp.to/daemontools/softlimit.html">The softlimit program</a></p><p><a href="http://cr.yp.to/daemontools/setlock.html">The setlock program</a></p><p>我们重点关注对常驻进程管理工具的使用，日志管理工具和环境管理工具主要是辅助进程管理做一些额外的功能，进程管理工具主要是通过<code>svscanboot</code>、<code>svscan</code>、<code>supervise</code>、<code>svc</code>、<code>svok</code>、<code>svstat</code>命令来管理常驻进程的</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ cd /usr/local/software/$ wget http://cr.yp.to/daemontools/daemontools-0.76.tar.gz$ tar -zxvf daemontools-0.76.tar.gz -C /usr/local/$ cd /usr/local/admin/daemontools-0.76/$ package/install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在<code>Linux</code>下安装出现如下错误：　</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">/usr/bin/ld: errno: TLS definition in /lib/libc.so.6 section .tbss mismatches non-TLS reference in envdir.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修复很简单将<em>admin/daemontools-0.76/src/error.h</em>中的<code>extern int errno;</code>替换为<code>include &lt;errno.h&gt;</code>之后再重新执行<code>package/install</code></p><p>安装完成之后，会创建<code>/service</code>和<code>/command</code>两个目录</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">/command/├── envdir -&gt; /usr/local/admin/daemontools/command/envdir├── envuidgid -&gt; /usr/local/admin/daemontools/command/envuidgid├── fghack -&gt; /usr/local/admin/daemontools/command/fghack├── multilog -&gt; /usr/local/admin/daemontools/command/multilog├── pgrphack -&gt; /usr/local/admin/daemontools/command/pgrphack├── readproctitle -&gt; /usr/local/admin/daemontools/command/readproctitle├── setlock -&gt; /usr/local/admin/daemontools/command/setlock├── setuidgid -&gt; /usr/local/admin/daemontools/command/setuidgid├── softlimit -&gt; /usr/local/admin/daemontools/command/softlimit├── supervise -&gt; /usr/local/admin/daemontools/command/supervise├── svc -&gt; /usr/local/admin/daemontools/command/svc├── svok -&gt; /usr/local/admin/daemontools/command/svok├── svscan -&gt; /usr/local/admin/daemontools/command/svscan├── svscanboot -&gt; /usr/local/admin/daemontools/command/svscanboot├── svstat -&gt; /usr/local/admin/daemontools/command/svstat├── tai64n -&gt; /usr/local/admin/daemontools/command/tai64n└── tai64nlocal -&gt; /usr/local/admin/daemontools/command/tai64nlocal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动daemontools"><a href="#启动daemontools" class="headerlink" title="启动daemontools"></a>启动daemontools</h3><p>启动<code>svscanboot</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># /command/svscanboot &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以设置开机启动，具体参考：</p><p><a href="http://cr.yp.to/daemontools/start.html">How to start daemontools</a></p><p>启动之后，查看进程，可以发现<code>svscan</code>做为<code>svscanboot</code>的子进程在运行</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># ps -ef | grep svroot      7547  5172  0 20:44 pts/0    00:00:00 /bin/sh /command/svscanbootroot      7549  7547  0 20:44 pts/0    00:00:00 svscan /service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="制作并测试你的脚本"><a href="#制作并测试你的脚本" class="headerlink" title="制作并测试你的脚本"></a>制作并测试你的脚本</h3><p>这步的主要目的就是在尝试把程序变为常驻内存进程之前，先确保它可以作为前台程序正常工作。如果脚本有误在前台都不能正常运行，那变为常驻程序后观察结果肯定是达不到预期的。比如我们制作了一个下面这样的<code>PHP</code>脚本</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">cat /data1/www/test/php/process/hello.php#!/usr/bin/env php<span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"hello, %d\n"</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构建-daemontools-Service"><a href="#构建-daemontools-Service" class="headerlink" title="构建 daemontools Service"></a>构建 daemontools Service</h3><p>我们把所有的服务统一放到<code>/scratch/service</code>（临时服务）目录下，服务的名称是任意的，比如我们称为<strong>hello</strong></p><p>创建 <code>/scratch/service</code> 目录</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># mkdir -p /scratch/service# cd /scratch/service/# mkdir hello# cd hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个<code>run</code>文件，其中包含：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!/bin/shexec 2&gt;&amp;1exec su - root -c "php /data1/www/test/php/process/hello.php" 1&gt;&gt; /data1/www/test/php/process/hello.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>赋予执行权限</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># chmod u+x run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装<strong>hello</strong>服务并实际开始运行它</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># ln -s /scratch/service/hello/ /service/hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong> 上面的命令执行后正常情况下服务就已经开始运行了</p><p>打开另一个终端，验证程序是否正在运行</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ tail -f /data1/www/test/php/process/hello.loghello, 67hello, 68hello, 69hello, 70<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>tail</code>命令未产生输出，请执行<code>svc -u hello</code>，虽然前面的命令如<code>/command/svscanboot &amp;</code>已经打开了服务，以防万一由于某种原因关闭了服务，而这本不应该被关闭。</p><pre class="line-numbers language-none"><code class="language-none"># pstree -a -p 7547svscanboot,7547 /command/svscanboot  ├─readproctitle,7550 service errors:...  └─svscan,7549 /service      └─supervise,7578 hello          └─su,7579 - root -c php\040/data1/www/test/php/process/hello.php              └─php,7580 /data1/www/test/php/process/hello.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<code>pstree</code>命令查看进程树，可以看到<code>supervise</code>作为<code>svscan</code>的子进程在运行，<code>su</code>作为<code>supervise</code>的子进程在运行，最终执行的<code>php /data1/www/test/php/process/hello.php</code>又作为<code>su</code>的子进程在运行。</p><h3 id="操作和监视你的服务"><a href="#操作和监视你的服务" class="headerlink" title="操作和监视你的服务"></a>操作和监视你的服务</h3><ul><li>操作服务</li></ul><p>你可以使用<code>svc</code>命令来操作你的服务，可以使用<code>svstat</code>命令来监视你的服务。</p><p><code>svc</code>命令通过向守护进程发送信号来对其进行操作。该命令以<code>root</code>身份在<code>/service</code>目录中执行。例如：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># svc -d hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令意思是关闭（<code>down</code>）或停止守护程序。下表是<code>svc</code>参数，它们的含义和信号的表：</p><table><thead><tr><th>Arg</th><th>Action</th><th>Signal</th></tr></thead><tbody><tr><td>-u</td><td>Start (up)</td><td>-</td></tr><tr><td>-d</td><td>Stop (down)</td><td>TERM, then CONT</td></tr><tr><td>-t</td><td>Restart if running</td><td>TERM</td></tr></tbody></table><p>有关该命令的其它参数，请参见： <a href="http://cr.yp.to/daemontools/svc.html">http://cr.yp.to/daemontools/svc.html</a></p><ul><li>监控服务</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># svstat hellohello: up (pid 7917) 5 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>svstat</code>可以告诉我们以下信息</p><ol><li>服务目录的名称（hello）</li><li>当前状态（up or down）</li><li>进程<code>PID</code></li><li>处于当前状态的秒数</li></ol><h2 id="Daemontools-架构模型"><a href="#Daemontools-架构模型" class="headerlink" title="Daemontools 架构模型"></a>Daemontools 架构模型</h2><p><img src="https://cdn.jsdelivr.net/gh/dendi875/images/PicGo/daemontools.png" alt="daemontools"></p><p>上图的“Connector A: Service”实际上是服务的<code>run</code>脚本，或者是任何二进制可执行文件，<code>shell</code>脚本或<code>PHP/Python/Perl/Ruby/ Lua</code>脚本，它们都是通过<code>exec</code>命令为其分配了一个<code>PID</code>的运行脚本。</p><p>通过上图可以知道<code>daemontools</code>的工作方式，计算机首先初始化，然后系统引导运行<code>/command/svscanboot</code>，接着<code>/command/svscanboot</code>依次引导运行<code>/command/readproctitle</code>和<code>/command/svscan</code>。<code>/command/readproctitle </code>只是一个可以运行的调试工具。</p><p><code>svscan /service </code>是daemontools的一个最重要的机制，每五秒钟它会扫描<code>/service</code>目录（假设<code>/ service</code>是传递给<code>svscan</code>的命令行参数）以查找符号链接目录，并运行该符号连接目录中的<code>run</code>命令（如果尚未运行）</p><p><code>svscan</code>程序会永远一直循环，每次循环做两件事：</p><p>1）扫描<code>/service</code>查找所有符号链接目录</p><p>2）对于查找到的每个符号链接目录，如果该目录还未运行<code>supervise</code>程序，则在该目录上运行<code>supervise</code>程序</p><p><code>supervise</code>程序它基于我们监控的服务目录（如/service/hello）中的 supervise 目录树中的内容来运行和停止运行<code>run</code>脚本</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tree /service/hello/supervise//service/hello/supervise/├── control├── lock├── ok└── status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本故障排查"><a href="#基本故障排查" class="headerlink" title="基本故障排查"></a>基本故障排查</h2><p>对daemontools问题进行故障排除的第一步就是找出正在运行的东西和没有运行的东西，可以参照架构模型将范围一步步缩小。</p><p>下面几个<code>ps</code>命令，用于查看正在运行的和未运行的进程：</p><ul><li><p><code>ps -ef | grep sv</code>，查看<code>svscanboot</code>和<code>svscan</code>是否正常在运行</p></li><li><p><code># ps -ef | grep supervise</code>，查看<code>supervise </code>是否在正常运行</p></li><li><p><code>ps ax | grep myprogram</code>，查看你<code>run</code>命令中执行的程序是否在运行，例如，在前面的救命中，它是 <code>hello.php</code></p></li></ul><h2 id="正确的卸载服务"><a href="#正确的卸载服务" class="headerlink" title="正确的卸载服务"></a>正确的卸载服务</h2><p>卸载服务指的不仅仅是停止它，而是停止使用服务。正确的执行步骤如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># cd /service/hello/# rm -rf /service/hello# svc -dx .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 是首先<code>cd</code>到服务目录下，再使用<strong>绝对路径</strong>删除软链接，最后在执行<code>svc -dx .</code></p><p>验证是否卸载成功：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># ps -ef | grep hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一种终极大招来卸载服务，那就是关闭服务并杀死正在运行所有的守护进程和其子进程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://cr.yp.to/daemontools.html">Daemontools</a></p></li><li><p><a href="http://cr.yp.to/daemontools/faq/create.html">FAQ of daemontools</a></p></li><li><p><a href="http://www.troubleshooters.com/linux/djbdns/daemontools_intro.htm">daemontools_intro</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 四种事务隔离级别说明</title>
      <link href="/2021/06/29/mysql-si-chong-shi-wu-ge-chi-ji-bie-shuo-ming/"/>
      <url>/2021/06/29/mysql-si-chong-shi-wu-ge-chi-ji-bie-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-四种事务隔离级别说明"><a href="#MySQL-四种事务隔离级别说明" class="headerlink" title="MySQL 四种事务隔离级别说明"></a>MySQL 四种事务隔离级别说明</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>MySQL</code> 中，为了保证并发读取数据的正确性，提出了四种事务隔离级别，下面我们就说明如何设置隔离级别，以及用示例来说明每种隔离级别的使用情况</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h3><p>你可以在 <code>MySQL</code> 配置文件 <code>my.cnf</code> 的 <code>[mysqld]</code>节中设置如下选项来为所有连接设置默认的隔离级别</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[mysqld]transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果未设置此选项，则 <code>InnoDB</code>默认是可重复读（<code>REPEATABLE-READ</code>）。</p><p>你也可以用 <code>set session</code>语句来改变单个会话或所有新进来连接的隔离级别。</p><p>语法如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">set [session | global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果使用 <code>global</code> 关键字，则表示在全局（多个 session中）对从那点开始创建的所有连接设置默认事务级别</li><li>如果使用 <code>session</code>关键字，则表示为将来在当前连接上执行的所有事务设置默认事务级别</li><li>不带<code>global</code>和<code>session</code>是为下一个（未开始）事务设置隔离级别</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">set session transaction isolation level read uncommitted;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令表示：为接下来在当前会话连接上执行的所有事务设置读未提交隔离级别</p><p>注意：使用<code>set</code> 命令来设置隔离级别的方式在 <code>MySQL</code> 重启后会恢复到配置文件中设置的隔离级别</p><h3 id="查询隔离级别"><a href="#查询隔离级别" class="headerlink" title="查询隔离级别"></a>查询隔离级别</h3><ul><li>查询全局的隔离级别</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">select @@global.tx_isolation;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询一个会话的隔离级别</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">select @@session.tx_isolation;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询一个事务的隔离级别</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">select @@tx_isolation;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="四种隔离级别的示例"><a href="#四种隔离级别的示例" class="headerlink" title="四种隔离级别的示例"></a>四种隔离级别的示例</h3><ol><li>各隔离级别会再现的问题</li></ol><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ul><li>读未提交：该隔离级别下可能会出现 <strong>脏读</strong>，也就是可能会读取到其它会话中修改了但还未提交的数据</li><li>读已提交：该隔离级别解决了脏读问题，但可能会出现<strong>不可重复读</strong></li><li>可重复读： 该隔离级别解决了不可重复读问题，但可能会出现<strong>幻读</strong></li><li>可串行化：该隔离级别解决了幻读问题，它是完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul><ol start="2"><li>示例来说明每种隔离级别的使用情况</li></ol><p>准备一张测试表，插入一些测试数据，然后开启两个<code>MySQL</code>终端，在此命令为<code>session1</code>和<code>session2</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">CREATE TABLE `goods` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(45) NOT NULL DEFAULT '' COMMENT '商品名称',  `stock` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '库存',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品';insert into `goods` (`name`, `stock`) values ('p1', '1000'),('p2', '1000'),('p3', '1000'),('p4', '1000'),('p5', '1000'),('p6', '1000'),('p7', '1000'),('p8', '1000'),('p9', '1000');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">// 关闭自动提交，设置隔离级别为读未提交mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level read uncommitted;// 确认mysql&gt; show variables like '%autocommit%';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | OFF   |+---------------+-------+mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| READ-UNCOMMITTED       |+------------------------+// 开启事务，查询 id = 1 的记录mysql&gt; start transaction;mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+1 row in set (0.01 sec)mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>session2：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level read uncommitted;// 确认// 开启事务，把 id = 1记录的库存更新至 1mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+1 row in set (0.00 sec)mysql&gt; update goods set stock=1 where id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; select * from goods where id=1; +----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |     1 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 这时 session1 读取到了 session2 未提交的内容，如果 session2 回滚刚才更新的数据，session1 读取到的数据就是错误的</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>事务一一直读，事务二修改数据并提交，有可能就会出现事务一内两次读取到的数据不一样</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">// 取消自动提交，并设置隔离级别为读已提交mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level read committed;// 确认mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| READ-COMMITTED         |+------------------------+// 开启事务，查询 id=1 的记录mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>session2：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">// 取消自动提交，并设置隔离级别为读已提交mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level read committed;// 确认mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| READ-COMMITTED         |+------------------------+mysql&gt; start transaction;mysql&gt; select * from goods where id=1;mysql&gt; update goods set stock=1 where id=1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时返回到 session1</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以观察到在读已提交的隔离级别下，session1 没出现<strong>脏读</strong>。</p><p>继续返回到 session2 执行手动提交</p><p>session2：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; commit;Query OK, 0 rows affected (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再返回到 session1 查看 id = 1的记录</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |     1 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 在 session2 提交后，session1 连接两次读取到的数据不一致了，这就是<strong>读已提交隔离级别可能会出现不可重复读的情况</strong></p><p>在演示幻读之前，我们先演示下<strong>可重复读</strong></p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level repeatable read;mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ        |+------------------------+mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>session2：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level repeatable read;mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ        |+------------------------+mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+1 row in set (0.00 sec)mysql&gt; update goods set stock=1 where id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt;  commit;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再返回到 session1 查询 id=1 的记录</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; select * from goods where id=1;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以观察到<strong>在可重复读隔离级别下</strong>，session1 连续多次读取的数据是一致的，也就是它是可重复读的</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>两个事务彼此隔离，互相并不知道对方操作了什么，当第一个事务插入了一条数据并提交后，因为隔离级别是可重复读，在第二个事务里并不知道第一个事务已经插入了数据，所以第二个事务查询出来的数据还是没插入之前的，这时第二个事务再次插入数据时就可能会报数据已存在，以为自己出现了幻觉</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level repeatable read;// 开启事务，插入数据并提交mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from goods;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |     1 ||  2 | p2   |  1000 ||  3 | p3   |  1000 ||  4 | p4   |  1000 ||  5 | p5   |  1000 ||  6 | p6   |  1000 ||  7 | p7   |  1000 ||  8 | p8   |  1000 ||  9 | p9   |  1000 |+----+------+-------+9 rows in set (0.00 sec)mysql&gt; insert into goods(`name`,`stock`) values('p10', 1000);      Query OK, 1 row affected (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到 session2 </p><p>session2：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; set autocommit=0;mysql&gt; set session transaction isolation level repeatable read;// 开启事务，查询后再插入mysql&gt; start transaction;mysql&gt; select * from goods;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |     1 ||  2 | p2   |  1000 ||  3 | p3   |  1000 ||  4 | p4   |  1000 ||  5 | p5   |  1000 ||  6 | p6   |  1000 ||  7 | p7   |  1000 ||  8 | p8   |  1000 ||  9 | p9   |  1000 |+----+------+-------+9 rows in set (0.00 sec)mysql&gt; insert into goods(`name`, `stock`) values('p10', 1000);     ERROR 1062 (23000): Duplicate entry 'p10' for key 'uk_name'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SERIALIZABLE（可串行化）"><a href="#SERIALIZABLE（可串行化）" class="headerlink" title="SERIALIZABLE（可串行化）"></a>SERIALIZABLE（可串行化）</h4><p>在该隔离级别下事务都是串行顺序执行的，<code>MySQL</code> 数据库的 <code>InnoDB</code> 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set session transaction isolation level serializable;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| SERIALIZABLE           |+------------------------+1 row in set (0.00 sec)// 开启一个事务，插入一条数据但不提交mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into goods(`name`, `stock`) values('p10', 1000); Query OK, 1 row affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到 session2 ，开启一个事务然后查询数据</p><p>session2：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set session transaction isolation level serializable;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| SERIALIZABLE           |+------------------------+1 row in set (0.00 sec)mysql&gt; select * from goods; // 些时会一直卡住<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>立马切换到 session1，提交事务</p><p>session1：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; commit;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再切换到 session2</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; select * from goods;+----+------+-------+| id | name | stock |+----+------+-------+|  1 | p1   |  1000 ||  2 | p2   |  1000 ||  3 | p3   |  1000 ||  4 | p4   |  1000 ||  5 | p5   |  1000 ||  6 | p6   |  1000 ||  7 | p7   |  1000 ||  8 | p8   |  1000 ||  9 | p9   |  1000 || 10 | p10  |  1000 |+----+------+-------+10 rows in set (1.12 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>session2 也有可能获取锁超时</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql&gt; select * from goods;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意：</strong>　一旦事务提交，session2 会立马返回插入的记录，否则会一直卡住，直到超时，其中超时参数是由 <code>innodb_lock_wait_timeout</code> 控制。由于每条 <code>select</code>语句都会加锁，所以该隔离级别的数据库并发能力最弱</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>四个级别逐渐增强，每个级别解决一个问题。事务级别越高，性能越差。<code>InnoDB</code>默认级别是可重复读。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
