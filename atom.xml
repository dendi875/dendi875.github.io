<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一代键客</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://www.zhangquan.me/atom.xml" rel="self"/>
  
  <link href="https://www.zhangquan.me/"/>
  <updated>2023-07-31T02:21:03.903Z</updated>
  <id>https://www.zhangquan.me/</id>
  
  <author>
    <name>张权</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程—Balking模式：再谈线程安全的单例模式</title>
    <link href="https://www.zhangquan.me/2023/07/31/java-bing-fa-bian-cheng-balking-mo-shi-zai-tan-xian-cheng-an-quan-de-dan-li-mo-shi/"/>
    <id>https://www.zhangquan.me/2023/07/31/java-bing-fa-bian-cheng-balking-mo-shi-zai-tan-xian-cheng-an-quan-de-dan-li-mo-shi/</id>
    <published>2023-07-31T02:20:07.000Z</published>
    <updated>2023-07-31T02:21:03.903Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;上&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Guarded Suspension模式：等待唤醒机制的规范实现</title>
    <link href="https://www.zhangquan.me/2023/07/30/java-bing-fa-bian-cheng-guarded-suspension-mo-shi-deng-dai-huan-xing-ji-zhi-de-gui-fan-shi-xian/"/>
    <id>https://www.zhangquan.me/2023/07/30/java-bing-fa-bian-cheng-guarded-suspension-mo-shi-deng-dai-huan-xing-ji-zhi-de-gui-fan-shi-xian/</id>
    <published>2023-07-30T11:55:33.000Z</published>
    <updated>2023-07-31T02:20:43.833Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前不久，同事小灰工作中遇到一个问题，他开发了一个 Web 项目：Web</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—线程本地存储模式：没有共享，就没有伤害</title>
    <link href="https://www.zhangquan.me/2023/07/26/java-bing-fa-bian-cheng-xian-cheng-ben-di-cun-chu-mo-shi-mei-you-gong-xiang-jiu-mei-you-shang-hai/"/>
    <id>https://www.zhangquan.me/2023/07/26/java-bing-fa-bian-cheng-xian-cheng-ben-di-cun-chu-mo-shi-mei-you-gong-xiang-jiu-mei-you-shang-hai/</id>
    <published>2023-07-26T03:12:54.000Z</published>
    <updated>2023-07-26T03:15:27.932Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们曾经一遍一遍又一遍地重复，多个线程同时读写同一共享变量存在并发问题。&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Copy-on-Write模式：不是延时策略的COW</title>
    <link href="https://www.zhangquan.me/2023/07/24/java-bing-fa-bian-cheng-copy-on-write-mo-shi-bu-shi-yan-shi-ce-lue-de-cow/"/>
    <id>https://www.zhangquan.me/2023/07/24/java-bing-fa-bian-cheng-copy-on-write-mo-shi-bu-shi-yan-shi-ce-lue-de-cow/</id>
    <published>2023-07-24T12:38:38.000Z</published>
    <updated>2023-07-26T03:02:30.370Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Immutability模式：如何利用不变性解决并发问题？</title>
    <link href="https://www.zhangquan.me/2023/07/18/java-bing-fa-bian-cheng-immutability-mo-shi-ru-he-li-yong-bu-bian-xing-jie-jue-bing-fa-wen-ti/"/>
    <id>https://www.zhangquan.me/2023/07/18/java-bing-fa-bian-cheng-immutability-mo-shi-ru-he-li-yong-bu-bian-xing-jie-jue-bing-fa-wen-ti/</id>
    <published>2023-07-18T07:51:13.000Z</published>
    <updated>2023-07-24T12:39:38.325Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们知道，“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。&lt;/p&gt;
&lt;p&gt;解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：&lt;s</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程— Fork/Join：单机版的MapReduce</title>
    <link href="https://www.zhangquan.me/2023/07/12/java-bing-fa-bian-cheng-fork-join-dan-ji-ban-de-mapreduce/"/>
    <id>https://www.zhangquan.me/2023/07/12/java-bing-fa-bian-cheng-fork-join-dan-ji-ban-de-mapreduce/</id>
    <published>2023-07-12T10:48:30.000Z</published>
    <updated>2023-07-12T11:49:43.987Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们介绍了线程池、Future、CompletableFuture 和</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—CompletionService：如何批量执行异步任务？</title>
    <link href="https://www.zhangquan.me/2023/07/10/java-bing-fa-bian-cheng-completionservice-ru-he-pi-liang-zhi-xing-yi-bu-ren-wu/"/>
    <id>https://www.zhangquan.me/2023/07/10/java-bing-fa-bian-cheng-completionservice-ru-he-pi-liang-zhi-xing-yi-bu-ren-wu/</id>
    <published>2023-07-10T03:06:36.000Z</published>
    <updated>2023-07-10T03:08:25.943Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 &lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—CompletableFuture：异步编程没那么难</title>
    <link href="https://www.zhangquan.me/2023/07/07/java-bing-fa-bian-cheng-completablefuture-yi-bu-bian-cheng-mei-na-me-nan/"/>
    <id>https://www.zhangquan.me/2023/07/07/java-bing-fa-bian-cheng-completablefuture-yi-bu-bian-cheng-mei-na-me-nan/</id>
    <published>2023-07-07T03:23:03.000Z</published>
    <updated>2023-07-07T03:24:53.011Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们不止一次提到，用多线程优化性能，其实不过就是将串行操作变成并行操作。如果仔细观察，你还会发现在串行转换成并行的过程中，一定会涉及到异步化，例如下面的示例代码，现在是串行的，为了提升性能，我们得把它们并行化，那具体实施起来该怎么做呢？&lt;/p&gt;
&lt;pre</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Future：如何用多线程实现最优的“烧水泡茶”程序？</title>
    <link href="https://www.zhangquan.me/2023/07/05/java-bing-fa-bian-cheng-future-ru-he-yong-duo-xian-cheng-shi-xian-zui-you-de-shao-shui-pao-cha-cheng-xu/"/>
    <id>https://www.zhangquan.me/2023/07/05/java-bing-fa-bian-cheng-future-ru-he-yong-duo-xian-cheng-shi-xian-zui-you-de-shao-shui-pao-cha-cheng-xu/</id>
    <published>2023-07-05T02:18:29.000Z</published>
    <updated>2023-07-10T02:12:18.005Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 &lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Executor与线程池：如何创建正确的线程池？</title>
    <link href="https://www.zhangquan.me/2023/07/04/java-bing-fa-bian-cheng-executor-yu-xian-cheng-chi-ru-he-chuang-jian-zheng-que-de-xian-cheng-chi/"/>
    <id>https://www.zhangquan.me/2023/07/04/java-bing-fa-bian-cheng-executor-yu-xian-cheng-chi-ru-he-chuang-jian-zheng-que-de-xian-cheng-chi/</id>
    <published>2023-07-04T01:42:52.000Z</published>
    <updated>2023-07-04T08:52:44.367Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;虽然在 Java 语言中创建线程看上去就像创建一个对象一样简单，只需要 new Thread() 就可以了，但实际上创建线程远不是创建一个对象那么简单。创建对象，仅仅是在 JVM 的堆里分配一块内存而已；而创建一个线程，却需要调用操作系统内核的</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—原子类：无锁工具类的典范</title>
    <link href="https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-yuan-zi-lei-wu-suo-gong-ju-lei-de-dian-fan/"/>
    <id>https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-yuan-zi-lei-wu-suo-gong-ju-lei-de-dian-fan/</id>
    <published>2023-07-03T05:43:30.000Z</published>
    <updated>2023-07-04T01:39:21.392Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们多次提到一个累加器的例子，示例代码如下。在这个例子中，add10K() 这个方法不是线程安全的，问题就出在变量 count 的可见性和 count+=1 的原子性上。可见性问题可以用 volatile</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—并发容器：都有哪些“坑”需要我们填？</title>
    <link href="https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-bing-fa-rong-qi-du-you-na-xie-keng-xu-yao-wo-men-tian/"/>
    <id>https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-bing-fa-rong-qi-du-you-na-xie-keng-xu-yao-wo-men-tian/</id>
    <published>2023-07-03T05:32:46.000Z</published>
    <updated>2023-07-03T05:39:08.865Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Java 并发包有很大一部分内容都是关于&lt;strong&gt;并发容器&lt;/strong&gt;的，因此学习和搞懂这部分的内容很有必要。&lt;/p&gt;
&lt;p&gt;Java 1.5 之前提供的&lt;strong&gt;同步容器&lt;/strong&gt;虽然也能保证线程安全，但是性能很差，而 Java 1.5</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—CountDownLatch和CyclicBarrier：如何让多线程步调一致？</title>
    <link href="https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-countdownlatch-he-cyclicbarrier-ru-he-rang-duo-xian-cheng-bu-diao-yi-zhi/"/>
    <id>https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-countdownlatch-he-cyclicbarrier-ru-he-rang-duo-xian-cheng-bu-diao-yi-zhi/</id>
    <published>2023-06-30T07:25:09.000Z</published>
    <updated>2023-07-04T09:10:00.030Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前几天老板突然匆匆忙忙过来，说对账系统最近越来越慢了，能不能快速优化一下。我了解了对账系统的业务后，发现还是挺简单的，用户通过在线商城下单，会生成电子订单，保存在订单库；之后物流会生成派送单给用户发货，派送单保存在派送单库。为了防止漏派送或者重复派送，对账系统每天还会校验是</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—StampedLock：有没有比读写锁更快的锁？</title>
    <link href="https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-stampedlock-you-mei-you-bi-du-xie-suo-geng-kuai-de-suo/"/>
    <id>https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-stampedlock-you-mei-you-bi-du-xie-suo-geng-kuai-de-suo/</id>
    <published>2023-06-30T07:15:53.000Z</published>
    <updated>2023-07-04T01:39:13.405Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—ReadWriteLock：如何快速实现一个完备的缓存？</title>
    <link href="https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-readwritelock-ru-he-kuai-su-shi-xian-yi-ge-wan-bei-de-huan-cun/"/>
    <id>https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-readwritelock-ru-he-kuai-su-shi-xian-yi-ge-wan-bei-de-huan-cun/</id>
    <published>2023-06-30T07:01:15.000Z</published>
    <updated>2023-07-04T01:39:07.759Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们介绍了&lt;a href=&quot;https://zhangquan.me/2023/06/15/java-bing-fa-bian-cheng-guan-cheng-bing-fa-bian-cheng-de-wan-neng-yao-chi/&quot;&gt;管程&lt;/a&gt;和&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Semaphore：如何快速实现一个限流器？</title>
    <link href="https://www.zhangquan.me/2023/06/29/java-bing-fa-bian-cheng-semaphore-ru-he-kuai-su-shi-xian-yi-ge-xian-liu-qi/"/>
    <id>https://www.zhangquan.me/2023/06/29/java-bing-fa-bian-cheng-semaphore-ru-he-kuai-su-shi-xian-yi-ge-xian-liu-qi/</id>
    <published>2023-06-29T02:27:46.000Z</published>
    <updated>2023-07-04T01:39:10.637Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Semaphore，现在普遍翻译为“信号量”，以前也曾被翻译成“信号灯”，因为类似现实生活里的红绿灯，车辆能不能通行，要看是不是绿灯。同样，在编程世界里，线程能不能执行，也要看信号量是不是允许。&lt;/p&gt;
&lt;p&gt;信号量是由大名鼎鼎的计算机科学家迪杰斯特拉（Dijkstra）于</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Lock和Condition（下）：Dubbo如何用管程实现异步转同步？</title>
    <link href="https://www.zhangquan.me/2023/06/27/java-bing-fa-bian-cheng-lock-he-condition-xia-dubbo-ru-he-yong-guan-cheng-shi-xian-yi-bu-zhuan-tong-bu/"/>
    <id>https://www.zhangquan.me/2023/06/27/java-bing-fa-bian-cheng-lock-he-condition-xia-dubbo-ru-he-yong-guan-cheng-shi-xian-yi-bu-zhuan-tong-bu/</id>
    <published>2023-06-27T12:27:06.000Z</published>
    <updated>2023-07-04T01:39:05.103Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Lock和Condition（上）：隐藏在并发包中的管程</title>
    <link href="https://www.zhangquan.me/2023/06/27/java-bing-fa-bian-cheng-lock-he-condition-shang-yin-cang-zai-bing-fa-bao-zhong-de-guan-cheng/"/>
    <id>https://www.zhangquan.me/2023/06/27/java-bing-fa-bian-cheng-lock-he-condition-shang-yin-cang-zai-bing-fa-bao-zhong-de-guan-cheng/</id>
    <published>2023-06-27T01:35:15.000Z</published>
    <updated>2023-07-04T01:39:02.492Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Java SDK 并发包内容很丰富，包罗万象，但是我觉得最核心的还是其对管程的实现。因为理论上利用管程，你几乎可以实现并发包里所有的工具类。在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—理论基础总结</title>
    <link href="https://www.zhangquan.me/2023/06/16/java-bing-fa-bian-cheng-li-lun-ji-chu-zong-jie/"/>
    <id>https://www.zhangquan.me/2023/06/16/java-bing-fa-bian-cheng-li-lun-ji-chu-zong-jie/</id>
    <published>2023-06-16T09:18:22.000Z</published>
    <updated>2023-07-04T01:39:41.316Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;到这里，专栏的第一模块——并发编程的理论基础，我们已经讲解完了，总共 12 篇，不算少，但“跳出来，看全景”你会发现这 12</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—如何用面向对象思想写好并发程序？</title>
    <link href="https://www.zhangquan.me/2023/06/16/java-bing-fa-bian-cheng-ru-he-yong-mian-xiang-dui-xiang-si-xiang-xie-hao-bing-fa-cheng-xu/"/>
    <id>https://www.zhangquan.me/2023/06/16/java-bing-fa-bian-cheng-ru-he-yong-mian-xiang-dui-xiang-si-xiang-xie-hao-bing-fa-cheng-xu/</id>
    <published>2023-06-16T07:42:26.000Z</published>
    <updated>2023-07-04T01:39:33.519Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;面向对象思想与并发编程有关系吗？本来是没关系的，它们分属两个不同的领域，但是在 Java 语言里，这两个领域被无情地融合在一起了，好在融合的效果还是不错的：&lt;strong&gt;在 Java</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
