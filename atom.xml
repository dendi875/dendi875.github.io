<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一代键客</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://www.zhangquan.me/atom.xml" rel="self"/>
  
  <link href="https://www.zhangquan.me/"/>
  <updated>2023-09-13T05:38:48.002Z</updated>
  <id>https://www.zhangquan.me/</id>
  
  <author>
    <name>张权</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python里参数是如何传递的？</title>
    <link href="https://www.zhangquan.me/2023/09/13/python-li-can-shu-shi-ru-he-chuan-di-de/"/>
    <id>https://www.zhangquan.me/2023/09/13/python-li-can-shu-shi-ru-he-chuan-di-de/</id>
    <published>2023-09-13T05:36:46.000Z</published>
    <updated>2023-09-13T05:38:48.002Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;什么是值传递和引用传递&quot;&gt;&lt;a href=&quot;#什么是值传递和引用传递&quot; class=&quot;headerlink&quot; title=&quot;什么是值传递和引用传递&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是值传递和引用传递&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;如果你接触过其他的编程语言，比如</summary>
        
      
    
    
    
    <category term="Python" scheme="https://www.zhangquan.me/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.zhangquan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—生产者-消费者模式：用流水线思想提高效率</title>
    <link href="https://www.zhangquan.me/2023/08/15/java-bing-fa-bian-cheng-sheng-chan-zhe-xiao-fei-zhe-mo-shi-yong-liu-shui-xian-si-xiang-ti-gao-xiao-lu/"/>
    <id>https://www.zhangquan.me/2023/08/15/java-bing-fa-bian-cheng-sheng-chan-zhe-xiao-fei-zhe-mo-shi-yong-liu-shui-xian-si-xiang-ti-gao-xiao-lu/</id>
    <published>2023-08-15T13:18:13.000Z</published>
    <updated>2023-08-15T13:19:01.649Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—两阶段终止模式：如何优雅地终止线程？</title>
    <link href="https://www.zhangquan.me/2023/08/11/java-bing-fa-bian-cheng-liang-jie-duan-zhong-zhi-mo-shi-ru-he-you-ya-di-zhong-zhi-xian-cheng/"/>
    <id>https://www.zhangquan.me/2023/08/11/java-bing-fa-bian-cheng-liang-jie-duan-zhong-zhi-mo-shi-ru-he-you-ya-di-zhong-zhi-xian-cheng/</id>
    <published>2023-08-11T12:53:28.000Z</published>
    <updated>2023-08-11T12:54:20.872Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Worker Thread模式：如何避免重复创建线程？</title>
    <link href="https://www.zhangquan.me/2023/08/06/java-bing-fa-bian-cheng-worker-thread-mo-shi-ru-he-bi-mian-chong-fu-chuang-jian-xian-cheng/"/>
    <id>https://www.zhangquan.me/2023/08/06/java-bing-fa-bian-cheng-worker-thread-mo-shi-ru-he-bi-mian-chong-fu-chuang-jian-xian-cheng/</id>
    <published>2023-08-06T11:42:01.000Z</published>
    <updated>2023-08-23T06:06:11.984Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Thread-Per-Message模式：最简单实用的分工方法</title>
    <link href="https://www.zhangquan.me/2023/08/03/java-bing-fa-bian-cheng-thread-per-message-mo-shi-zui-jian-dan-shi-yong-de-fen-gong-fang-fa/"/>
    <id>https://www.zhangquan.me/2023/08/03/java-bing-fa-bian-cheng-thread-per-message-mo-shi-zui-jian-dan-shi-yong-de-fen-gong-fang-fa/</id>
    <published>2023-08-03T10:07:13.000Z</published>
    <updated>2023-08-23T06:07:21.734Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们曾经把并发编程领域的问题总结为三个核心问题：分工、同步和互斥。其中，同步和互斥相关问题更多地源自微观，而分工问题则是源自宏观。我们解决问题，往往都是从宏观入手，在编程领域，软件的设计过程也是先从概要设计开始，而后才进行详细设计。同样，&lt;strong&gt;解决并发编程问题，首</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Balking模式：再谈线程安全的单例模式</title>
    <link href="https://www.zhangquan.me/2023/07/31/java-bing-fa-bian-cheng-balking-mo-shi-zai-tan-xian-cheng-an-quan-de-dan-li-mo-shi/"/>
    <id>https://www.zhangquan.me/2023/07/31/java-bing-fa-bian-cheng-balking-mo-shi-zai-tan-xian-cheng-an-quan-de-dan-li-mo-shi/</id>
    <published>2023-07-31T02:20:07.000Z</published>
    <updated>2023-07-31T02:21:03.903Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;上&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Guarded Suspension模式：等待唤醒机制的规范实现</title>
    <link href="https://www.zhangquan.me/2023/07/30/java-bing-fa-bian-cheng-guarded-suspension-mo-shi-deng-dai-huan-xing-ji-zhi-de-gui-fan-shi-xian/"/>
    <id>https://www.zhangquan.me/2023/07/30/java-bing-fa-bian-cheng-guarded-suspension-mo-shi-deng-dai-huan-xing-ji-zhi-de-gui-fan-shi-xian/</id>
    <published>2023-07-30T11:55:33.000Z</published>
    <updated>2023-07-31T02:20:43.833Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前不久，同事小灰工作中遇到一个问题，他开发了一个 Web 项目：Web</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—线程本地存储模式：没有共享，就没有伤害</title>
    <link href="https://www.zhangquan.me/2023/07/26/java-bing-fa-bian-cheng-xian-cheng-ben-di-cun-chu-mo-shi-mei-you-gong-xiang-jiu-mei-you-shang-hai/"/>
    <id>https://www.zhangquan.me/2023/07/26/java-bing-fa-bian-cheng-xian-cheng-ben-di-cun-chu-mo-shi-mei-you-gong-xiang-jiu-mei-you-shang-hai/</id>
    <published>2023-07-26T03:12:54.000Z</published>
    <updated>2023-08-23T06:11:20.867Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们曾经一遍一遍又一遍地重复，多个线程同时读写同一共享变量存在并发问题。&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Copy-on-Write模式：不是延时策略的COW</title>
    <link href="https://www.zhangquan.me/2023/07/24/java-bing-fa-bian-cheng-copy-on-write-mo-shi-bu-shi-yan-shi-ce-lue-de-cow/"/>
    <id>https://www.zhangquan.me/2023/07/24/java-bing-fa-bian-cheng-copy-on-write-mo-shi-bu-shi-yan-shi-ce-lue-de-cow/</id>
    <published>2023-07-24T12:38:38.000Z</published>
    <updated>2023-08-23T06:10:45.656Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Immutability模式：如何利用不变性解决并发问题？</title>
    <link href="https://www.zhangquan.me/2023/07/18/java-bing-fa-bian-cheng-immutability-mo-shi-ru-he-li-yong-bu-bian-xing-jie-jue-bing-fa-wen-ti/"/>
    <id>https://www.zhangquan.me/2023/07/18/java-bing-fa-bian-cheng-immutability-mo-shi-ru-he-li-yong-bu-bian-xing-jie-jue-bing-fa-wen-ti/</id>
    <published>2023-07-18T07:51:13.000Z</published>
    <updated>2023-08-23T06:10:21.512Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们知道，“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。&lt;/p&gt;
&lt;p&gt;解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：&lt;s</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程— Fork/Join：单机版的MapReduce</title>
    <link href="https://www.zhangquan.me/2023/07/12/java-bing-fa-bian-cheng-fork-join-dan-ji-ban-de-mapreduce/"/>
    <id>https://www.zhangquan.me/2023/07/12/java-bing-fa-bian-cheng-fork-join-dan-ji-ban-de-mapreduce/</id>
    <published>2023-07-12T10:48:30.000Z</published>
    <updated>2023-07-12T11:49:43.987Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们介绍了线程池、Future、CompletableFuture 和</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—CompletionService：如何批量执行异步任务？</title>
    <link href="https://www.zhangquan.me/2023/07/10/java-bing-fa-bian-cheng-completionservice-ru-he-pi-liang-zhi-xing-yi-bu-ren-wu/"/>
    <id>https://www.zhangquan.me/2023/07/10/java-bing-fa-bian-cheng-completionservice-ru-he-pi-liang-zhi-xing-yi-bu-ren-wu/</id>
    <published>2023-07-10T03:06:36.000Z</published>
    <updated>2023-07-10T03:08:25.943Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 &lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—CompletableFuture：异步编程没那么难</title>
    <link href="https://www.zhangquan.me/2023/07/07/java-bing-fa-bian-cheng-completablefuture-yi-bu-bian-cheng-mei-na-me-nan/"/>
    <id>https://www.zhangquan.me/2023/07/07/java-bing-fa-bian-cheng-completablefuture-yi-bu-bian-cheng-mei-na-me-nan/</id>
    <published>2023-07-07T03:23:03.000Z</published>
    <updated>2023-07-07T03:24:53.011Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们不止一次提到，用多线程优化性能，其实不过就是将串行操作变成并行操作。如果仔细观察，你还会发现在串行转换成并行的过程中，一定会涉及到异步化，例如下面的示例代码，现在是串行的，为了提升性能，我们得把它们并行化，那具体实施起来该怎么做呢？&lt;/p&gt;
&lt;pre</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Future：如何用多线程实现最优的“烧水泡茶”程序？</title>
    <link href="https://www.zhangquan.me/2023/07/05/java-bing-fa-bian-cheng-future-ru-he-yong-duo-xian-cheng-shi-xian-zui-you-de-shao-shui-pao-cha-cheng-xu/"/>
    <id>https://www.zhangquan.me/2023/07/05/java-bing-fa-bian-cheng-future-ru-he-yong-duo-xian-cheng-shi-xian-zui-you-de-shao-shui-pao-cha-cheng-xu/</id>
    <published>2023-07-05T02:18:29.000Z</published>
    <updated>2023-07-10T02:12:18.005Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 &lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—Executor与线程池：如何创建正确的线程池？</title>
    <link href="https://www.zhangquan.me/2023/07/04/java-bing-fa-bian-cheng-executor-yu-xian-cheng-chi-ru-he-chuang-jian-zheng-que-de-xian-cheng-chi/"/>
    <id>https://www.zhangquan.me/2023/07/04/java-bing-fa-bian-cheng-executor-yu-xian-cheng-chi-ru-he-chuang-jian-zheng-que-de-xian-cheng-chi/</id>
    <published>2023-07-04T01:42:52.000Z</published>
    <updated>2023-07-04T08:52:44.367Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;虽然在 Java 语言中创建线程看上去就像创建一个对象一样简单，只需要 new Thread() 就可以了，但实际上创建线程远不是创建一个对象那么简单。创建对象，仅仅是在 JVM 的堆里分配一块内存而已；而创建一个线程，却需要调用操作系统内核的</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—原子类：无锁工具类的典范</title>
    <link href="https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-yuan-zi-lei-wu-suo-gong-ju-lei-de-dian-fan/"/>
    <id>https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-yuan-zi-lei-wu-suo-gong-ju-lei-de-dian-fan/</id>
    <published>2023-07-03T05:43:30.000Z</published>
    <updated>2023-07-04T01:39:21.392Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们多次提到一个累加器的例子，示例代码如下。在这个例子中，add10K() 这个方法不是线程安全的，问题就出在变量 count 的可见性和 count+=1 的原子性上。可见性问题可以用 volatile</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—并发容器：都有哪些“坑”需要我们填？</title>
    <link href="https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-bing-fa-rong-qi-du-you-na-xie-keng-xu-yao-wo-men-tian/"/>
    <id>https://www.zhangquan.me/2023/07/03/java-bing-fa-bian-cheng-bing-fa-rong-qi-du-you-na-xie-keng-xu-yao-wo-men-tian/</id>
    <published>2023-07-03T05:32:46.000Z</published>
    <updated>2023-07-03T05:39:08.865Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Java 并发包有很大一部分内容都是关于&lt;strong&gt;并发容器&lt;/strong&gt;的，因此学习和搞懂这部分的内容很有必要。&lt;/p&gt;
&lt;p&gt;Java 1.5 之前提供的&lt;strong&gt;同步容器&lt;/strong&gt;虽然也能保证线程安全，但是性能很差，而 Java 1.5</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—CountDownLatch和CyclicBarrier：如何让多线程步调一致？</title>
    <link href="https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-countdownlatch-he-cyclicbarrier-ru-he-rang-duo-xian-cheng-bu-diao-yi-zhi/"/>
    <id>https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-countdownlatch-he-cyclicbarrier-ru-he-rang-duo-xian-cheng-bu-diao-yi-zhi/</id>
    <published>2023-06-30T07:25:09.000Z</published>
    <updated>2023-07-04T09:10:00.030Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前几天老板突然匆匆忙忙过来，说对账系统最近越来越慢了，能不能快速优化一下。我了解了对账系统的业务后，发现还是挺简单的，用户通过在线商城下单，会生成电子订单，保存在订单库；之后物流会生成派送单给用户发货，派送单保存在派送单库。为了防止漏派送或者重复派送，对账系统每天还会校验是</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—StampedLock：有没有比读写锁更快的锁？</title>
    <link href="https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-stampedlock-you-mei-you-bi-du-xie-suo-geng-kuai-de-suo/"/>
    <id>https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-stampedlock-you-mei-you-bi-du-xie-suo-geng-kuai-de-suo/</id>
    <published>2023-06-30T07:15:53.000Z</published>
    <updated>2023-07-04T01:39:13.405Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程—ReadWriteLock：如何快速实现一个完备的缓存？</title>
    <link href="https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-readwritelock-ru-he-kuai-su-shi-xian-yi-ge-wan-bei-de-huan-cun/"/>
    <id>https://www.zhangquan.me/2023/06/30/java-bing-fa-bian-cheng-readwritelock-ru-he-kuai-su-shi-xian-yi-ge-wan-bei-de-huan-cun/</id>
    <published>2023-06-30T07:01:15.000Z</published>
    <updated>2023-07-04T01:39:07.759Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前面我们介绍了&lt;a href=&quot;https://zhangquan.me/2023/06/15/java-bing-fa-bian-cheng-guan-cheng-bing-fa-bian-cheng-de-wan-neng-yao-chi/&quot;&gt;管程&lt;/a&gt;和&lt;a</summary>
        
      
    
    
    
    <category term="Java并发编程" scheme="https://www.zhangquan.me/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.zhangquan.me/tags/Java/"/>
    
    <category term="并发编程" scheme="https://www.zhangquan.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
